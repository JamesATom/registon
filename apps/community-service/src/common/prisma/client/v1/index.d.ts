/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model IeltsExam
 *
 */
export type IeltsExam = $Result.DefaultSelection<Prisma.$IeltsExamPayload>;
/**
 * Model IeltsRegistrationStudent
 *
 */
export type IeltsRegistrationStudent = $Result.DefaultSelection<Prisma.$IeltsRegistrationStudentPayload>;
/**
 * Model City
 *
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>;
/**
 * Model MockRegistration
 *
 */
export type MockRegistration = $Result.DefaultSelection<Prisma.$MockRegistrationPayload>;
/**
 * Model MockRegistrationStudent
 *
 */
export type MockRegistrationStudent = $Result.DefaultSelection<Prisma.$MockRegistrationStudentPayload>;
/**
 * Model JobHunting
 *
 */
export type JobHunting = $Result.DefaultSelection<Prisma.$JobHuntingPayload>;
/**
 * Model Company
 *
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>;
/**
 * Model CV
 *
 */
export type CV = $Result.DefaultSelection<Prisma.$CVPayload>;
/**
 * Model Skill
 *
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>;
/**
 * Model Tool
 *
 */
export type Tool = $Result.DefaultSelection<Prisma.$ToolPayload>;
/**
 * Model CvSkill
 *
 */
export type CvSkill = $Result.DefaultSelection<Prisma.$CvSkillPayload>;
/**
 * Model CvTool
 *
 */
export type CvTool = $Result.DefaultSelection<Prisma.$CvToolPayload>;
/**
 * Model Certificate
 *
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>;
/**
 * Model University
 *
 */
export type University = $Result.DefaultSelection<Prisma.$UniversityPayload>;
/**
 * Model Program
 *
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>;
/**
 * Model Faculty
 *
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>;
/**
 * Model CertificateRequirements
 *
 */
export type CertificateRequirements = $Result.DefaultSelection<Prisma.$CertificateRequirementsPayload>;

/**
 * Enums
 */
export namespace $Enums {
    export const WorkExperience: {
        Experience13: 'Experience13';
        Experience36: 'Experience36';
        Experience6Plus: 'Experience6Plus';
        NoExperience: 'NoExperience';
    };

    export type WorkExperience = (typeof WorkExperience)[keyof typeof WorkExperience];

    export const WorkScheduleHours: {
        Schedule61: 'Schedule61';
        Schedule52: 'Schedule52';
        Weekends: 'Weekends';
        Free: 'Free';
        Other: 'Other';
    };

    export type WorkScheduleHours = (typeof WorkScheduleHours)[keyof typeof WorkScheduleHours];

    export const EmploymentType: {
        Full: 'Full';
        Part: 'Part';
    };

    export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType];

    export const WorkMode: {
        Offline: 'Offline';
        Online: 'Online';
        Hybrid: 'Hybrid';
    };

    export type WorkMode = (typeof WorkMode)[keyof typeof WorkMode];

    export const Degree: {
        Bachelor: 'Bachelor';
        Master: 'Master';
        Doctorate: 'Doctorate';
        Associate: 'Associate';
        Phd: 'Phd';
    };

    export type Degree = (typeof Degree)[keyof typeof Degree];

    export const UniType: {
        Local: 'Local';
        International: 'International';
        Foreign: 'Foreign';
    };

    export type UniType = (typeof UniType)[keyof typeof UniType];

    export const StudyLanguage: {
        Uzbek: 'Uzbek';
        Russian: 'Russian';
        English: 'English';
    };

    export type StudyLanguage = (typeof StudyLanguage)[keyof typeof StudyLanguage];

    export const StudyType: {
        FullTime: 'FullTime';
        PartTime: 'PartTime';
        Remote: 'Remote';
        Hybrid: 'Hybrid';
    };

    export type StudyType = (typeof StudyType)[keyof typeof StudyType];
}

export type WorkExperience = $Enums.WorkExperience;

export const WorkExperience: typeof $Enums.WorkExperience;

export type WorkScheduleHours = $Enums.WorkScheduleHours;

export const WorkScheduleHours: typeof $Enums.WorkScheduleHours;

export type EmploymentType = $Enums.EmploymentType;

export const EmploymentType: typeof $Enums.EmploymentType;

export type WorkMode = $Enums.WorkMode;

export const WorkMode: typeof $Enums.WorkMode;

export type Degree = $Enums.Degree;

export const Degree: typeof $Enums.Degree;

export type UniType = $Enums.UniType;

export const UniType: typeof $Enums.UniType;

export type StudyLanguage = $Enums.StudyLanguage;

export const StudyLanguage: typeof $Enums.StudyLanguage;

export type StudyType = $Enums.StudyType;

export const StudyType: typeof $Enums.StudyType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more IeltsExams
 * const ieltsExams = await prisma.ieltsExam.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
    ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    U = 'log' extends keyof ClientOptions
        ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
            ? Prisma.GetEvents<ClientOptions['log']>
            : never
        : never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

    /**
     * ##  Prisma Client ʲˢ
     *
     * Type-safe database client for TypeScript & Node.js
     * @example
     * ```
     * const prisma = new PrismaClient()
     * // Fetch zero or more IeltsExams
     * const ieltsExams = await prisma.ieltsExam.findMany()
     * ```
     *
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
     */

    constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
    $on<V extends U>(
        eventType: V,
        callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void,
    ): PrismaClient;

    /**
     * Connect with the database
     */
    $connect(): $Utils.JsPromise<void>;

    /**
     * Disconnect from the database
     */
    $disconnect(): $Utils.JsPromise<void>;

    /**
     * Add a middleware
     * @deprecated since 4.16.0. For new code, prefer client extensions instead.
     * @see https://pris.ly/d/extensions
     */
    $use(cb: Prisma.Middleware): void;

    /**
     * Executes a prepared raw query and returns the number of affected rows.
     * @example
     * ```
     * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

    /**
     * Executes a raw query and returns the number of affected rows.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

    /**
     * Performs a prepared raw query and returns the `SELECT` data.
     * @example
     * ```
     * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

    /**
     * Performs a raw query and returns the `SELECT` data.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

    /**
     * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
     * @example
     * ```
     * const [george, bob, alice] = await prisma.$transaction([
     *   prisma.user.create({ data: { name: 'George' } }),
     *   prisma.user.create({ data: { name: 'Bob' } }),
     *   prisma.user.create({ data: { name: 'Alice' } }),
     * ])
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
     */
    $transaction<P extends Prisma.PrismaPromise<any>[]>(
        arg: [...P],
        options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
    ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

    $transaction<R>(
        fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
        options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel },
    ): $Utils.JsPromise<R>;

    $extends: $Extensions.ExtendsHook<
        'extends',
        Prisma.TypeMapCb<ClientOptions>,
        ExtArgs,
        $Utils.Call<
            Prisma.TypeMapCb<ClientOptions>,
            {
                extArgs: ExtArgs;
            }
        >
    >;

    /**
     * `prisma.ieltsExam`: Exposes CRUD operations for the **IeltsExam** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more IeltsExams
     * const ieltsExams = await prisma.ieltsExam.findMany()
     * ```
     */
    get ieltsExam(): Prisma.IeltsExamDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.ieltsRegistrationStudent`: Exposes CRUD operations for the **IeltsRegistrationStudent** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more IeltsRegistrationStudents
     * const ieltsRegistrationStudents = await prisma.ieltsRegistrationStudent.findMany()
     * ```
     */
    get ieltsRegistrationStudent(): Prisma.IeltsRegistrationStudentDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.city`: Exposes CRUD operations for the **City** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Cities
     * const cities = await prisma.city.findMany()
     * ```
     */
    get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.mockRegistration`: Exposes CRUD operations for the **MockRegistration** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more MockRegistrations
     * const mockRegistrations = await prisma.mockRegistration.findMany()
     * ```
     */
    get mockRegistration(): Prisma.MockRegistrationDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.mockRegistrationStudent`: Exposes CRUD operations for the **MockRegistrationStudent** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more MockRegistrationStudents
     * const mockRegistrationStudents = await prisma.mockRegistrationStudent.findMany()
     * ```
     */
    get mockRegistrationStudent(): Prisma.MockRegistrationStudentDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.jobHunting`: Exposes CRUD operations for the **JobHunting** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more JobHuntings
     * const jobHuntings = await prisma.jobHunting.findMany()
     * ```
     */
    get jobHunting(): Prisma.JobHuntingDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.company`: Exposes CRUD operations for the **Company** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Companies
     * const companies = await prisma.company.findMany()
     * ```
     */
    get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.cV`: Exposes CRUD operations for the **CV** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more CVS
     * const cVS = await prisma.cV.findMany()
     * ```
     */
    get cV(): Prisma.CVDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Skills
     * const skills = await prisma.skill.findMany()
     * ```
     */
    get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.tool`: Exposes CRUD operations for the **Tool** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Tools
     * const tools = await prisma.tool.findMany()
     * ```
     */
    get tool(): Prisma.ToolDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.cvSkill`: Exposes CRUD operations for the **CvSkill** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more CvSkills
     * const cvSkills = await prisma.cvSkill.findMany()
     * ```
     */
    get cvSkill(): Prisma.CvSkillDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.cvTool`: Exposes CRUD operations for the **CvTool** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more CvTools
     * const cvTools = await prisma.cvTool.findMany()
     * ```
     */
    get cvTool(): Prisma.CvToolDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Certificates
     * const certificates = await prisma.certificate.findMany()
     * ```
     */
    get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.university`: Exposes CRUD operations for the **University** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Universities
     * const universities = await prisma.university.findMany()
     * ```
     */
    get university(): Prisma.UniversityDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.program`: Exposes CRUD operations for the **Program** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Programs
     * const programs = await prisma.program.findMany()
     * ```
     */
    get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Faculties
     * const faculties = await prisma.faculty.findMany()
     * ```
     */
    get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

    /**
     * `prisma.certificateRequirements`: Exposes CRUD operations for the **CertificateRequirements** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more CertificateRequirements
     * const certificateRequirements = await prisma.certificateRequirements.findMany()
     * ```
     */
    get certificateRequirements(): Prisma.CertificateRequirementsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
    export import DMMF = runtime.DMMF;

    export type PrismaPromise<T> = $Public.PrismaPromise<T>;

    /**
     * Validator
     */
    export import validator = runtime.Public.validator;

    /**
     * Prisma Errors
     */
    export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
    export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
    export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
    export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
    export import PrismaClientValidationError = runtime.PrismaClientValidationError;

    /**
     * Re-export of sql-template-tag
     */
    export import sql = runtime.sqltag;
    export import empty = runtime.empty;
    export import join = runtime.join;
    export import raw = runtime.raw;
    export import Sql = runtime.Sql;

    /**
     * Decimal.js
     */
    export import Decimal = runtime.Decimal;

    export type DecimalJsLike = runtime.DecimalJsLike;

    /**
     * Metrics
     */
    export type Metrics = runtime.Metrics;
    export type Metric<T> = runtime.Metric<T>;
    export type MetricHistogram = runtime.MetricHistogram;
    export type MetricHistogramBucket = runtime.MetricHistogramBucket;

    /**
     * Extensions
     */
    export import Extension = $Extensions.UserArgs;
    export import getExtensionContext = runtime.Extensions.getExtensionContext;
    export import Args = $Public.Args;
    export import Payload = $Public.Payload;
    export import Result = $Public.Result;
    export import Exact = $Public.Exact;

    /**
     * Prisma Client JS version: 6.9.0
     * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
     */
    export type PrismaVersion = {
        client: string;
    };

    export const prismaVersion: PrismaVersion;

    /**
     * Utility Types
     */

    export import JsonObject = runtime.JsonObject;
    export import JsonArray = runtime.JsonArray;
    export import JsonValue = runtime.JsonValue;
    export import InputJsonObject = runtime.InputJsonObject;
    export import InputJsonArray = runtime.InputJsonArray;
    export import InputJsonValue = runtime.InputJsonValue;

    /**
     * Types of the values used to represent different kinds of `null` values when working with JSON fields.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    namespace NullTypes {
        /**
         * Type of `Prisma.DbNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class DbNull {
            private DbNull: never;
            private constructor();
        }

        /**
         * Type of `Prisma.JsonNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class JsonNull {
            private JsonNull: never;
            private constructor();
        }

        /**
         * Type of `Prisma.AnyNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class AnyNull {
            private AnyNull: never;
            private constructor();
        }
    }

    /**
     * Helper for filtering JSON entries that have `null` on the database (empty on the db)
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const DbNull: NullTypes.DbNull;

    /**
     * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const JsonNull: NullTypes.JsonNull;

    /**
     * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const AnyNull: NullTypes.AnyNull;

    type SelectAndInclude = {
        select: any;
        include: any;
    };

    type SelectAndOmit = {
        select: any;
        omit: any;
    };

    /**
     * Get the type of the value, that the Promise holds.
     */
    export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

    /**
     * Get the return type of a function which returns a Promise.
     */
    export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>;

    /**
     * From T, pick a set of properties whose keys are in the union K
     */
    type Prisma__Pick<T, K extends keyof T> = {
        [P in K]: T[P];
    };

    export type Enumerable<T> = T | Array<T>;

    export type RequiredKeys<T> = {
        [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
    }[keyof T];

    export type TruthyKeys<T> = keyof {
        [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
    };

    export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

    /**
     * Subset
     * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
     */
    export type Subset<T, U> = {
        [key in keyof T]: key extends keyof U ? T[key] : never;
    };

    /**
     * SelectSubset
     * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
     * Additionally, it validates, if both select and include are present. If the case, it errors.
     */
    export type SelectSubset<T, U> = {
        [key in keyof T]: key extends keyof U ? T[key] : never;
    } & (T extends SelectAndInclude
        ? 'Please either choose `select` or `include`.'
        : T extends SelectAndOmit
          ? 'Please either choose `select` or `omit`.'
          : {});

    /**
     * Subset + Intersection
     * @desc From `T` pick properties that exist in `U` and intersect `K`
     */
    export type SubsetIntersection<T, U, K> = {
        [key in keyof T]: key extends keyof U ? T[key] : never;
    } & K;

    type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

    /**
     * XOR is needed to have a real mutually exclusive union type
     * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
     */
    type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;

    /**
     * Is T a Record?
     */
    type IsObject<T extends any> =
        T extends Array<any>
            ? False
            : T extends Date
              ? False
              : T extends Uint8Array
                ? False
                : T extends BigInt
                  ? False
                  : T extends object
                    ? True
                    : False;

    /**
     * If it's T[], return T
     */
    export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

    /**
     * From ts-toolbelt
     */

    type __Either<O extends object, K extends Key> = Omit<O, K> &
        {
            // Merge all but K
            [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
        }[K];

    type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

    type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

    type _Either<O extends object, K extends Key, strict extends Boolean> = {
        1: EitherStrict<O, K>;
        0: EitherLoose<O, K>;
    }[strict];

    type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
        ? _Either<O, K, strict>
        : never;

    export type Union = any;

    type PatchUndefined<O extends object, O1 extends object> = {
        [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
    } & {};

    /** Helper Types for "Merge" **/
    export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void
        ? I
        : never;

    export type Overwrite<O extends object, O1 extends object> = {
        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
    } & {};

    type _Merge<U extends object> = IntersectOf<
        Overwrite<
            U,
            {
                [K in keyof U]-?: At<U, K>;
            }
        >
    >;

    type Key = string | number | symbol;
    type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
    type AtStrict<O extends object, K extends Key> = O[K & keyof O];
    type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
    export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
        1: AtStrict<O, K>;
        0: AtLoose<O, K>;
    }[strict];

    export type ComputeRaw<A extends any> = A extends Function
        ? A
        : {
              [K in keyof A]: A[K];
          } & {};

    export type OptionalFlat<O> = {
        [K in keyof O]?: O[K];
    } & {};

    type _Record<K extends keyof any, T> = {
        [P in K]: T;
    };

    // cause typescript not to expand types and preserve names
    type NoExpand<T> = T extends unknown ? T : never;

    // this type assumes the passed object is entirely optional
    type AtLeast<O extends object, K extends string> = NoExpand<
        O extends unknown
            ?
                  | (K extends keyof O ? { [P in K]: O[P] } & O : O)
                  | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
            : never
    >;

    type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

    export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
    /** End Helper Types for "Merge" **/

    export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

    /**
  A [[Boolean]]
  */
    export type Boolean = True | False;

    // /**
    // 1
    // */
    export type True = 1;

    /**
  0
  */
    export type False = 0;

    export type Not<B extends Boolean> = {
        0: 1;
        1: 0;
    }[B];

    export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
        ? 0 // anything `never` is false
        : A1 extends A2
          ? 1
          : 0;

    export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

    export type Or<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0;
            1: 1;
        };
        1: {
            0: 1;
            1: 1;
        };
    }[B1][B2];

    export type Keys<U extends Union> = U extends unknown ? keyof U : never;

    type Cast<A, B> = A extends B ? A : B;

    export const type: unique symbol;

    /**
     * Used by group by
     */

    export type GetScalarType<T, O> = O extends object
        ? {
              [P in keyof T]: P extends keyof O ? O[P] : never;
          }
        : never;

    type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> = IsObject<T> extends True ? U : T;

    type GetHavingFields<T> = {
        [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
            ? // infer is only needed to not hit TS limit
              // based on the brilliant idea of Pierre-Antoine Mills
              // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
              T[K] extends infer TK
                ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
                : never
            : {} extends FieldPaths<T[K]>
              ? never
              : K;
    }[keyof T];

    /**
     * Convert tuple to union
     */
    type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
    type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
    type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

    /**
     * Like `Pick`, but additionally can also accept an array of keys
     */
    type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

    /**
     * Exclude all keys with underscores
     */
    type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

    export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

    type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>;

    export const ModelName: {
        IeltsExam: 'IeltsExam';
        IeltsRegistrationStudent: 'IeltsRegistrationStudent';
        City: 'City';
        MockRegistration: 'MockRegistration';
        MockRegistrationStudent: 'MockRegistrationStudent';
        JobHunting: 'JobHunting';
        Company: 'Company';
        CV: 'CV';
        Skill: 'Skill';
        Tool: 'Tool';
        CvSkill: 'CvSkill';
        CvTool: 'CvTool';
        Certificate: 'Certificate';
        University: 'University';
        Program: 'Program';
        Faculty: 'Faculty';
        CertificateRequirements: 'CertificateRequirements';
    };

    export type ModelName = (typeof ModelName)[keyof typeof ModelName];

    export type Datasources = {
        db?: Datasource;
    };

    interface TypeMapCb<ClientOptions = {}>
        extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
        returns: Prisma.TypeMap<
            this['params']['extArgs'],
            ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
        >;
    }

    export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
        globalOmitOptions: {
            omit: GlobalOmitOptions;
        };
        meta: {
            modelProps:
                | 'ieltsExam'
                | 'ieltsRegistrationStudent'
                | 'city'
                | 'mockRegistration'
                | 'mockRegistrationStudent'
                | 'jobHunting'
                | 'company'
                | 'cV'
                | 'skill'
                | 'tool'
                | 'cvSkill'
                | 'cvTool'
                | 'certificate'
                | 'university'
                | 'program'
                | 'faculty'
                | 'certificateRequirements';
            txIsolationLevel: Prisma.TransactionIsolationLevel;
        };
        model: {
            IeltsExam: {
                payload: Prisma.$IeltsExamPayload<ExtArgs>;
                fields: Prisma.IeltsExamFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.IeltsExamFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.IeltsExamFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    findFirst: {
                        args: Prisma.IeltsExamFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.IeltsExamFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    findMany: {
                        args: Prisma.IeltsExamFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>[];
                    };
                    create: {
                        args: Prisma.IeltsExamCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    createMany: {
                        args: Prisma.IeltsExamCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.IeltsExamCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>[];
                    };
                    delete: {
                        args: Prisma.IeltsExamDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    update: {
                        args: Prisma.IeltsExamUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    deleteMany: {
                        args: Prisma.IeltsExamDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.IeltsExamUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.IeltsExamUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>[];
                    };
                    upsert: {
                        args: Prisma.IeltsExamUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsExamPayload>;
                    };
                    aggregate: {
                        args: Prisma.IeltsExamAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateIeltsExam>;
                    };
                    groupBy: {
                        args: Prisma.IeltsExamGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<IeltsExamGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.IeltsExamCountArgs<ExtArgs>;
                        result: $Utils.Optional<IeltsExamCountAggregateOutputType> | number;
                    };
                };
            };
            IeltsRegistrationStudent: {
                payload: Prisma.$IeltsRegistrationStudentPayload<ExtArgs>;
                fields: Prisma.IeltsRegistrationStudentFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.IeltsRegistrationStudentFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.IeltsRegistrationStudentFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    findFirst: {
                        args: Prisma.IeltsRegistrationStudentFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.IeltsRegistrationStudentFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    findMany: {
                        args: Prisma.IeltsRegistrationStudentFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>[];
                    };
                    create: {
                        args: Prisma.IeltsRegistrationStudentCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    createMany: {
                        args: Prisma.IeltsRegistrationStudentCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.IeltsRegistrationStudentCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>[];
                    };
                    delete: {
                        args: Prisma.IeltsRegistrationStudentDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    update: {
                        args: Prisma.IeltsRegistrationStudentUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    deleteMany: {
                        args: Prisma.IeltsRegistrationStudentDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.IeltsRegistrationStudentUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.IeltsRegistrationStudentUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>[];
                    };
                    upsert: {
                        args: Prisma.IeltsRegistrationStudentUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$IeltsRegistrationStudentPayload>;
                    };
                    aggregate: {
                        args: Prisma.IeltsRegistrationStudentAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateIeltsRegistrationStudent>;
                    };
                    groupBy: {
                        args: Prisma.IeltsRegistrationStudentGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<IeltsRegistrationStudentGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.IeltsRegistrationStudentCountArgs<ExtArgs>;
                        result: $Utils.Optional<IeltsRegistrationStudentCountAggregateOutputType> | number;
                    };
                };
            };
            City: {
                payload: Prisma.$CityPayload<ExtArgs>;
                fields: Prisma.CityFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CityFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    findFirst: {
                        args: Prisma.CityFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    findMany: {
                        args: Prisma.CityFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>[];
                    };
                    create: {
                        args: Prisma.CityCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    createMany: {
                        args: Prisma.CityCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>[];
                    };
                    delete: {
                        args: Prisma.CityDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    update: {
                        args: Prisma.CityUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CityDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CityUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>[];
                    };
                    upsert: {
                        args: Prisma.CityUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CityPayload>;
                    };
                    aggregate: {
                        args: Prisma.CityAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCity>;
                    };
                    groupBy: {
                        args: Prisma.CityGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CityGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CityCountArgs<ExtArgs>;
                        result: $Utils.Optional<CityCountAggregateOutputType> | number;
                    };
                };
            };
            MockRegistration: {
                payload: Prisma.$MockRegistrationPayload<ExtArgs>;
                fields: Prisma.MockRegistrationFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.MockRegistrationFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.MockRegistrationFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    findFirst: {
                        args: Prisma.MockRegistrationFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.MockRegistrationFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    findMany: {
                        args: Prisma.MockRegistrationFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>[];
                    };
                    create: {
                        args: Prisma.MockRegistrationCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    createMany: {
                        args: Prisma.MockRegistrationCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.MockRegistrationCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>[];
                    };
                    delete: {
                        args: Prisma.MockRegistrationDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    update: {
                        args: Prisma.MockRegistrationUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    deleteMany: {
                        args: Prisma.MockRegistrationDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.MockRegistrationUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.MockRegistrationUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>[];
                    };
                    upsert: {
                        args: Prisma.MockRegistrationUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationPayload>;
                    };
                    aggregate: {
                        args: Prisma.MockRegistrationAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateMockRegistration>;
                    };
                    groupBy: {
                        args: Prisma.MockRegistrationGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<MockRegistrationGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.MockRegistrationCountArgs<ExtArgs>;
                        result: $Utils.Optional<MockRegistrationCountAggregateOutputType> | number;
                    };
                };
            };
            MockRegistrationStudent: {
                payload: Prisma.$MockRegistrationStudentPayload<ExtArgs>;
                fields: Prisma.MockRegistrationStudentFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.MockRegistrationStudentFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.MockRegistrationStudentFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    findFirst: {
                        args: Prisma.MockRegistrationStudentFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.MockRegistrationStudentFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    findMany: {
                        args: Prisma.MockRegistrationStudentFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>[];
                    };
                    create: {
                        args: Prisma.MockRegistrationStudentCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    createMany: {
                        args: Prisma.MockRegistrationStudentCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.MockRegistrationStudentCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>[];
                    };
                    delete: {
                        args: Prisma.MockRegistrationStudentDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    update: {
                        args: Prisma.MockRegistrationStudentUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    deleteMany: {
                        args: Prisma.MockRegistrationStudentDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.MockRegistrationStudentUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.MockRegistrationStudentUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>[];
                    };
                    upsert: {
                        args: Prisma.MockRegistrationStudentUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$MockRegistrationStudentPayload>;
                    };
                    aggregate: {
                        args: Prisma.MockRegistrationStudentAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateMockRegistrationStudent>;
                    };
                    groupBy: {
                        args: Prisma.MockRegistrationStudentGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<MockRegistrationStudentGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.MockRegistrationStudentCountArgs<ExtArgs>;
                        result: $Utils.Optional<MockRegistrationStudentCountAggregateOutputType> | number;
                    };
                };
            };
            JobHunting: {
                payload: Prisma.$JobHuntingPayload<ExtArgs>;
                fields: Prisma.JobHuntingFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.JobHuntingFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.JobHuntingFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    findFirst: {
                        args: Prisma.JobHuntingFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.JobHuntingFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    findMany: {
                        args: Prisma.JobHuntingFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>[];
                    };
                    create: {
                        args: Prisma.JobHuntingCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    createMany: {
                        args: Prisma.JobHuntingCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.JobHuntingCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>[];
                    };
                    delete: {
                        args: Prisma.JobHuntingDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    update: {
                        args: Prisma.JobHuntingUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    deleteMany: {
                        args: Prisma.JobHuntingDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.JobHuntingUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.JobHuntingUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>[];
                    };
                    upsert: {
                        args: Prisma.JobHuntingUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$JobHuntingPayload>;
                    };
                    aggregate: {
                        args: Prisma.JobHuntingAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateJobHunting>;
                    };
                    groupBy: {
                        args: Prisma.JobHuntingGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<JobHuntingGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.JobHuntingCountArgs<ExtArgs>;
                        result: $Utils.Optional<JobHuntingCountAggregateOutputType> | number;
                    };
                };
            };
            Company: {
                payload: Prisma.$CompanyPayload<ExtArgs>;
                fields: Prisma.CompanyFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CompanyFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    findFirst: {
                        args: Prisma.CompanyFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    findMany: {
                        args: Prisma.CompanyFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                    };
                    create: {
                        args: Prisma.CompanyCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    createMany: {
                        args: Prisma.CompanyCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                    };
                    delete: {
                        args: Prisma.CompanyDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    update: {
                        args: Prisma.CompanyUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CompanyDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CompanyUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                    };
                    upsert: {
                        args: Prisma.CompanyUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CompanyPayload>;
                    };
                    aggregate: {
                        args: Prisma.CompanyAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCompany>;
                    };
                    groupBy: {
                        args: Prisma.CompanyGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CompanyGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CompanyCountArgs<ExtArgs>;
                        result: $Utils.Optional<CompanyCountAggregateOutputType> | number;
                    };
                };
            };
            CV: {
                payload: Prisma.$CVPayload<ExtArgs>;
                fields: Prisma.CVFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CVFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CVFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    findFirst: {
                        args: Prisma.CVFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CVFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    findMany: {
                        args: Prisma.CVFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>[];
                    };
                    create: {
                        args: Prisma.CVCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    createMany: {
                        args: Prisma.CVCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CVCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>[];
                    };
                    delete: {
                        args: Prisma.CVDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    update: {
                        args: Prisma.CVUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CVDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CVUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CVUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>[];
                    };
                    upsert: {
                        args: Prisma.CVUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CVPayload>;
                    };
                    aggregate: {
                        args: Prisma.CVAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCV>;
                    };
                    groupBy: {
                        args: Prisma.CVGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CVGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CVCountArgs<ExtArgs>;
                        result: $Utils.Optional<CVCountAggregateOutputType> | number;
                    };
                };
            };
            Skill: {
                payload: Prisma.$SkillPayload<ExtArgs>;
                fields: Prisma.SkillFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.SkillFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    findFirst: {
                        args: Prisma.SkillFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    findMany: {
                        args: Prisma.SkillFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>[];
                    };
                    create: {
                        args: Prisma.SkillCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    createMany: {
                        args: Prisma.SkillCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>[];
                    };
                    delete: {
                        args: Prisma.SkillDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    update: {
                        args: Prisma.SkillUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    deleteMany: {
                        args: Prisma.SkillDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.SkillUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>[];
                    };
                    upsert: {
                        args: Prisma.SkillUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$SkillPayload>;
                    };
                    aggregate: {
                        args: Prisma.SkillAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateSkill>;
                    };
                    groupBy: {
                        args: Prisma.SkillGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<SkillGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.SkillCountArgs<ExtArgs>;
                        result: $Utils.Optional<SkillCountAggregateOutputType> | number;
                    };
                };
            };
            Tool: {
                payload: Prisma.$ToolPayload<ExtArgs>;
                fields: Prisma.ToolFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.ToolFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.ToolFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    findFirst: {
                        args: Prisma.ToolFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.ToolFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    findMany: {
                        args: Prisma.ToolFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>[];
                    };
                    create: {
                        args: Prisma.ToolCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    createMany: {
                        args: Prisma.ToolCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.ToolCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>[];
                    };
                    delete: {
                        args: Prisma.ToolDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    update: {
                        args: Prisma.ToolUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    deleteMany: {
                        args: Prisma.ToolDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.ToolUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.ToolUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>[];
                    };
                    upsert: {
                        args: Prisma.ToolUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ToolPayload>;
                    };
                    aggregate: {
                        args: Prisma.ToolAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateTool>;
                    };
                    groupBy: {
                        args: Prisma.ToolGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<ToolGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.ToolCountArgs<ExtArgs>;
                        result: $Utils.Optional<ToolCountAggregateOutputType> | number;
                    };
                };
            };
            CvSkill: {
                payload: Prisma.$CvSkillPayload<ExtArgs>;
                fields: Prisma.CvSkillFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CvSkillFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CvSkillFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    findFirst: {
                        args: Prisma.CvSkillFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CvSkillFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    findMany: {
                        args: Prisma.CvSkillFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>[];
                    };
                    create: {
                        args: Prisma.CvSkillCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    createMany: {
                        args: Prisma.CvSkillCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CvSkillCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>[];
                    };
                    delete: {
                        args: Prisma.CvSkillDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    update: {
                        args: Prisma.CvSkillUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CvSkillDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CvSkillUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CvSkillUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>[];
                    };
                    upsert: {
                        args: Prisma.CvSkillUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvSkillPayload>;
                    };
                    aggregate: {
                        args: Prisma.CvSkillAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCvSkill>;
                    };
                    groupBy: {
                        args: Prisma.CvSkillGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CvSkillGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CvSkillCountArgs<ExtArgs>;
                        result: $Utils.Optional<CvSkillCountAggregateOutputType> | number;
                    };
                };
            };
            CvTool: {
                payload: Prisma.$CvToolPayload<ExtArgs>;
                fields: Prisma.CvToolFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CvToolFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CvToolFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    findFirst: {
                        args: Prisma.CvToolFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CvToolFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    findMany: {
                        args: Prisma.CvToolFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>[];
                    };
                    create: {
                        args: Prisma.CvToolCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    createMany: {
                        args: Prisma.CvToolCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CvToolCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>[];
                    };
                    delete: {
                        args: Prisma.CvToolDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    update: {
                        args: Prisma.CvToolUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CvToolDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CvToolUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CvToolUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>[];
                    };
                    upsert: {
                        args: Prisma.CvToolUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CvToolPayload>;
                    };
                    aggregate: {
                        args: Prisma.CvToolAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCvTool>;
                    };
                    groupBy: {
                        args: Prisma.CvToolGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CvToolGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CvToolCountArgs<ExtArgs>;
                        result: $Utils.Optional<CvToolCountAggregateOutputType> | number;
                    };
                };
            };
            Certificate: {
                payload: Prisma.$CertificatePayload<ExtArgs>;
                fields: Prisma.CertificateFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CertificateFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    findFirst: {
                        args: Prisma.CertificateFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    findMany: {
                        args: Prisma.CertificateFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[];
                    };
                    create: {
                        args: Prisma.CertificateCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    createMany: {
                        args: Prisma.CertificateCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[];
                    };
                    delete: {
                        args: Prisma.CertificateDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    update: {
                        args: Prisma.CertificateUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    deleteMany: {
                        args: Prisma.CertificateDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CertificateUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[];
                    };
                    upsert: {
                        args: Prisma.CertificateUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificatePayload>;
                    };
                    aggregate: {
                        args: Prisma.CertificateAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCertificate>;
                    };
                    groupBy: {
                        args: Prisma.CertificateGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CertificateGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CertificateCountArgs<ExtArgs>;
                        result: $Utils.Optional<CertificateCountAggregateOutputType> | number;
                    };
                };
            };
            University: {
                payload: Prisma.$UniversityPayload<ExtArgs>;
                fields: Prisma.UniversityFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.UniversityFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.UniversityFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    findFirst: {
                        args: Prisma.UniversityFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.UniversityFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    findMany: {
                        args: Prisma.UniversityFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[];
                    };
                    create: {
                        args: Prisma.UniversityCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    createMany: {
                        args: Prisma.UniversityCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.UniversityCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[];
                    };
                    delete: {
                        args: Prisma.UniversityDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    update: {
                        args: Prisma.UniversityUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    deleteMany: {
                        args: Prisma.UniversityDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.UniversityUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.UniversityUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[];
                    };
                    upsert: {
                        args: Prisma.UniversityUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$UniversityPayload>;
                    };
                    aggregate: {
                        args: Prisma.UniversityAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateUniversity>;
                    };
                    groupBy: {
                        args: Prisma.UniversityGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<UniversityGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.UniversityCountArgs<ExtArgs>;
                        result: $Utils.Optional<UniversityCountAggregateOutputType> | number;
                    };
                };
            };
            Program: {
                payload: Prisma.$ProgramPayload<ExtArgs>;
                fields: Prisma.ProgramFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.ProgramFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    findFirst: {
                        args: Prisma.ProgramFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    findMany: {
                        args: Prisma.ProgramFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[];
                    };
                    create: {
                        args: Prisma.ProgramCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    createMany: {
                        args: Prisma.ProgramCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[];
                    };
                    delete: {
                        args: Prisma.ProgramDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    update: {
                        args: Prisma.ProgramUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    deleteMany: {
                        args: Prisma.ProgramDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.ProgramUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[];
                    };
                    upsert: {
                        args: Prisma.ProgramUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$ProgramPayload>;
                    };
                    aggregate: {
                        args: Prisma.ProgramAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateProgram>;
                    };
                    groupBy: {
                        args: Prisma.ProgramGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<ProgramGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.ProgramCountArgs<ExtArgs>;
                        result: $Utils.Optional<ProgramCountAggregateOutputType> | number;
                    };
                };
            };
            Faculty: {
                payload: Prisma.$FacultyPayload<ExtArgs>;
                fields: Prisma.FacultyFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.FacultyFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    findFirst: {
                        args: Prisma.FacultyFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    findMany: {
                        args: Prisma.FacultyFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
                    };
                    create: {
                        args: Prisma.FacultyCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    createMany: {
                        args: Prisma.FacultyCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.FacultyCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
                    };
                    delete: {
                        args: Prisma.FacultyDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    update: {
                        args: Prisma.FacultyUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    deleteMany: {
                        args: Prisma.FacultyDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.FacultyUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.FacultyUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[];
                    };
                    upsert: {
                        args: Prisma.FacultyUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$FacultyPayload>;
                    };
                    aggregate: {
                        args: Prisma.FacultyAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateFaculty>;
                    };
                    groupBy: {
                        args: Prisma.FacultyGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<FacultyGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.FacultyCountArgs<ExtArgs>;
                        result: $Utils.Optional<FacultyCountAggregateOutputType> | number;
                    };
                };
            };
            CertificateRequirements: {
                payload: Prisma.$CertificateRequirementsPayload<ExtArgs>;
                fields: Prisma.CertificateRequirementsFieldRefs;
                operations: {
                    findUnique: {
                        args: Prisma.CertificateRequirementsFindUniqueArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload> | null;
                    };
                    findUniqueOrThrow: {
                        args: Prisma.CertificateRequirementsFindUniqueOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    findFirst: {
                        args: Prisma.CertificateRequirementsFindFirstArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload> | null;
                    };
                    findFirstOrThrow: {
                        args: Prisma.CertificateRequirementsFindFirstOrThrowArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    findMany: {
                        args: Prisma.CertificateRequirementsFindManyArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>[];
                    };
                    create: {
                        args: Prisma.CertificateRequirementsCreateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    createMany: {
                        args: Prisma.CertificateRequirementsCreateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    createManyAndReturn: {
                        args: Prisma.CertificateRequirementsCreateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>[];
                    };
                    delete: {
                        args: Prisma.CertificateRequirementsDeleteArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    update: {
                        args: Prisma.CertificateRequirementsUpdateArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    deleteMany: {
                        args: Prisma.CertificateRequirementsDeleteManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateMany: {
                        args: Prisma.CertificateRequirementsUpdateManyArgs<ExtArgs>;
                        result: BatchPayload;
                    };
                    updateManyAndReturn: {
                        args: Prisma.CertificateRequirementsUpdateManyAndReturnArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>[];
                    };
                    upsert: {
                        args: Prisma.CertificateRequirementsUpsertArgs<ExtArgs>;
                        result: $Utils.PayloadToResult<Prisma.$CertificateRequirementsPayload>;
                    };
                    aggregate: {
                        args: Prisma.CertificateRequirementsAggregateArgs<ExtArgs>;
                        result: $Utils.Optional<AggregateCertificateRequirements>;
                    };
                    groupBy: {
                        args: Prisma.CertificateRequirementsGroupByArgs<ExtArgs>;
                        result: $Utils.Optional<CertificateRequirementsGroupByOutputType>[];
                    };
                    count: {
                        args: Prisma.CertificateRequirementsCountArgs<ExtArgs>;
                        result: $Utils.Optional<CertificateRequirementsCountAggregateOutputType> | number;
                    };
                };
            };
        };
    } & {
        other: {
            payload: any;
            operations: {
                $executeRaw: {
                    args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
                    result: any;
                };
                $executeRawUnsafe: {
                    args: [query: string, ...values: any[]];
                    result: any;
                };
                $queryRaw: {
                    args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
                    result: any;
                };
                $queryRawUnsafe: {
                    args: [query: string, ...values: any[]];
                    result: any;
                };
            };
        };
    };
    export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>;
    export type DefaultPrismaClient = PrismaClient;
    export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
    export interface PrismaClientOptions {
        /**
         * Overwrites the datasource url from your schema.prisma file
         */
        datasources?: Datasources;
        /**
         * Overwrites the datasource url from your schema.prisma file
         */
        datasourceUrl?: string;
        /**
         * @default "colorless"
         */
        errorFormat?: ErrorFormat;
        /**
         * @example
         * ```
         * // Defaults to stdout
         * log: ['query', 'info', 'warn', 'error']
         *
         * // Emit as events
         * log: [
         *   { emit: 'stdout', level: 'query' },
         *   { emit: 'stdout', level: 'info' },
         *   { emit: 'stdout', level: 'warn' }
         *   { emit: 'stdout', level: 'error' }
         * ]
         * ```
         * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
         */
        log?: (LogLevel | LogDefinition)[];
        /**
         * The default values for transactionOptions
         * maxWait ?= 2000
         * timeout ?= 5000
         */
        transactionOptions?: {
            maxWait?: number;
            timeout?: number;
            isolationLevel?: Prisma.TransactionIsolationLevel;
        };
        /**
         * Global configuration for omitting model fields by default.
         *
         * @example
         * ```
         * const prisma = new PrismaClient({
         *   omit: {
         *     user: {
         *       password: true
         *     }
         *   }
         * })
         * ```
         */
        omit?: Prisma.GlobalOmitConfig;
    }
    export type GlobalOmitConfig = {
        ieltsExam?: IeltsExamOmit;
        ieltsRegistrationStudent?: IeltsRegistrationStudentOmit;
        city?: CityOmit;
        mockRegistration?: MockRegistrationOmit;
        mockRegistrationStudent?: MockRegistrationStudentOmit;
        jobHunting?: JobHuntingOmit;
        company?: CompanyOmit;
        cV?: CVOmit;
        skill?: SkillOmit;
        tool?: ToolOmit;
        cvSkill?: CvSkillOmit;
        cvTool?: CvToolOmit;
        certificate?: CertificateOmit;
        university?: UniversityOmit;
        program?: ProgramOmit;
        faculty?: FacultyOmit;
        certificateRequirements?: CertificateRequirementsOmit;
    };

    /* Types for Logging */
    export type LogLevel = 'info' | 'query' | 'warn' | 'error';
    export type LogDefinition = {
        level: LogLevel;
        emit: 'stdout' | 'event';
    };

    export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
        ? T['emit'] extends 'event'
            ? T['level']
            : never
        : never;
    export type GetEvents<T extends any> =
        T extends Array<LogLevel | LogDefinition>
            ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
            : never;

    export type QueryEvent = {
        timestamp: Date;
        query: string;
        params: string;
        duration: number;
        target: string;
    };

    export type LogEvent = {
        timestamp: Date;
        message: string;
        target: string;
    };
    /* End Types for Logging */

    export type PrismaAction =
        | 'findUnique'
        | 'findUniqueOrThrow'
        | 'findMany'
        | 'findFirst'
        | 'findFirstOrThrow'
        | 'create'
        | 'createMany'
        | 'createManyAndReturn'
        | 'update'
        | 'updateMany'
        | 'updateManyAndReturn'
        | 'upsert'
        | 'delete'
        | 'deleteMany'
        | 'executeRaw'
        | 'queryRaw'
        | 'aggregate'
        | 'count'
        | 'runCommandRaw'
        | 'findRaw'
        | 'groupBy';

    /**
     * These options are being passed into the middleware as "params"
     */
    export type MiddlewareParams = {
        model?: ModelName;
        action: PrismaAction;
        args: any;
        dataPath: string[];
        runInTransaction: boolean;
    };

    /**
     * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
     */
    export type Middleware<T = any> = (
        params: MiddlewareParams,
        next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
    ) => $Utils.JsPromise<T>;

    // tested in getLogLevel.test.ts
    export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

    /**
     * `PrismaClient` proxy available in interactive transactions.
     */
    export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

    export type Datasource = {
        url?: string;
    };

    /**
     * Count Types
     */

    /**
     * Count Type IeltsExamCountOutputType
     */

    export type IeltsExamCountOutputType = {
        students: number;
    };

    export type IeltsExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        students?: boolean | IeltsExamCountOutputTypeCountStudentsArgs;
    };

    // Custom InputTypes
    /**
     * IeltsExamCountOutputType without action
     */
    export type IeltsExamCountOutputTypeDefaultArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsExamCountOutputType
         */
        select?: IeltsExamCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * IeltsExamCountOutputType without action
     */
    export type IeltsExamCountOutputTypeCountStudentsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: IeltsRegistrationStudentWhereInput;
    };

    /**
     * Count Type CityCountOutputType
     */

    export type CityCountOutputType = {
        ieltsExams: number;
        jobHuntings: number;
        cvs: number;
        universities: number;
    };

    export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        ieltsExams?: boolean | CityCountOutputTypeCountIeltsExamsArgs;
        jobHuntings?: boolean | CityCountOutputTypeCountJobHuntingsArgs;
        cvs?: boolean | CityCountOutputTypeCountCvsArgs;
        universities?: boolean | CityCountOutputTypeCountUniversitiesArgs;
    };

    // Custom InputTypes
    /**
     * CityCountOutputType without action
     */
    export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CityCountOutputType
         */
        select?: CityCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * CityCountOutputType without action
     */
    export type CityCountOutputTypeCountIeltsExamsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: IeltsExamWhereInput;
    };

    /**
     * CityCountOutputType without action
     */
    export type CityCountOutputTypeCountJobHuntingsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: JobHuntingWhereInput;
    };

    /**
     * CityCountOutputType without action
     */
    export type CityCountOutputTypeCountCvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CVWhereInput;
    };

    /**
     * CityCountOutputType without action
     */
    export type CityCountOutputTypeCountUniversitiesArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: UniversityWhereInput;
    };

    /**
     * Count Type MockRegistrationCountOutputType
     */

    export type MockRegistrationCountOutputType = {
        students: number;
    };

    export type MockRegistrationCountOutputTypeSelect<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        students?: boolean | MockRegistrationCountOutputTypeCountStudentsArgs;
    };

    // Custom InputTypes
    /**
     * MockRegistrationCountOutputType without action
     */
    export type MockRegistrationCountOutputTypeDefaultArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationCountOutputType
         */
        select?: MockRegistrationCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * MockRegistrationCountOutputType without action
     */
    export type MockRegistrationCountOutputTypeCountStudentsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: MockRegistrationStudentWhereInput;
    };

    /**
     * Count Type CompanyCountOutputType
     */

    export type CompanyCountOutputType = {
        jobHuntings: number;
    };

    export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        jobHuntings?: boolean | CompanyCountOutputTypeCountJobHuntingsArgs;
    };

    // Custom InputTypes
    /**
     * CompanyCountOutputType without action
     */
    export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CompanyCountOutputType
             */
            select?: CompanyCountOutputTypeSelect<ExtArgs> | null;
        };

    /**
     * CompanyCountOutputType without action
     */
    export type CompanyCountOutputTypeCountJobHuntingsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: JobHuntingWhereInput;
    };

    /**
     * Count Type CVCountOutputType
     */

    export type CVCountOutputType = {
        skills: number;
        tools: number;
    };

    export type CVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        skills?: boolean | CVCountOutputTypeCountSkillsArgs;
        tools?: boolean | CVCountOutputTypeCountToolsArgs;
    };

    // Custom InputTypes
    /**
     * CVCountOutputType without action
     */
    export type CVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CVCountOutputType
         */
        select?: CVCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * CVCountOutputType without action
     */
    export type CVCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvSkillWhereInput;
    };

    /**
     * CVCountOutputType without action
     */
    export type CVCountOutputTypeCountToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvToolWhereInput;
    };

    /**
     * Count Type SkillCountOutputType
     */

    export type SkillCountOutputType = {
        cvs: number;
    };

    export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cvs?: boolean | SkillCountOutputTypeCountCvsArgs;
    };

    // Custom InputTypes
    /**
     * SkillCountOutputType without action
     */
    export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the SkillCountOutputType
         */
        select?: SkillCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * SkillCountOutputType without action
     */
    export type SkillCountOutputTypeCountCvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvSkillWhereInput;
    };

    /**
     * Count Type ToolCountOutputType
     */

    export type ToolCountOutputType = {
        cvs: number;
    };

    export type ToolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cvs?: boolean | ToolCountOutputTypeCountCvsArgs;
    };

    // Custom InputTypes
    /**
     * ToolCountOutputType without action
     */
    export type ToolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the ToolCountOutputType
         */
        select?: ToolCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * ToolCountOutputType without action
     */
    export type ToolCountOutputTypeCountCvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvToolWhereInput;
    };

    /**
     * Count Type UniversityCountOutputType
     */

    export type UniversityCountOutputType = {
        programs: number;
        faculties: number;
    };

    export type UniversityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        programs?: boolean | UniversityCountOutputTypeCountProgramsArgs;
        faculties?: boolean | UniversityCountOutputTypeCountFacultiesArgs;
    };

    // Custom InputTypes
    /**
     * UniversityCountOutputType without action
     */
    export type UniversityCountOutputTypeDefaultArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the UniversityCountOutputType
         */
        select?: UniversityCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * UniversityCountOutputType without action
     */
    export type UniversityCountOutputTypeCountProgramsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: ProgramWhereInput;
    };

    /**
     * UniversityCountOutputType without action
     */
    export type UniversityCountOutputTypeCountFacultiesArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: FacultyWhereInput;
    };

    /**
     * Count Type FacultyCountOutputType
     */

    export type FacultyCountOutputType = {
        programs: number;
    };

    export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        programs?: boolean | FacultyCountOutputTypeCountProgramsArgs;
    };

    // Custom InputTypes
    /**
     * FacultyCountOutputType without action
     */
    export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the FacultyCountOutputType
             */
            select?: FacultyCountOutputTypeSelect<ExtArgs> | null;
        };

    /**
     * FacultyCountOutputType without action
     */
    export type FacultyCountOutputTypeCountProgramsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: ProgramWhereInput;
    };

    /**
     * Count Type CertificateRequirementsCountOutputType
     */

    export type CertificateRequirementsCountOutputType = {
        universities: number;
        programs: number;
    };

    export type CertificateRequirementsCountOutputTypeSelect<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        universities?: boolean | CertificateRequirementsCountOutputTypeCountUniversitiesArgs;
        programs?: boolean | CertificateRequirementsCountOutputTypeCountProgramsArgs;
    };

    // Custom InputTypes
    /**
     * CertificateRequirementsCountOutputType without action
     */
    export type CertificateRequirementsCountOutputTypeDefaultArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirementsCountOutputType
         */
        select?: CertificateRequirementsCountOutputTypeSelect<ExtArgs> | null;
    };

    /**
     * CertificateRequirementsCountOutputType without action
     */
    export type CertificateRequirementsCountOutputTypeCountUniversitiesArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: UniversityWhereInput;
    };

    /**
     * CertificateRequirementsCountOutputType without action
     */
    export type CertificateRequirementsCountOutputTypeCountProgramsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: ProgramWhereInput;
    };

    /**
     * Models
     */

    /**
     * Model IeltsExam
     */

    export type AggregateIeltsExam = {
        _count: IeltsExamCountAggregateOutputType | null;
        _min: IeltsExamMinAggregateOutputType | null;
        _max: IeltsExamMaxAggregateOutputType | null;
    };

    export type IeltsExamMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        dateExam: Date | null;
        cityId: string | null;
        isActive: boolean | null;
        commentUser: string | null;
        commentAdmin: string | null;
    };

    export type IeltsExamMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        dateExam: Date | null;
        cityId: string | null;
        isActive: boolean | null;
        commentUser: string | null;
        commentAdmin: string | null;
    };

    export type IeltsExamCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        dateExam: number;
        cityId: number;
        isActive: number;
        commentUser: number;
        commentAdmin: number;
        _all: number;
    };

    export type IeltsExamMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        dateExam?: true;
        cityId?: true;
        isActive?: true;
        commentUser?: true;
        commentAdmin?: true;
    };

    export type IeltsExamMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        dateExam?: true;
        cityId?: true;
        isActive?: true;
        commentUser?: true;
        commentAdmin?: true;
    };

    export type IeltsExamCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        dateExam?: true;
        cityId?: true;
        isActive?: true;
        commentUser?: true;
        commentAdmin?: true;
        _all?: true;
    };

    export type IeltsExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which IeltsExam to aggregate.
         */
        where?: IeltsExamWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsExams to fetch.
         */
        orderBy?: IeltsExamOrderByWithRelationInput | IeltsExamOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: IeltsExamWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsExams from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsExams.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned IeltsExams
         **/
        _count?: true | IeltsExamCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: IeltsExamMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: IeltsExamMaxAggregateInputType;
    };

    export type GetIeltsExamAggregateType<T extends IeltsExamAggregateArgs> = {
        [P in keyof T & keyof AggregateIeltsExam]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateIeltsExam[P]>
            : GetScalarType<T[P], AggregateIeltsExam[P]>;
    };

    export type IeltsExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: IeltsExamWhereInput;
        orderBy?: IeltsExamOrderByWithAggregationInput | IeltsExamOrderByWithAggregationInput[];
        by: IeltsExamScalarFieldEnum[] | IeltsExamScalarFieldEnum;
        having?: IeltsExamScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: IeltsExamCountAggregateInputType | true;
        _min?: IeltsExamMinAggregateInputType;
        _max?: IeltsExamMaxAggregateInputType;
    };

    export type IeltsExamGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string;
        updatedAt: Date;
        updatedBy: string | null;
        dateExam: Date;
        cityId: string;
        isActive: boolean | null;
        commentUser: string | null;
        commentAdmin: string | null;
        _count: IeltsExamCountAggregateOutputType | null;
        _min: IeltsExamMinAggregateOutputType | null;
        _max: IeltsExamMaxAggregateOutputType | null;
    };

    type GetIeltsExamGroupByPayload<T extends IeltsExamGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<IeltsExamGroupByOutputType, T['by']> & {
                [P in keyof T & keyof IeltsExamGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], IeltsExamGroupByOutputType[P]>
                    : GetScalarType<T[P], IeltsExamGroupByOutputType[P]>;
            }
        >
    >;

    export type IeltsExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                dateExam?: boolean;
                cityId?: boolean;
                isActive?: boolean;
                commentUser?: boolean;
                commentAdmin?: boolean;
                city?: boolean | CityDefaultArgs<ExtArgs>;
                students?: boolean | IeltsExam$studentsArgs<ExtArgs>;
                _count?: boolean | IeltsExamCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['ieltsExam']
        >;

    export type IeltsExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                dateExam?: boolean;
                cityId?: boolean;
                isActive?: boolean;
                commentUser?: boolean;
                commentAdmin?: boolean;
                city?: boolean | CityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['ieltsExam']
        >;

    export type IeltsExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                dateExam?: boolean;
                cityId?: boolean;
                isActive?: boolean;
                commentUser?: boolean;
                commentAdmin?: boolean;
                city?: boolean | CityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['ieltsExam']
        >;

    export type IeltsExamSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        dateExam?: boolean;
        cityId?: boolean;
        isActive?: boolean;
        commentUser?: boolean;
        commentAdmin?: boolean;
    };

    export type IeltsExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        | 'id'
        | 'createdAt'
        | 'createdBy'
        | 'updatedAt'
        | 'updatedBy'
        | 'dateExam'
        | 'cityId'
        | 'isActive'
        | 'commentUser'
        | 'commentAdmin',
        ExtArgs['result']['ieltsExam']
    >;
    export type IeltsExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
        students?: boolean | IeltsExam$studentsArgs<ExtArgs>;
        _count?: boolean | IeltsExamCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type IeltsExamIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
    };
    export type IeltsExamIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
    };

    export type $IeltsExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'IeltsExam';
        objects: {
            city: Prisma.$CityPayload<ExtArgs>;
            students: Prisma.$IeltsRegistrationStudentPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string;
                updatedAt: Date;
                updatedBy: string | null;
                dateExam: Date;
                cityId: string;
                isActive: boolean | null;
                commentUser: string | null;
                commentAdmin: string | null;
            },
            ExtArgs['result']['ieltsExam']
        >;
        composites: {};
    };

    type IeltsExamGetPayload<S extends boolean | null | undefined | IeltsExamDefaultArgs> = $Result.GetResult<
        Prisma.$IeltsExamPayload,
        S
    >;

    type IeltsExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        IeltsExamFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: IeltsExamCountAggregateInputType | true;
    };

    export interface IeltsExamDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IeltsExam']; meta: { name: 'IeltsExam' } };
        /**
         * Find zero or one IeltsExam that matches the filter.
         * @param {IeltsExamFindUniqueArgs} args - Arguments to find a IeltsExam
         * @example
         * // Get one IeltsExam
         * const ieltsExam = await prisma.ieltsExam.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends IeltsExamFindUniqueArgs>(
            args: SelectSubset<T, IeltsExamFindUniqueArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one IeltsExam that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {IeltsExamFindUniqueOrThrowArgs} args - Arguments to find a IeltsExam
         * @example
         * // Get one IeltsExam
         * const ieltsExam = await prisma.ieltsExam.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends IeltsExamFindUniqueOrThrowArgs>(
            args: SelectSubset<T, IeltsExamFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first IeltsExam that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamFindFirstArgs} args - Arguments to find a IeltsExam
         * @example
         * // Get one IeltsExam
         * const ieltsExam = await prisma.ieltsExam.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends IeltsExamFindFirstArgs>(
            args?: SelectSubset<T, IeltsExamFindFirstArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first IeltsExam that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamFindFirstOrThrowArgs} args - Arguments to find a IeltsExam
         * @example
         * // Get one IeltsExam
         * const ieltsExam = await prisma.ieltsExam.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends IeltsExamFindFirstOrThrowArgs>(
            args?: SelectSubset<T, IeltsExamFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more IeltsExams that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all IeltsExams
         * const ieltsExams = await prisma.ieltsExam.findMany()
         *
         * // Get first 10 IeltsExams
         * const ieltsExams = await prisma.ieltsExam.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const ieltsExamWithIdOnly = await prisma.ieltsExam.findMany({ select: { id: true } })
         *
         */
        findMany<T extends IeltsExamFindManyArgs>(
            args?: SelectSubset<T, IeltsExamFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a IeltsExam.
         * @param {IeltsExamCreateArgs} args - Arguments to create a IeltsExam.
         * @example
         * // Create one IeltsExam
         * const IeltsExam = await prisma.ieltsExam.create({
         *   data: {
         *     // ... data to create a IeltsExam
         *   }
         * })
         *
         */
        create<T extends IeltsExamCreateArgs>(
            args: SelectSubset<T, IeltsExamCreateArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many IeltsExams.
         * @param {IeltsExamCreateManyArgs} args - Arguments to create many IeltsExams.
         * @example
         * // Create many IeltsExams
         * const ieltsExam = await prisma.ieltsExam.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends IeltsExamCreateManyArgs>(
            args?: SelectSubset<T, IeltsExamCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many IeltsExams and returns the data saved in the database.
         * @param {IeltsExamCreateManyAndReturnArgs} args - Arguments to create many IeltsExams.
         * @example
         * // Create many IeltsExams
         * const ieltsExam = await prisma.ieltsExam.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many IeltsExams and only return the `id`
         * const ieltsExamWithIdOnly = await prisma.ieltsExam.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends IeltsExamCreateManyAndReturnArgs>(
            args?: SelectSubset<T, IeltsExamCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a IeltsExam.
         * @param {IeltsExamDeleteArgs} args - Arguments to delete one IeltsExam.
         * @example
         * // Delete one IeltsExam
         * const IeltsExam = await prisma.ieltsExam.delete({
         *   where: {
         *     // ... filter to delete one IeltsExam
         *   }
         * })
         *
         */
        delete<T extends IeltsExamDeleteArgs>(
            args: SelectSubset<T, IeltsExamDeleteArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one IeltsExam.
         * @param {IeltsExamUpdateArgs} args - Arguments to update one IeltsExam.
         * @example
         * // Update one IeltsExam
         * const ieltsExam = await prisma.ieltsExam.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends IeltsExamUpdateArgs>(
            args: SelectSubset<T, IeltsExamUpdateArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more IeltsExams.
         * @param {IeltsExamDeleteManyArgs} args - Arguments to filter IeltsExams to delete.
         * @example
         * // Delete a few IeltsExams
         * const { count } = await prisma.ieltsExam.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends IeltsExamDeleteManyArgs>(
            args?: SelectSubset<T, IeltsExamDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more IeltsExams.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many IeltsExams
         * const ieltsExam = await prisma.ieltsExam.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends IeltsExamUpdateManyArgs>(
            args: SelectSubset<T, IeltsExamUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more IeltsExams and returns the data updated in the database.
         * @param {IeltsExamUpdateManyAndReturnArgs} args - Arguments to update many IeltsExams.
         * @example
         * // Update many IeltsExams
         * const ieltsExam = await prisma.ieltsExam.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more IeltsExams and only return the `id`
         * const ieltsExamWithIdOnly = await prisma.ieltsExam.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends IeltsExamUpdateManyAndReturnArgs>(
            args: SelectSubset<T, IeltsExamUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one IeltsExam.
         * @param {IeltsExamUpsertArgs} args - Arguments to update or create a IeltsExam.
         * @example
         * // Update or create a IeltsExam
         * const ieltsExam = await prisma.ieltsExam.upsert({
         *   create: {
         *     // ... data to create a IeltsExam
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the IeltsExam we want to update
         *   }
         * })
         */
        upsert<T extends IeltsExamUpsertArgs>(
            args: SelectSubset<T, IeltsExamUpsertArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of IeltsExams.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamCountArgs} args - Arguments to filter IeltsExams to count.
         * @example
         * // Count the number of IeltsExams
         * const count = await prisma.ieltsExam.count({
         *   where: {
         *     // ... the filter for the IeltsExams we want to count
         *   }
         * })
         **/
        count<T extends IeltsExamCountArgs>(
            args?: Subset<T, IeltsExamCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], IeltsExamCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a IeltsExam.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends IeltsExamAggregateArgs>(
            args: Subset<T, IeltsExamAggregateArgs>,
        ): Prisma.PrismaPromise<GetIeltsExamAggregateType<T>>;

        /**
         * Group by IeltsExam.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsExamGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends IeltsExamGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: IeltsExamGroupByArgs['orderBy'] }
                : { orderBy?: IeltsExamGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, IeltsExamGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetIeltsExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the IeltsExam model
         */
        readonly fields: IeltsExamFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for IeltsExam.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__IeltsExamClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        city<T extends CityDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, CityDefaultArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        students<T extends IeltsExam$studentsArgs<ExtArgs> = {}>(
            args?: Subset<T, IeltsExam$studentsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the IeltsExam model
     */
    interface IeltsExamFieldRefs {
        readonly id: FieldRef<'IeltsExam', 'String'>;
        readonly createdAt: FieldRef<'IeltsExam', 'DateTime'>;
        readonly createdBy: FieldRef<'IeltsExam', 'String'>;
        readonly updatedAt: FieldRef<'IeltsExam', 'DateTime'>;
        readonly updatedBy: FieldRef<'IeltsExam', 'String'>;
        readonly dateExam: FieldRef<'IeltsExam', 'DateTime'>;
        readonly cityId: FieldRef<'IeltsExam', 'String'>;
        readonly isActive: FieldRef<'IeltsExam', 'Boolean'>;
        readonly commentUser: FieldRef<'IeltsExam', 'String'>;
        readonly commentAdmin: FieldRef<'IeltsExam', 'String'>;
    }

    // Custom InputTypes
    /**
     * IeltsExam findUnique
     */
    export type IeltsExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsExam to fetch.
         */
        where: IeltsExamWhereUniqueInput;
    };

    /**
     * IeltsExam findUniqueOrThrow
     */
    export type IeltsExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsExam to fetch.
         */
        where: IeltsExamWhereUniqueInput;
    };

    /**
     * IeltsExam findFirst
     */
    export type IeltsExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsExam to fetch.
         */
        where?: IeltsExamWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsExams to fetch.
         */
        orderBy?: IeltsExamOrderByWithRelationInput | IeltsExamOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for IeltsExams.
         */
        cursor?: IeltsExamWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsExams from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsExams.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of IeltsExams.
         */
        distinct?: IeltsExamScalarFieldEnum | IeltsExamScalarFieldEnum[];
    };

    /**
     * IeltsExam findFirstOrThrow
     */
    export type IeltsExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsExam to fetch.
         */
        where?: IeltsExamWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsExams to fetch.
         */
        orderBy?: IeltsExamOrderByWithRelationInput | IeltsExamOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for IeltsExams.
         */
        cursor?: IeltsExamWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsExams from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsExams.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of IeltsExams.
         */
        distinct?: IeltsExamScalarFieldEnum | IeltsExamScalarFieldEnum[];
    };

    /**
     * IeltsExam findMany
     */
    export type IeltsExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsExams to fetch.
         */
        where?: IeltsExamWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsExams to fetch.
         */
        orderBy?: IeltsExamOrderByWithRelationInput | IeltsExamOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing IeltsExams.
         */
        cursor?: IeltsExamWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsExams from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsExams.
         */
        skip?: number;
        distinct?: IeltsExamScalarFieldEnum | IeltsExamScalarFieldEnum[];
    };

    /**
     * IeltsExam create
     */
    export type IeltsExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * The data needed to create a IeltsExam.
         */
        data: XOR<IeltsExamCreateInput, IeltsExamUncheckedCreateInput>;
    };

    /**
     * IeltsExam createMany
     */
    export type IeltsExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many IeltsExams.
         */
        data: IeltsExamCreateManyInput | IeltsExamCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * IeltsExam createManyAndReturn
     */
    export type IeltsExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * The data used to create many IeltsExams.
         */
        data: IeltsExamCreateManyInput | IeltsExamCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * IeltsExam update
     */
    export type IeltsExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * The data needed to update a IeltsExam.
         */
        data: XOR<IeltsExamUpdateInput, IeltsExamUncheckedUpdateInput>;
        /**
         * Choose, which IeltsExam to update.
         */
        where: IeltsExamWhereUniqueInput;
    };

    /**
     * IeltsExam updateMany
     */
    export type IeltsExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update IeltsExams.
         */
        data: XOR<IeltsExamUpdateManyMutationInput, IeltsExamUncheckedUpdateManyInput>;
        /**
         * Filter which IeltsExams to update
         */
        where?: IeltsExamWhereInput;
        /**
         * Limit how many IeltsExams to update.
         */
        limit?: number;
    };

    /**
     * IeltsExam updateManyAndReturn
     */
    export type IeltsExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * The data used to update IeltsExams.
         */
        data: XOR<IeltsExamUpdateManyMutationInput, IeltsExamUncheckedUpdateManyInput>;
        /**
         * Filter which IeltsExams to update
         */
        where?: IeltsExamWhereInput;
        /**
         * Limit how many IeltsExams to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * IeltsExam upsert
     */
    export type IeltsExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * The filter to search for the IeltsExam to update in case it exists.
         */
        where: IeltsExamWhereUniqueInput;
        /**
         * In case the IeltsExam found by the `where` argument doesn't exist, create a new IeltsExam with this data.
         */
        create: XOR<IeltsExamCreateInput, IeltsExamUncheckedCreateInput>;
        /**
         * In case the IeltsExam was found with the provided `where` argument, update it with this data.
         */
        update: XOR<IeltsExamUpdateInput, IeltsExamUncheckedUpdateInput>;
    };

    /**
     * IeltsExam delete
     */
    export type IeltsExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        /**
         * Filter which IeltsExam to delete.
         */
        where: IeltsExamWhereUniqueInput;
    };

    /**
     * IeltsExam deleteMany
     */
    export type IeltsExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which IeltsExams to delete
         */
        where?: IeltsExamWhereInput;
        /**
         * Limit how many IeltsExams to delete.
         */
        limit?: number;
    };

    /**
     * IeltsExam.students
     */
    export type IeltsExam$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        where?: IeltsRegistrationStudentWhereInput;
        orderBy?: IeltsRegistrationStudentOrderByWithRelationInput | IeltsRegistrationStudentOrderByWithRelationInput[];
        cursor?: IeltsRegistrationStudentWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: IeltsRegistrationStudentScalarFieldEnum | IeltsRegistrationStudentScalarFieldEnum[];
    };

    /**
     * IeltsExam without action
     */
    export type IeltsExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
    };

    /**
     * Model IeltsRegistrationStudent
     */

    export type AggregateIeltsRegistrationStudent = {
        _count: IeltsRegistrationStudentCountAggregateOutputType | null;
        _min: IeltsRegistrationStudentMinAggregateOutputType | null;
        _max: IeltsRegistrationStudentMaxAggregateOutputType | null;
    };

    export type IeltsRegistrationStudentMinAggregateOutputType = {
        id: string | null;
        examId: string | null;
        studentId: string | null;
        registeredAt: Date | null;
    };

    export type IeltsRegistrationStudentMaxAggregateOutputType = {
        id: string | null;
        examId: string | null;
        studentId: string | null;
        registeredAt: Date | null;
    };

    export type IeltsRegistrationStudentCountAggregateOutputType = {
        id: number;
        examId: number;
        studentId: number;
        registeredAt: number;
        _all: number;
    };

    export type IeltsRegistrationStudentMinAggregateInputType = {
        id?: true;
        examId?: true;
        studentId?: true;
        registeredAt?: true;
    };

    export type IeltsRegistrationStudentMaxAggregateInputType = {
        id?: true;
        examId?: true;
        studentId?: true;
        registeredAt?: true;
    };

    export type IeltsRegistrationStudentCountAggregateInputType = {
        id?: true;
        examId?: true;
        studentId?: true;
        registeredAt?: true;
        _all?: true;
    };

    export type IeltsRegistrationStudentAggregateArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which IeltsRegistrationStudent to aggregate.
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsRegistrationStudents to fetch.
         */
        orderBy?: IeltsRegistrationStudentOrderByWithRelationInput | IeltsRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: IeltsRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned IeltsRegistrationStudents
         **/
        _count?: true | IeltsRegistrationStudentCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: IeltsRegistrationStudentMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: IeltsRegistrationStudentMaxAggregateInputType;
    };

    export type GetIeltsRegistrationStudentAggregateType<T extends IeltsRegistrationStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateIeltsRegistrationStudent]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateIeltsRegistrationStudent[P]>
            : GetScalarType<T[P], AggregateIeltsRegistrationStudent[P]>;
    };

    export type IeltsRegistrationStudentGroupByArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        where?: IeltsRegistrationStudentWhereInput;
        orderBy?:
            | IeltsRegistrationStudentOrderByWithAggregationInput
            | IeltsRegistrationStudentOrderByWithAggregationInput[];
        by: IeltsRegistrationStudentScalarFieldEnum[] | IeltsRegistrationStudentScalarFieldEnum;
        having?: IeltsRegistrationStudentScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: IeltsRegistrationStudentCountAggregateInputType | true;
        _min?: IeltsRegistrationStudentMinAggregateInputType;
        _max?: IeltsRegistrationStudentMaxAggregateInputType;
    };

    export type IeltsRegistrationStudentGroupByOutputType = {
        id: string;
        examId: string;
        studentId: string;
        registeredAt: Date;
        _count: IeltsRegistrationStudentCountAggregateOutputType | null;
        _min: IeltsRegistrationStudentMinAggregateOutputType | null;
        _max: IeltsRegistrationStudentMaxAggregateOutputType | null;
    };

    type GetIeltsRegistrationStudentGroupByPayload<T extends IeltsRegistrationStudentGroupByArgs> =
        Prisma.PrismaPromise<
            Array<
                PickEnumerable<IeltsRegistrationStudentGroupByOutputType, T['by']> & {
                    [P in keyof T & keyof IeltsRegistrationStudentGroupByOutputType]: P extends '_count'
                        ? T[P] extends boolean
                            ? number
                            : GetScalarType<T[P], IeltsRegistrationStudentGroupByOutputType[P]>
                        : GetScalarType<T[P], IeltsRegistrationStudentGroupByOutputType[P]>;
                }
            >
        >;

    export type IeltsRegistrationStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                examId?: boolean;
                studentId?: boolean;
                registeredAt?: boolean;
                exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['ieltsRegistrationStudent']
        >;

    export type IeltsRegistrationStudentSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            examId?: boolean;
            studentId?: boolean;
            registeredAt?: boolean;
            exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['ieltsRegistrationStudent']
    >;

    export type IeltsRegistrationStudentSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            examId?: boolean;
            studentId?: boolean;
            registeredAt?: boolean;
            exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['ieltsRegistrationStudent']
    >;

    export type IeltsRegistrationStudentSelectScalar = {
        id?: boolean;
        examId?: boolean;
        studentId?: boolean;
        registeredAt?: boolean;
    };

    export type IeltsRegistrationStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            'id' | 'examId' | 'studentId' | 'registeredAt',
            ExtArgs['result']['ieltsRegistrationStudent']
        >;
    export type IeltsRegistrationStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
    };
    export type IeltsRegistrationStudentIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
    };
    export type IeltsRegistrationStudentIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        exam?: boolean | IeltsExamDefaultArgs<ExtArgs>;
    };

    export type $IeltsRegistrationStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'IeltsRegistrationStudent';
        objects: {
            exam: Prisma.$IeltsExamPayload<ExtArgs>;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                examId: string;
                studentId: string;
                registeredAt: Date;
            },
            ExtArgs['result']['ieltsRegistrationStudent']
        >;
        composites: {};
    };

    type IeltsRegistrationStudentGetPayload<
        S extends boolean | null | undefined | IeltsRegistrationStudentDefaultArgs,
    > = $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload, S>;

    type IeltsRegistrationStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        IeltsRegistrationStudentFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: IeltsRegistrationStudentCountAggregateInputType | true;
    };

    export interface IeltsRegistrationStudentDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: {
            types: Prisma.TypeMap<ExtArgs>['model']['IeltsRegistrationStudent'];
            meta: { name: 'IeltsRegistrationStudent' };
        };
        /**
         * Find zero or one IeltsRegistrationStudent that matches the filter.
         * @param {IeltsRegistrationStudentFindUniqueArgs} args - Arguments to find a IeltsRegistrationStudent
         * @example
         * // Get one IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends IeltsRegistrationStudentFindUniqueArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentFindUniqueArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'findUnique',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one IeltsRegistrationStudent that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {IeltsRegistrationStudentFindUniqueOrThrowArgs} args - Arguments to find a IeltsRegistrationStudent
         * @example
         * // Get one IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends IeltsRegistrationStudentFindUniqueOrThrowArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'findUniqueOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first IeltsRegistrationStudent that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentFindFirstArgs} args - Arguments to find a IeltsRegistrationStudent
         * @example
         * // Get one IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends IeltsRegistrationStudentFindFirstArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentFindFirstArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'findFirst',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first IeltsRegistrationStudent that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentFindFirstOrThrowArgs} args - Arguments to find a IeltsRegistrationStudent
         * @example
         * // Get one IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends IeltsRegistrationStudentFindFirstOrThrowArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'findFirstOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more IeltsRegistrationStudents that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all IeltsRegistrationStudents
         * const ieltsRegistrationStudents = await prisma.ieltsRegistrationStudent.findMany()
         *
         * // Get first 10 IeltsRegistrationStudents
         * const ieltsRegistrationStudents = await prisma.ieltsRegistrationStudent.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const ieltsRegistrationStudentWithIdOnly = await prisma.ieltsRegistrationStudent.findMany({ select: { id: true } })
         *
         */
        findMany<T extends IeltsRegistrationStudentFindManyArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a IeltsRegistrationStudent.
         * @param {IeltsRegistrationStudentCreateArgs} args - Arguments to create a IeltsRegistrationStudent.
         * @example
         * // Create one IeltsRegistrationStudent
         * const IeltsRegistrationStudent = await prisma.ieltsRegistrationStudent.create({
         *   data: {
         *     // ... data to create a IeltsRegistrationStudent
         *   }
         * })
         *
         */
        create<T extends IeltsRegistrationStudentCreateArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentCreateArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many IeltsRegistrationStudents.
         * @param {IeltsRegistrationStudentCreateManyArgs} args - Arguments to create many IeltsRegistrationStudents.
         * @example
         * // Create many IeltsRegistrationStudents
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends IeltsRegistrationStudentCreateManyArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many IeltsRegistrationStudents and returns the data saved in the database.
         * @param {IeltsRegistrationStudentCreateManyAndReturnArgs} args - Arguments to create many IeltsRegistrationStudents.
         * @example
         * // Create many IeltsRegistrationStudents
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many IeltsRegistrationStudents and only return the `id`
         * const ieltsRegistrationStudentWithIdOnly = await prisma.ieltsRegistrationStudent.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends IeltsRegistrationStudentCreateManyAndReturnArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'createManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Delete a IeltsRegistrationStudent.
         * @param {IeltsRegistrationStudentDeleteArgs} args - Arguments to delete one IeltsRegistrationStudent.
         * @example
         * // Delete one IeltsRegistrationStudent
         * const IeltsRegistrationStudent = await prisma.ieltsRegistrationStudent.delete({
         *   where: {
         *     // ... filter to delete one IeltsRegistrationStudent
         *   }
         * })
         *
         */
        delete<T extends IeltsRegistrationStudentDeleteArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentDeleteArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one IeltsRegistrationStudent.
         * @param {IeltsRegistrationStudentUpdateArgs} args - Arguments to update one IeltsRegistrationStudent.
         * @example
         * // Update one IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends IeltsRegistrationStudentUpdateArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentUpdateArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more IeltsRegistrationStudents.
         * @param {IeltsRegistrationStudentDeleteManyArgs} args - Arguments to filter IeltsRegistrationStudents to delete.
         * @example
         * // Delete a few IeltsRegistrationStudents
         * const { count } = await prisma.ieltsRegistrationStudent.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends IeltsRegistrationStudentDeleteManyArgs>(
            args?: SelectSubset<T, IeltsRegistrationStudentDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more IeltsRegistrationStudents.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many IeltsRegistrationStudents
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends IeltsRegistrationStudentUpdateManyArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more IeltsRegistrationStudents and returns the data updated in the database.
         * @param {IeltsRegistrationStudentUpdateManyAndReturnArgs} args - Arguments to update many IeltsRegistrationStudents.
         * @example
         * // Update many IeltsRegistrationStudents
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more IeltsRegistrationStudents and only return the `id`
         * const ieltsRegistrationStudentWithIdOnly = await prisma.ieltsRegistrationStudent.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends IeltsRegistrationStudentUpdateManyAndReturnArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$IeltsRegistrationStudentPayload<ExtArgs>,
                T,
                'updateManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Create or update one IeltsRegistrationStudent.
         * @param {IeltsRegistrationStudentUpsertArgs} args - Arguments to update or create a IeltsRegistrationStudent.
         * @example
         * // Update or create a IeltsRegistrationStudent
         * const ieltsRegistrationStudent = await prisma.ieltsRegistrationStudent.upsert({
         *   create: {
         *     // ... data to create a IeltsRegistrationStudent
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the IeltsRegistrationStudent we want to update
         *   }
         * })
         */
        upsert<T extends IeltsRegistrationStudentUpsertArgs>(
            args: SelectSubset<T, IeltsRegistrationStudentUpsertArgs<ExtArgs>>,
        ): Prisma__IeltsRegistrationStudentClient<
            $Result.GetResult<Prisma.$IeltsRegistrationStudentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of IeltsRegistrationStudents.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentCountArgs} args - Arguments to filter IeltsRegistrationStudents to count.
         * @example
         * // Count the number of IeltsRegistrationStudents
         * const count = await prisma.ieltsRegistrationStudent.count({
         *   where: {
         *     // ... the filter for the IeltsRegistrationStudents we want to count
         *   }
         * })
         **/
        count<T extends IeltsRegistrationStudentCountArgs>(
            args?: Subset<T, IeltsRegistrationStudentCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], IeltsRegistrationStudentCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a IeltsRegistrationStudent.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends IeltsRegistrationStudentAggregateArgs>(
            args: Subset<T, IeltsRegistrationStudentAggregateArgs>,
        ): Prisma.PrismaPromise<GetIeltsRegistrationStudentAggregateType<T>>;

        /**
         * Group by IeltsRegistrationStudent.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IeltsRegistrationStudentGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends IeltsRegistrationStudentGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: IeltsRegistrationStudentGroupByArgs['orderBy'] }
                : { orderBy?: IeltsRegistrationStudentGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, IeltsRegistrationStudentGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetIeltsRegistrationStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the IeltsRegistrationStudent model
         */
        readonly fields: IeltsRegistrationStudentFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for IeltsRegistrationStudent.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__IeltsRegistrationStudentClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        exam<T extends IeltsExamDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, IeltsExamDefaultArgs<ExtArgs>>,
        ): Prisma__IeltsExamClient<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the IeltsRegistrationStudent model
     */
    interface IeltsRegistrationStudentFieldRefs {
        readonly id: FieldRef<'IeltsRegistrationStudent', 'String'>;
        readonly examId: FieldRef<'IeltsRegistrationStudent', 'String'>;
        readonly studentId: FieldRef<'IeltsRegistrationStudent', 'String'>;
        readonly registeredAt: FieldRef<'IeltsRegistrationStudent', 'DateTime'>;
    }

    // Custom InputTypes
    /**
     * IeltsRegistrationStudent findUnique
     */
    export type IeltsRegistrationStudentFindUniqueArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsRegistrationStudent to fetch.
         */
        where: IeltsRegistrationStudentWhereUniqueInput;
    };

    /**
     * IeltsRegistrationStudent findUniqueOrThrow
     */
    export type IeltsRegistrationStudentFindUniqueOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsRegistrationStudent to fetch.
         */
        where: IeltsRegistrationStudentWhereUniqueInput;
    };

    /**
     * IeltsRegistrationStudent findFirst
     */
    export type IeltsRegistrationStudentFindFirstArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsRegistrationStudent to fetch.
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsRegistrationStudents to fetch.
         */
        orderBy?: IeltsRegistrationStudentOrderByWithRelationInput | IeltsRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for IeltsRegistrationStudents.
         */
        cursor?: IeltsRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of IeltsRegistrationStudents.
         */
        distinct?: IeltsRegistrationStudentScalarFieldEnum | IeltsRegistrationStudentScalarFieldEnum[];
    };

    /**
     * IeltsRegistrationStudent findFirstOrThrow
     */
    export type IeltsRegistrationStudentFindFirstOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsRegistrationStudent to fetch.
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsRegistrationStudents to fetch.
         */
        orderBy?: IeltsRegistrationStudentOrderByWithRelationInput | IeltsRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for IeltsRegistrationStudents.
         */
        cursor?: IeltsRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of IeltsRegistrationStudents.
         */
        distinct?: IeltsRegistrationStudentScalarFieldEnum | IeltsRegistrationStudentScalarFieldEnum[];
    };

    /**
     * IeltsRegistrationStudent findMany
     */
    export type IeltsRegistrationStudentFindManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which IeltsRegistrationStudents to fetch.
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of IeltsRegistrationStudents to fetch.
         */
        orderBy?: IeltsRegistrationStudentOrderByWithRelationInput | IeltsRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing IeltsRegistrationStudents.
         */
        cursor?: IeltsRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` IeltsRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` IeltsRegistrationStudents.
         */
        skip?: number;
        distinct?: IeltsRegistrationStudentScalarFieldEnum | IeltsRegistrationStudentScalarFieldEnum[];
    };

    /**
     * IeltsRegistrationStudent create
     */
    export type IeltsRegistrationStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the IeltsRegistrationStudent
             */
            select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the IeltsRegistrationStudent
             */
            omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The data needed to create a IeltsRegistrationStudent.
             */
            data: XOR<IeltsRegistrationStudentCreateInput, IeltsRegistrationStudentUncheckedCreateInput>;
        };

    /**
     * IeltsRegistrationStudent createMany
     */
    export type IeltsRegistrationStudentCreateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to create many IeltsRegistrationStudents.
         */
        data: IeltsRegistrationStudentCreateManyInput | IeltsRegistrationStudentCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * IeltsRegistrationStudent createManyAndReturn
     */
    export type IeltsRegistrationStudentCreateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * The data used to create many IeltsRegistrationStudents.
         */
        data: IeltsRegistrationStudentCreateManyInput | IeltsRegistrationStudentCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * IeltsRegistrationStudent update
     */
    export type IeltsRegistrationStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the IeltsRegistrationStudent
             */
            select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the IeltsRegistrationStudent
             */
            omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The data needed to update a IeltsRegistrationStudent.
             */
            data: XOR<IeltsRegistrationStudentUpdateInput, IeltsRegistrationStudentUncheckedUpdateInput>;
            /**
             * Choose, which IeltsRegistrationStudent to update.
             */
            where: IeltsRegistrationStudentWhereUniqueInput;
        };

    /**
     * IeltsRegistrationStudent updateMany
     */
    export type IeltsRegistrationStudentUpdateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to update IeltsRegistrationStudents.
         */
        data: XOR<IeltsRegistrationStudentUpdateManyMutationInput, IeltsRegistrationStudentUncheckedUpdateManyInput>;
        /**
         * Filter which IeltsRegistrationStudents to update
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * Limit how many IeltsRegistrationStudents to update.
         */
        limit?: number;
    };

    /**
     * IeltsRegistrationStudent updateManyAndReturn
     */
    export type IeltsRegistrationStudentUpdateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * The data used to update IeltsRegistrationStudents.
         */
        data: XOR<IeltsRegistrationStudentUpdateManyMutationInput, IeltsRegistrationStudentUncheckedUpdateManyInput>;
        /**
         * Filter which IeltsRegistrationStudents to update
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * Limit how many IeltsRegistrationStudents to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * IeltsRegistrationStudent upsert
     */
    export type IeltsRegistrationStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the IeltsRegistrationStudent
             */
            select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the IeltsRegistrationStudent
             */
            omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The filter to search for the IeltsRegistrationStudent to update in case it exists.
             */
            where: IeltsRegistrationStudentWhereUniqueInput;
            /**
             * In case the IeltsRegistrationStudent found by the `where` argument doesn't exist, create a new IeltsRegistrationStudent with this data.
             */
            create: XOR<IeltsRegistrationStudentCreateInput, IeltsRegistrationStudentUncheckedCreateInput>;
            /**
             * In case the IeltsRegistrationStudent was found with the provided `where` argument, update it with this data.
             */
            update: XOR<IeltsRegistrationStudentUpdateInput, IeltsRegistrationStudentUncheckedUpdateInput>;
        };

    /**
     * IeltsRegistrationStudent delete
     */
    export type IeltsRegistrationStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the IeltsRegistrationStudent
             */
            select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the IeltsRegistrationStudent
             */
            omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
            /**
             * Filter which IeltsRegistrationStudent to delete.
             */
            where: IeltsRegistrationStudentWhereUniqueInput;
        };

    /**
     * IeltsRegistrationStudent deleteMany
     */
    export type IeltsRegistrationStudentDeleteManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which IeltsRegistrationStudents to delete
         */
        where?: IeltsRegistrationStudentWhereInput;
        /**
         * Limit how many IeltsRegistrationStudents to delete.
         */
        limit?: number;
    };

    /**
     * IeltsRegistrationStudent without action
     */
    export type IeltsRegistrationStudentDefaultArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the IeltsRegistrationStudent
         */
        select?: IeltsRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsRegistrationStudent
         */
        omit?: IeltsRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsRegistrationStudentInclude<ExtArgs> | null;
    };

    /**
     * Model City
     */

    export type AggregateCity = {
        _count: CityCountAggregateOutputType | null;
        _min: CityMinAggregateOutputType | null;
        _max: CityMaxAggregateOutputType | null;
    };

    export type CityMinAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type CityMaxAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type CityCountAggregateOutputType = {
        id: number;
        name: number;
        _all: number;
    };

    export type CityMinAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type CityMaxAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type CityCountAggregateInputType = {
        id?: true;
        name?: true;
        _all?: true;
    };

    export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which City to aggregate.
         */
        where?: CityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cities to fetch.
         */
        orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Cities
         **/
        _count?: true | CityCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CityMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CityMaxAggregateInputType;
    };

    export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCity[P]>
            : GetScalarType<T[P], AggregateCity[P]>;
    };

    export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CityWhereInput;
        orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[];
        by: CityScalarFieldEnum[] | CityScalarFieldEnum;
        having?: CityScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CityCountAggregateInputType | true;
        _min?: CityMinAggregateInputType;
        _max?: CityMaxAggregateInputType;
    };

    export type CityGroupByOutputType = {
        id: string;
        name: string;
        _count: CityCountAggregateOutputType | null;
        _min: CityMinAggregateOutputType | null;
        _max: CityMaxAggregateOutputType | null;
    };

    type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CityGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CityGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CityGroupByOutputType[P]>
                    : GetScalarType<T[P], CityGroupByOutputType[P]>;
            }
        >
    >;

    export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
        {
            id?: boolean;
            name?: boolean;
            ieltsExams?: boolean | City$ieltsExamsArgs<ExtArgs>;
            jobHuntings?: boolean | City$jobHuntingsArgs<ExtArgs>;
            cvs?: boolean | City$cvsArgs<ExtArgs>;
            universities?: boolean | City$universitiesArgs<ExtArgs>;
            _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['city']
    >;

    export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['city']
        >;

    export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['city']
        >;

    export type CitySelectScalar = {
        id?: boolean;
        name?: boolean;
    };

    export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'id' | 'name',
        ExtArgs['result']['city']
    >;
    export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        ieltsExams?: boolean | City$ieltsExamsArgs<ExtArgs>;
        jobHuntings?: boolean | City$jobHuntingsArgs<ExtArgs>;
        cvs?: boolean | City$cvsArgs<ExtArgs>;
        universities?: boolean | City$universitiesArgs<ExtArgs>;
        _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
    export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

    export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'City';
        objects: {
            ieltsExams: Prisma.$IeltsExamPayload<ExtArgs>[];
            jobHuntings: Prisma.$JobHuntingPayload<ExtArgs>[];
            cvs: Prisma.$CVPayload<ExtArgs>[];
            universities: Prisma.$UniversityPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                name: string;
            },
            ExtArgs['result']['city']
        >;
        composites: {};
    };

    type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<
        Prisma.$CityPayload,
        S
    >;

    type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CityFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CityCountAggregateInputType | true;
    };

    export interface CityDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City']; meta: { name: 'City' } };
        /**
         * Find zero or one City that matches the filter.
         * @param {CityFindUniqueArgs} args - Arguments to find a City
         * @example
         * // Get one City
         * const city = await prisma.city.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CityFindUniqueArgs>(
            args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one City that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
         * @example
         * // Get one City
         * const city = await prisma.city.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first City that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityFindFirstArgs} args - Arguments to find a City
         * @example
         * // Get one City
         * const city = await prisma.city.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CityFindFirstArgs>(
            args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first City that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
         * @example
         * // Get one City
         * const city = await prisma.city.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Cities that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Cities
         * const cities = await prisma.city.findMany()
         *
         * // Get first 10 Cities
         * const cities = await prisma.city.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
         *
         */
        findMany<T extends CityFindManyArgs>(
            args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a City.
         * @param {CityCreateArgs} args - Arguments to create a City.
         * @example
         * // Create one City
         * const City = await prisma.city.create({
         *   data: {
         *     // ... data to create a City
         *   }
         * })
         *
         */
        create<T extends CityCreateArgs>(
            args: SelectSubset<T, CityCreateArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Cities.
         * @param {CityCreateManyArgs} args - Arguments to create many Cities.
         * @example
         * // Create many Cities
         * const city = await prisma.city.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CityCreateManyArgs>(
            args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Cities and returns the data saved in the database.
         * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
         * @example
         * // Create many Cities
         * const city = await prisma.city.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Cities and only return the `id`
         * const cityWithIdOnly = await prisma.city.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CityCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a City.
         * @param {CityDeleteArgs} args - Arguments to delete one City.
         * @example
         * // Delete one City
         * const City = await prisma.city.delete({
         *   where: {
         *     // ... filter to delete one City
         *   }
         * })
         *
         */
        delete<T extends CityDeleteArgs>(
            args: SelectSubset<T, CityDeleteArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one City.
         * @param {CityUpdateArgs} args - Arguments to update one City.
         * @example
         * // Update one City
         * const city = await prisma.city.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CityUpdateArgs>(
            args: SelectSubset<T, CityUpdateArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Cities.
         * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
         * @example
         * // Delete a few Cities
         * const { count } = await prisma.city.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CityDeleteManyArgs>(
            args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Cities.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Cities
         * const city = await prisma.city.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CityUpdateManyArgs>(
            args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Cities and returns the data updated in the database.
         * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
         * @example
         * // Update many Cities
         * const city = await prisma.city.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Cities and only return the `id`
         * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one City.
         * @param {CityUpsertArgs} args - Arguments to update or create a City.
         * @example
         * // Update or create a City
         * const city = await prisma.city.upsert({
         *   create: {
         *     // ... data to create a City
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the City we want to update
         *   }
         * })
         */
        upsert<T extends CityUpsertArgs>(
            args: SelectSubset<T, CityUpsertArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Cities.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityCountArgs} args - Arguments to filter Cities to count.
         * @example
         * // Count the number of Cities
         * const count = await prisma.city.count({
         *   where: {
         *     // ... the filter for the Cities we want to count
         *   }
         * })
         **/
        count<T extends CityCountArgs>(
            args?: Subset<T, CityCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CityCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a City.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CityAggregateArgs>(
            args: Subset<T, CityAggregateArgs>,
        ): Prisma.PrismaPromise<GetCityAggregateType<T>>;

        /**
         * Group by City.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CityGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CityGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CityGroupByArgs['orderBy'] }
                : { orderBy?: CityGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the City model
         */
        readonly fields: CityFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for City.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CityClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        ieltsExams<T extends City$ieltsExamsArgs<ExtArgs> = {}>(
            args?: Subset<T, City$ieltsExamsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$IeltsExamPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        jobHuntings<T extends City$jobHuntingsArgs<ExtArgs> = {}>(
            args?: Subset<T, City$jobHuntingsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        cvs<T extends City$cvsArgs<ExtArgs> = {}>(
            args?: Subset<T, City$cvsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null>;
        universities<T extends City$universitiesArgs<ExtArgs> = {}>(
            args?: Subset<T, City$universitiesArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the City model
     */
    interface CityFieldRefs {
        readonly id: FieldRef<'City', 'String'>;
        readonly name: FieldRef<'City', 'String'>;
    }

    // Custom InputTypes
    /**
     * City findUnique
     */
    export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter, which City to fetch.
         */
        where: CityWhereUniqueInput;
    };

    /**
     * City findUniqueOrThrow
     */
    export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter, which City to fetch.
         */
        where: CityWhereUniqueInput;
    };

    /**
     * City findFirst
     */
    export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter, which City to fetch.
         */
        where?: CityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cities to fetch.
         */
        orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Cities.
         */
        cursor?: CityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Cities.
         */
        distinct?: CityScalarFieldEnum | CityScalarFieldEnum[];
    };

    /**
     * City findFirstOrThrow
     */
    export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter, which City to fetch.
         */
        where?: CityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cities to fetch.
         */
        orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Cities.
         */
        cursor?: CityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Cities.
         */
        distinct?: CityScalarFieldEnum | CityScalarFieldEnum[];
    };

    /**
     * City findMany
     */
    export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter, which Cities to fetch.
         */
        where?: CityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cities to fetch.
         */
        orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Cities.
         */
        cursor?: CityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cities.
         */
        skip?: number;
        distinct?: CityScalarFieldEnum | CityScalarFieldEnum[];
    };

    /**
     * City create
     */
    export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * The data needed to create a City.
         */
        data: XOR<CityCreateInput, CityUncheckedCreateInput>;
    };

    /**
     * City createMany
     */
    export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Cities.
         */
        data: CityCreateManyInput | CityCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * City createManyAndReturn
     */
    export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * The data used to create many Cities.
         */
        data: CityCreateManyInput | CityCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * City update
     */
    export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * The data needed to update a City.
         */
        data: XOR<CityUpdateInput, CityUncheckedUpdateInput>;
        /**
         * Choose, which City to update.
         */
        where: CityWhereUniqueInput;
    };

    /**
     * City updateMany
     */
    export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Cities.
         */
        data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>;
        /**
         * Filter which Cities to update
         */
        where?: CityWhereInput;
        /**
         * Limit how many Cities to update.
         */
        limit?: number;
    };

    /**
     * City updateManyAndReturn
     */
    export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * The data used to update Cities.
         */
        data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>;
        /**
         * Filter which Cities to update
         */
        where?: CityWhereInput;
        /**
         * Limit how many Cities to update.
         */
        limit?: number;
    };

    /**
     * City upsert
     */
    export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * The filter to search for the City to update in case it exists.
         */
        where: CityWhereUniqueInput;
        /**
         * In case the City found by the `where` argument doesn't exist, create a new City with this data.
         */
        create: XOR<CityCreateInput, CityUncheckedCreateInput>;
        /**
         * In case the City was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CityUpdateInput, CityUncheckedUpdateInput>;
    };

    /**
     * City delete
     */
    export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        /**
         * Filter which City to delete.
         */
        where: CityWhereUniqueInput;
    };

    /**
     * City deleteMany
     */
    export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Cities to delete
         */
        where?: CityWhereInput;
        /**
         * Limit how many Cities to delete.
         */
        limit?: number;
    };

    /**
     * City.ieltsExams
     */
    export type City$ieltsExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the IeltsExam
         */
        select?: IeltsExamSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the IeltsExam
         */
        omit?: IeltsExamOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: IeltsExamInclude<ExtArgs> | null;
        where?: IeltsExamWhereInput;
        orderBy?: IeltsExamOrderByWithRelationInput | IeltsExamOrderByWithRelationInput[];
        cursor?: IeltsExamWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: IeltsExamScalarFieldEnum | IeltsExamScalarFieldEnum[];
    };

    /**
     * City.jobHuntings
     */
    export type City$jobHuntingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        where?: JobHuntingWhereInput;
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        cursor?: JobHuntingWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: JobHuntingScalarFieldEnum | JobHuntingScalarFieldEnum[];
    };

    /**
     * City.cvs
     */
    export type City$cvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        where?: CVWhereInput;
        orderBy?: CVOrderByWithRelationInput | CVOrderByWithRelationInput[];
        cursor?: CVWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: CVScalarFieldEnum | CVScalarFieldEnum[];
    };

    /**
     * City.universities
     */
    export type City$universitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        where?: UniversityWhereInput;
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        cursor?: UniversityWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[];
    };

    /**
     * City without action
     */
    export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
    };

    /**
     * Model MockRegistration
     */

    export type AggregateMockRegistration = {
        _count: MockRegistrationCountAggregateOutputType | null;
        _min: MockRegistrationMinAggregateOutputType | null;
        _max: MockRegistrationMaxAggregateOutputType | null;
    };

    export type MockRegistrationMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        commentUser: string | null;
        commentAdmin: string | null;
        title: string | null;
        date: Date | null;
        branchId: string | null;
        isActive: boolean | null;
    };

    export type MockRegistrationMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        commentUser: string | null;
        commentAdmin: string | null;
        title: string | null;
        date: Date | null;
        branchId: string | null;
        isActive: boolean | null;
    };

    export type MockRegistrationCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        commentUser: number;
        commentAdmin: number;
        title: number;
        date: number;
        branchId: number;
        isActive: number;
        _all: number;
    };

    export type MockRegistrationMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        commentUser?: true;
        commentAdmin?: true;
        title?: true;
        date?: true;
        branchId?: true;
        isActive?: true;
    };

    export type MockRegistrationMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        commentUser?: true;
        commentAdmin?: true;
        title?: true;
        date?: true;
        branchId?: true;
        isActive?: true;
    };

    export type MockRegistrationCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        commentUser?: true;
        commentAdmin?: true;
        title?: true;
        date?: true;
        branchId?: true;
        isActive?: true;
        _all?: true;
    };

    export type MockRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which MockRegistration to aggregate.
         */
        where?: MockRegistrationWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrations to fetch.
         */
        orderBy?: MockRegistrationOrderByWithRelationInput | MockRegistrationOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: MockRegistrationWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrations from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrations.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned MockRegistrations
         **/
        _count?: true | MockRegistrationCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: MockRegistrationMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: MockRegistrationMaxAggregateInputType;
    };

    export type GetMockRegistrationAggregateType<T extends MockRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMockRegistration]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateMockRegistration[P]>
            : GetScalarType<T[P], AggregateMockRegistration[P]>;
    };

    export type MockRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: MockRegistrationWhereInput;
        orderBy?: MockRegistrationOrderByWithAggregationInput | MockRegistrationOrderByWithAggregationInput[];
        by: MockRegistrationScalarFieldEnum[] | MockRegistrationScalarFieldEnum;
        having?: MockRegistrationScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: MockRegistrationCountAggregateInputType | true;
        _min?: MockRegistrationMinAggregateInputType;
        _max?: MockRegistrationMaxAggregateInputType;
    };

    export type MockRegistrationGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string;
        updatedAt: Date;
        updatedBy: string | null;
        commentUser: string | null;
        commentAdmin: string | null;
        title: string | null;
        date: Date;
        branchId: string;
        isActive: boolean;
        _count: MockRegistrationCountAggregateOutputType | null;
        _min: MockRegistrationMinAggregateOutputType | null;
        _max: MockRegistrationMaxAggregateOutputType | null;
    };

    type GetMockRegistrationGroupByPayload<T extends MockRegistrationGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<MockRegistrationGroupByOutputType, T['by']> & {
                [P in keyof T & keyof MockRegistrationGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], MockRegistrationGroupByOutputType[P]>
                    : GetScalarType<T[P], MockRegistrationGroupByOutputType[P]>;
            }
        >
    >;

    export type MockRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                commentUser?: boolean;
                commentAdmin?: boolean;
                title?: boolean;
                date?: boolean;
                branchId?: boolean;
                isActive?: boolean;
                students?: boolean | MockRegistration$studentsArgs<ExtArgs>;
                _count?: boolean | MockRegistrationCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['mockRegistration']
        >;

    export type MockRegistrationSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            commentUser?: boolean;
            commentAdmin?: boolean;
            title?: boolean;
            date?: boolean;
            branchId?: boolean;
            isActive?: boolean;
        },
        ExtArgs['result']['mockRegistration']
    >;

    export type MockRegistrationSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            commentUser?: boolean;
            commentAdmin?: boolean;
            title?: boolean;
            date?: boolean;
            branchId?: boolean;
            isActive?: boolean;
        },
        ExtArgs['result']['mockRegistration']
    >;

    export type MockRegistrationSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        commentUser?: boolean;
        commentAdmin?: boolean;
        title?: boolean;
        date?: boolean;
        branchId?: boolean;
        isActive?: boolean;
    };

    export type MockRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            | 'id'
            | 'createdAt'
            | 'createdBy'
            | 'updatedAt'
            | 'updatedBy'
            | 'commentUser'
            | 'commentAdmin'
            | 'title'
            | 'date'
            | 'branchId'
            | 'isActive',
            ExtArgs['result']['mockRegistration']
        >;
    export type MockRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        students?: boolean | MockRegistration$studentsArgs<ExtArgs>;
        _count?: boolean | MockRegistrationCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type MockRegistrationIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {};
    export type MockRegistrationIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {};

    export type $MockRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'MockRegistration';
        objects: {
            students: Prisma.$MockRegistrationStudentPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string;
                updatedAt: Date;
                updatedBy: string | null;
                commentUser: string | null;
                commentAdmin: string | null;
                title: string | null;
                date: Date;
                branchId: string;
                isActive: boolean;
            },
            ExtArgs['result']['mockRegistration']
        >;
        composites: {};
    };

    type MockRegistrationGetPayload<S extends boolean | null | undefined | MockRegistrationDefaultArgs> =
        $Result.GetResult<Prisma.$MockRegistrationPayload, S>;

    type MockRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        MockRegistrationFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: MockRegistrationCountAggregateInputType | true;
    };

    export interface MockRegistrationDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: {
            types: Prisma.TypeMap<ExtArgs>['model']['MockRegistration'];
            meta: { name: 'MockRegistration' };
        };
        /**
         * Find zero or one MockRegistration that matches the filter.
         * @param {MockRegistrationFindUniqueArgs} args - Arguments to find a MockRegistration
         * @example
         * // Get one MockRegistration
         * const mockRegistration = await prisma.mockRegistration.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends MockRegistrationFindUniqueArgs>(
            args: SelectSubset<T, MockRegistrationFindUniqueArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one MockRegistration that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {MockRegistrationFindUniqueOrThrowArgs} args - Arguments to find a MockRegistration
         * @example
         * // Get one MockRegistration
         * const mockRegistration = await prisma.mockRegistration.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends MockRegistrationFindUniqueOrThrowArgs>(
            args: SelectSubset<T, MockRegistrationFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first MockRegistration that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationFindFirstArgs} args - Arguments to find a MockRegistration
         * @example
         * // Get one MockRegistration
         * const mockRegistration = await prisma.mockRegistration.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends MockRegistrationFindFirstArgs>(
            args?: SelectSubset<T, MockRegistrationFindFirstArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first MockRegistration that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationFindFirstOrThrowArgs} args - Arguments to find a MockRegistration
         * @example
         * // Get one MockRegistration
         * const mockRegistration = await prisma.mockRegistration.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends MockRegistrationFindFirstOrThrowArgs>(
            args?: SelectSubset<T, MockRegistrationFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more MockRegistrations that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all MockRegistrations
         * const mockRegistrations = await prisma.mockRegistration.findMany()
         *
         * // Get first 10 MockRegistrations
         * const mockRegistrations = await prisma.mockRegistration.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const mockRegistrationWithIdOnly = await prisma.mockRegistration.findMany({ select: { id: true } })
         *
         */
        findMany<T extends MockRegistrationFindManyArgs>(
            args?: SelectSubset<T, MockRegistrationFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a MockRegistration.
         * @param {MockRegistrationCreateArgs} args - Arguments to create a MockRegistration.
         * @example
         * // Create one MockRegistration
         * const MockRegistration = await prisma.mockRegistration.create({
         *   data: {
         *     // ... data to create a MockRegistration
         *   }
         * })
         *
         */
        create<T extends MockRegistrationCreateArgs>(
            args: SelectSubset<T, MockRegistrationCreateArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many MockRegistrations.
         * @param {MockRegistrationCreateManyArgs} args - Arguments to create many MockRegistrations.
         * @example
         * // Create many MockRegistrations
         * const mockRegistration = await prisma.mockRegistration.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends MockRegistrationCreateManyArgs>(
            args?: SelectSubset<T, MockRegistrationCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many MockRegistrations and returns the data saved in the database.
         * @param {MockRegistrationCreateManyAndReturnArgs} args - Arguments to create many MockRegistrations.
         * @example
         * // Create many MockRegistrations
         * const mockRegistration = await prisma.mockRegistration.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many MockRegistrations and only return the `id`
         * const mockRegistrationWithIdOnly = await prisma.mockRegistration.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends MockRegistrationCreateManyAndReturnArgs>(
            args?: SelectSubset<T, MockRegistrationCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a MockRegistration.
         * @param {MockRegistrationDeleteArgs} args - Arguments to delete one MockRegistration.
         * @example
         * // Delete one MockRegistration
         * const MockRegistration = await prisma.mockRegistration.delete({
         *   where: {
         *     // ... filter to delete one MockRegistration
         *   }
         * })
         *
         */
        delete<T extends MockRegistrationDeleteArgs>(
            args: SelectSubset<T, MockRegistrationDeleteArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one MockRegistration.
         * @param {MockRegistrationUpdateArgs} args - Arguments to update one MockRegistration.
         * @example
         * // Update one MockRegistration
         * const mockRegistration = await prisma.mockRegistration.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends MockRegistrationUpdateArgs>(
            args: SelectSubset<T, MockRegistrationUpdateArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more MockRegistrations.
         * @param {MockRegistrationDeleteManyArgs} args - Arguments to filter MockRegistrations to delete.
         * @example
         * // Delete a few MockRegistrations
         * const { count } = await prisma.mockRegistration.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends MockRegistrationDeleteManyArgs>(
            args?: SelectSubset<T, MockRegistrationDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more MockRegistrations.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many MockRegistrations
         * const mockRegistration = await prisma.mockRegistration.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends MockRegistrationUpdateManyArgs>(
            args: SelectSubset<T, MockRegistrationUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more MockRegistrations and returns the data updated in the database.
         * @param {MockRegistrationUpdateManyAndReturnArgs} args - Arguments to update many MockRegistrations.
         * @example
         * // Update many MockRegistrations
         * const mockRegistration = await prisma.mockRegistration.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more MockRegistrations and only return the `id`
         * const mockRegistrationWithIdOnly = await prisma.mockRegistration.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends MockRegistrationUpdateManyAndReturnArgs>(
            args: SelectSubset<T, MockRegistrationUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one MockRegistration.
         * @param {MockRegistrationUpsertArgs} args - Arguments to update or create a MockRegistration.
         * @example
         * // Update or create a MockRegistration
         * const mockRegistration = await prisma.mockRegistration.upsert({
         *   create: {
         *     // ... data to create a MockRegistration
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the MockRegistration we want to update
         *   }
         * })
         */
        upsert<T extends MockRegistrationUpsertArgs>(
            args: SelectSubset<T, MockRegistrationUpsertArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of MockRegistrations.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationCountArgs} args - Arguments to filter MockRegistrations to count.
         * @example
         * // Count the number of MockRegistrations
         * const count = await prisma.mockRegistration.count({
         *   where: {
         *     // ... the filter for the MockRegistrations we want to count
         *   }
         * })
         **/
        count<T extends MockRegistrationCountArgs>(
            args?: Subset<T, MockRegistrationCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], MockRegistrationCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a MockRegistration.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends MockRegistrationAggregateArgs>(
            args: Subset<T, MockRegistrationAggregateArgs>,
        ): Prisma.PrismaPromise<GetMockRegistrationAggregateType<T>>;

        /**
         * Group by MockRegistration.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends MockRegistrationGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: MockRegistrationGroupByArgs['orderBy'] }
                : { orderBy?: MockRegistrationGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, MockRegistrationGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetMockRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the MockRegistration model
         */
        readonly fields: MockRegistrationFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for MockRegistration.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__MockRegistrationClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        students<T extends MockRegistration$studentsArgs<ExtArgs> = {}>(
            args?: Subset<T, MockRegistration$studentsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the MockRegistration model
     */
    interface MockRegistrationFieldRefs {
        readonly id: FieldRef<'MockRegistration', 'String'>;
        readonly createdAt: FieldRef<'MockRegistration', 'DateTime'>;
        readonly createdBy: FieldRef<'MockRegistration', 'String'>;
        readonly updatedAt: FieldRef<'MockRegistration', 'DateTime'>;
        readonly updatedBy: FieldRef<'MockRegistration', 'String'>;
        readonly commentUser: FieldRef<'MockRegistration', 'String'>;
        readonly commentAdmin: FieldRef<'MockRegistration', 'String'>;
        readonly title: FieldRef<'MockRegistration', 'String'>;
        readonly date: FieldRef<'MockRegistration', 'DateTime'>;
        readonly branchId: FieldRef<'MockRegistration', 'String'>;
        readonly isActive: FieldRef<'MockRegistration', 'Boolean'>;
    }

    // Custom InputTypes
    /**
     * MockRegistration findUnique
     */
    export type MockRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistration to fetch.
         */
        where: MockRegistrationWhereUniqueInput;
    };

    /**
     * MockRegistration findUniqueOrThrow
     */
    export type MockRegistrationFindUniqueOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistration to fetch.
         */
        where: MockRegistrationWhereUniqueInput;
    };

    /**
     * MockRegistration findFirst
     */
    export type MockRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistration to fetch.
         */
        where?: MockRegistrationWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrations to fetch.
         */
        orderBy?: MockRegistrationOrderByWithRelationInput | MockRegistrationOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for MockRegistrations.
         */
        cursor?: MockRegistrationWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrations from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrations.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of MockRegistrations.
         */
        distinct?: MockRegistrationScalarFieldEnum | MockRegistrationScalarFieldEnum[];
    };

    /**
     * MockRegistration findFirstOrThrow
     */
    export type MockRegistrationFindFirstOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistration to fetch.
         */
        where?: MockRegistrationWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrations to fetch.
         */
        orderBy?: MockRegistrationOrderByWithRelationInput | MockRegistrationOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for MockRegistrations.
         */
        cursor?: MockRegistrationWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrations from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrations.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of MockRegistrations.
         */
        distinct?: MockRegistrationScalarFieldEnum | MockRegistrationScalarFieldEnum[];
    };

    /**
     * MockRegistration findMany
     */
    export type MockRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrations to fetch.
         */
        where?: MockRegistrationWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrations to fetch.
         */
        orderBy?: MockRegistrationOrderByWithRelationInput | MockRegistrationOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing MockRegistrations.
         */
        cursor?: MockRegistrationWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrations from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrations.
         */
        skip?: number;
        distinct?: MockRegistrationScalarFieldEnum | MockRegistrationScalarFieldEnum[];
    };

    /**
     * MockRegistration create
     */
    export type MockRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * The data needed to create a MockRegistration.
         */
        data: XOR<MockRegistrationCreateInput, MockRegistrationUncheckedCreateInput>;
    };

    /**
     * MockRegistration createMany
     */
    export type MockRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many MockRegistrations.
         */
        data: MockRegistrationCreateManyInput | MockRegistrationCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * MockRegistration createManyAndReturn
     */
    export type MockRegistrationCreateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * The data used to create many MockRegistrations.
         */
        data: MockRegistrationCreateManyInput | MockRegistrationCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * MockRegistration update
     */
    export type MockRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * The data needed to update a MockRegistration.
         */
        data: XOR<MockRegistrationUpdateInput, MockRegistrationUncheckedUpdateInput>;
        /**
         * Choose, which MockRegistration to update.
         */
        where: MockRegistrationWhereUniqueInput;
    };

    /**
     * MockRegistration updateMany
     */
    export type MockRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update MockRegistrations.
         */
        data: XOR<MockRegistrationUpdateManyMutationInput, MockRegistrationUncheckedUpdateManyInput>;
        /**
         * Filter which MockRegistrations to update
         */
        where?: MockRegistrationWhereInput;
        /**
         * Limit how many MockRegistrations to update.
         */
        limit?: number;
    };

    /**
     * MockRegistration updateManyAndReturn
     */
    export type MockRegistrationUpdateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * The data used to update MockRegistrations.
         */
        data: XOR<MockRegistrationUpdateManyMutationInput, MockRegistrationUncheckedUpdateManyInput>;
        /**
         * Filter which MockRegistrations to update
         */
        where?: MockRegistrationWhereInput;
        /**
         * Limit how many MockRegistrations to update.
         */
        limit?: number;
    };

    /**
     * MockRegistration upsert
     */
    export type MockRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * The filter to search for the MockRegistration to update in case it exists.
         */
        where: MockRegistrationWhereUniqueInput;
        /**
         * In case the MockRegistration found by the `where` argument doesn't exist, create a new MockRegistration with this data.
         */
        create: XOR<MockRegistrationCreateInput, MockRegistrationUncheckedCreateInput>;
        /**
         * In case the MockRegistration was found with the provided `where` argument, update it with this data.
         */
        update: XOR<MockRegistrationUpdateInput, MockRegistrationUncheckedUpdateInput>;
    };

    /**
     * MockRegistration delete
     */
    export type MockRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
        /**
         * Filter which MockRegistration to delete.
         */
        where: MockRegistrationWhereUniqueInput;
    };

    /**
     * MockRegistration deleteMany
     */
    export type MockRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which MockRegistrations to delete
         */
        where?: MockRegistrationWhereInput;
        /**
         * Limit how many MockRegistrations to delete.
         */
        limit?: number;
    };

    /**
     * MockRegistration.students
     */
    export type MockRegistration$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        where?: MockRegistrationStudentWhereInput;
        orderBy?: MockRegistrationStudentOrderByWithRelationInput | MockRegistrationStudentOrderByWithRelationInput[];
        cursor?: MockRegistrationStudentWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: MockRegistrationStudentScalarFieldEnum | MockRegistrationStudentScalarFieldEnum[];
    };

    /**
     * MockRegistration without action
     */
    export type MockRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the MockRegistration
         */
        select?: MockRegistrationSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistration
         */
        omit?: MockRegistrationOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationInclude<ExtArgs> | null;
    };

    /**
     * Model MockRegistrationStudent
     */

    export type AggregateMockRegistrationStudent = {
        _count: MockRegistrationStudentCountAggregateOutputType | null;
        _min: MockRegistrationStudentMinAggregateOutputType | null;
        _max: MockRegistrationStudentMaxAggregateOutputType | null;
    };

    export type MockRegistrationStudentMinAggregateOutputType = {
        id: string | null;
        studentId: string | null;
        mockRegistrationId: string | null;
        registeredAt: Date | null;
    };

    export type MockRegistrationStudentMaxAggregateOutputType = {
        id: string | null;
        studentId: string | null;
        mockRegistrationId: string | null;
        registeredAt: Date | null;
    };

    export type MockRegistrationStudentCountAggregateOutputType = {
        id: number;
        studentId: number;
        mockRegistrationId: number;
        registeredAt: number;
        _all: number;
    };

    export type MockRegistrationStudentMinAggregateInputType = {
        id?: true;
        studentId?: true;
        mockRegistrationId?: true;
        registeredAt?: true;
    };

    export type MockRegistrationStudentMaxAggregateInputType = {
        id?: true;
        studentId?: true;
        mockRegistrationId?: true;
        registeredAt?: true;
    };

    export type MockRegistrationStudentCountAggregateInputType = {
        id?: true;
        studentId?: true;
        mockRegistrationId?: true;
        registeredAt?: true;
        _all?: true;
    };

    export type MockRegistrationStudentAggregateArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which MockRegistrationStudent to aggregate.
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrationStudents to fetch.
         */
        orderBy?: MockRegistrationStudentOrderByWithRelationInput | MockRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: MockRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned MockRegistrationStudents
         **/
        _count?: true | MockRegistrationStudentCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: MockRegistrationStudentMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: MockRegistrationStudentMaxAggregateInputType;
    };

    export type GetMockRegistrationStudentAggregateType<T extends MockRegistrationStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateMockRegistrationStudent]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateMockRegistrationStudent[P]>
            : GetScalarType<T[P], AggregateMockRegistrationStudent[P]>;
    };

    export type MockRegistrationStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            where?: MockRegistrationStudentWhereInput;
            orderBy?:
                | MockRegistrationStudentOrderByWithAggregationInput
                | MockRegistrationStudentOrderByWithAggregationInput[];
            by: MockRegistrationStudentScalarFieldEnum[] | MockRegistrationStudentScalarFieldEnum;
            having?: MockRegistrationStudentScalarWhereWithAggregatesInput;
            take?: number;
            skip?: number;
            _count?: MockRegistrationStudentCountAggregateInputType | true;
            _min?: MockRegistrationStudentMinAggregateInputType;
            _max?: MockRegistrationStudentMaxAggregateInputType;
        };

    export type MockRegistrationStudentGroupByOutputType = {
        id: string;
        studentId: string;
        mockRegistrationId: string;
        registeredAt: Date;
        _count: MockRegistrationStudentCountAggregateOutputType | null;
        _min: MockRegistrationStudentMinAggregateOutputType | null;
        _max: MockRegistrationStudentMaxAggregateOutputType | null;
    };

    type GetMockRegistrationStudentGroupByPayload<T extends MockRegistrationStudentGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<MockRegistrationStudentGroupByOutputType, T['by']> & {
                [P in keyof T & keyof MockRegistrationStudentGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], MockRegistrationStudentGroupByOutputType[P]>
                    : GetScalarType<T[P], MockRegistrationStudentGroupByOutputType[P]>;
            }
        >
    >;

    export type MockRegistrationStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                studentId?: boolean;
                mockRegistrationId?: boolean;
                registeredAt?: boolean;
                mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['mockRegistrationStudent']
        >;

    export type MockRegistrationStudentSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            studentId?: boolean;
            mockRegistrationId?: boolean;
            registeredAt?: boolean;
            mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['mockRegistrationStudent']
    >;

    export type MockRegistrationStudentSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            studentId?: boolean;
            mockRegistrationId?: boolean;
            registeredAt?: boolean;
            mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['mockRegistrationStudent']
    >;

    export type MockRegistrationStudentSelectScalar = {
        id?: boolean;
        studentId?: boolean;
        mockRegistrationId?: boolean;
        registeredAt?: boolean;
    };

    export type MockRegistrationStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            'id' | 'studentId' | 'mockRegistrationId' | 'registeredAt',
            ExtArgs['result']['mockRegistrationStudent']
        >;
    export type MockRegistrationStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
    };
    export type MockRegistrationStudentIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
    };
    export type MockRegistrationStudentIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        mockRegistration?: boolean | MockRegistrationDefaultArgs<ExtArgs>;
    };

    export type $MockRegistrationStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'MockRegistrationStudent';
        objects: {
            mockRegistration: Prisma.$MockRegistrationPayload<ExtArgs>;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                studentId: string;
                mockRegistrationId: string;
                registeredAt: Date;
            },
            ExtArgs['result']['mockRegistrationStudent']
        >;
        composites: {};
    };

    type MockRegistrationStudentGetPayload<S extends boolean | null | undefined | MockRegistrationStudentDefaultArgs> =
        $Result.GetResult<Prisma.$MockRegistrationStudentPayload, S>;

    type MockRegistrationStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        MockRegistrationStudentFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: MockRegistrationStudentCountAggregateInputType | true;
    };

    export interface MockRegistrationStudentDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: {
            types: Prisma.TypeMap<ExtArgs>['model']['MockRegistrationStudent'];
            meta: { name: 'MockRegistrationStudent' };
        };
        /**
         * Find zero or one MockRegistrationStudent that matches the filter.
         * @param {MockRegistrationStudentFindUniqueArgs} args - Arguments to find a MockRegistrationStudent
         * @example
         * // Get one MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends MockRegistrationStudentFindUniqueArgs>(
            args: SelectSubset<T, MockRegistrationStudentFindUniqueArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'findUnique',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one MockRegistrationStudent that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {MockRegistrationStudentFindUniqueOrThrowArgs} args - Arguments to find a MockRegistrationStudent
         * @example
         * // Get one MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends MockRegistrationStudentFindUniqueOrThrowArgs>(
            args: SelectSubset<T, MockRegistrationStudentFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'findUniqueOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first MockRegistrationStudent that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentFindFirstArgs} args - Arguments to find a MockRegistrationStudent
         * @example
         * // Get one MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends MockRegistrationStudentFindFirstArgs>(
            args?: SelectSubset<T, MockRegistrationStudentFindFirstArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'findFirst',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first MockRegistrationStudent that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentFindFirstOrThrowArgs} args - Arguments to find a MockRegistrationStudent
         * @example
         * // Get one MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends MockRegistrationStudentFindFirstOrThrowArgs>(
            args?: SelectSubset<T, MockRegistrationStudentFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'findFirstOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more MockRegistrationStudents that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all MockRegistrationStudents
         * const mockRegistrationStudents = await prisma.mockRegistrationStudent.findMany()
         *
         * // Get first 10 MockRegistrationStudents
         * const mockRegistrationStudents = await prisma.mockRegistrationStudent.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const mockRegistrationStudentWithIdOnly = await prisma.mockRegistrationStudent.findMany({ select: { id: true } })
         *
         */
        findMany<T extends MockRegistrationStudentFindManyArgs>(
            args?: SelectSubset<T, MockRegistrationStudentFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a MockRegistrationStudent.
         * @param {MockRegistrationStudentCreateArgs} args - Arguments to create a MockRegistrationStudent.
         * @example
         * // Create one MockRegistrationStudent
         * const MockRegistrationStudent = await prisma.mockRegistrationStudent.create({
         *   data: {
         *     // ... data to create a MockRegistrationStudent
         *   }
         * })
         *
         */
        create<T extends MockRegistrationStudentCreateArgs>(
            args: SelectSubset<T, MockRegistrationStudentCreateArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many MockRegistrationStudents.
         * @param {MockRegistrationStudentCreateManyArgs} args - Arguments to create many MockRegistrationStudents.
         * @example
         * // Create many MockRegistrationStudents
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends MockRegistrationStudentCreateManyArgs>(
            args?: SelectSubset<T, MockRegistrationStudentCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many MockRegistrationStudents and returns the data saved in the database.
         * @param {MockRegistrationStudentCreateManyAndReturnArgs} args - Arguments to create many MockRegistrationStudents.
         * @example
         * // Create many MockRegistrationStudents
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many MockRegistrationStudents and only return the `id`
         * const mockRegistrationStudentWithIdOnly = await prisma.mockRegistrationStudent.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends MockRegistrationStudentCreateManyAndReturnArgs>(
            args?: SelectSubset<T, MockRegistrationStudentCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'createManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Delete a MockRegistrationStudent.
         * @param {MockRegistrationStudentDeleteArgs} args - Arguments to delete one MockRegistrationStudent.
         * @example
         * // Delete one MockRegistrationStudent
         * const MockRegistrationStudent = await prisma.mockRegistrationStudent.delete({
         *   where: {
         *     // ... filter to delete one MockRegistrationStudent
         *   }
         * })
         *
         */
        delete<T extends MockRegistrationStudentDeleteArgs>(
            args: SelectSubset<T, MockRegistrationStudentDeleteArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one MockRegistrationStudent.
         * @param {MockRegistrationStudentUpdateArgs} args - Arguments to update one MockRegistrationStudent.
         * @example
         * // Update one MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends MockRegistrationStudentUpdateArgs>(
            args: SelectSubset<T, MockRegistrationStudentUpdateArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more MockRegistrationStudents.
         * @param {MockRegistrationStudentDeleteManyArgs} args - Arguments to filter MockRegistrationStudents to delete.
         * @example
         * // Delete a few MockRegistrationStudents
         * const { count } = await prisma.mockRegistrationStudent.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends MockRegistrationStudentDeleteManyArgs>(
            args?: SelectSubset<T, MockRegistrationStudentDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more MockRegistrationStudents.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many MockRegistrationStudents
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends MockRegistrationStudentUpdateManyArgs>(
            args: SelectSubset<T, MockRegistrationStudentUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more MockRegistrationStudents and returns the data updated in the database.
         * @param {MockRegistrationStudentUpdateManyAndReturnArgs} args - Arguments to update many MockRegistrationStudents.
         * @example
         * // Update many MockRegistrationStudents
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more MockRegistrationStudents and only return the `id`
         * const mockRegistrationStudentWithIdOnly = await prisma.mockRegistrationStudent.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends MockRegistrationStudentUpdateManyAndReturnArgs>(
            args: SelectSubset<T, MockRegistrationStudentUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$MockRegistrationStudentPayload<ExtArgs>,
                T,
                'updateManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Create or update one MockRegistrationStudent.
         * @param {MockRegistrationStudentUpsertArgs} args - Arguments to update or create a MockRegistrationStudent.
         * @example
         * // Update or create a MockRegistrationStudent
         * const mockRegistrationStudent = await prisma.mockRegistrationStudent.upsert({
         *   create: {
         *     // ... data to create a MockRegistrationStudent
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the MockRegistrationStudent we want to update
         *   }
         * })
         */
        upsert<T extends MockRegistrationStudentUpsertArgs>(
            args: SelectSubset<T, MockRegistrationStudentUpsertArgs<ExtArgs>>,
        ): Prisma__MockRegistrationStudentClient<
            $Result.GetResult<Prisma.$MockRegistrationStudentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of MockRegistrationStudents.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentCountArgs} args - Arguments to filter MockRegistrationStudents to count.
         * @example
         * // Count the number of MockRegistrationStudents
         * const count = await prisma.mockRegistrationStudent.count({
         *   where: {
         *     // ... the filter for the MockRegistrationStudents we want to count
         *   }
         * })
         **/
        count<T extends MockRegistrationStudentCountArgs>(
            args?: Subset<T, MockRegistrationStudentCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], MockRegistrationStudentCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a MockRegistrationStudent.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends MockRegistrationStudentAggregateArgs>(
            args: Subset<T, MockRegistrationStudentAggregateArgs>,
        ): Prisma.PrismaPromise<GetMockRegistrationStudentAggregateType<T>>;

        /**
         * Group by MockRegistrationStudent.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MockRegistrationStudentGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends MockRegistrationStudentGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: MockRegistrationStudentGroupByArgs['orderBy'] }
                : { orderBy?: MockRegistrationStudentGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, MockRegistrationStudentGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetMockRegistrationStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the MockRegistrationStudent model
         */
        readonly fields: MockRegistrationStudentFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for MockRegistrationStudent.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__MockRegistrationStudentClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        mockRegistration<T extends MockRegistrationDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, MockRegistrationDefaultArgs<ExtArgs>>,
        ): Prisma__MockRegistrationClient<
            | $Result.GetResult<Prisma.$MockRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
            | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the MockRegistrationStudent model
     */
    interface MockRegistrationStudentFieldRefs {
        readonly id: FieldRef<'MockRegistrationStudent', 'String'>;
        readonly studentId: FieldRef<'MockRegistrationStudent', 'String'>;
        readonly mockRegistrationId: FieldRef<'MockRegistrationStudent', 'String'>;
        readonly registeredAt: FieldRef<'MockRegistrationStudent', 'DateTime'>;
    }

    // Custom InputTypes
    /**
     * MockRegistrationStudent findUnique
     */
    export type MockRegistrationStudentFindUniqueArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrationStudent to fetch.
         */
        where: MockRegistrationStudentWhereUniqueInput;
    };

    /**
     * MockRegistrationStudent findUniqueOrThrow
     */
    export type MockRegistrationStudentFindUniqueOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrationStudent to fetch.
         */
        where: MockRegistrationStudentWhereUniqueInput;
    };

    /**
     * MockRegistrationStudent findFirst
     */
    export type MockRegistrationStudentFindFirstArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrationStudent to fetch.
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrationStudents to fetch.
         */
        orderBy?: MockRegistrationStudentOrderByWithRelationInput | MockRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for MockRegistrationStudents.
         */
        cursor?: MockRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of MockRegistrationStudents.
         */
        distinct?: MockRegistrationStudentScalarFieldEnum | MockRegistrationStudentScalarFieldEnum[];
    };

    /**
     * MockRegistrationStudent findFirstOrThrow
     */
    export type MockRegistrationStudentFindFirstOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrationStudent to fetch.
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrationStudents to fetch.
         */
        orderBy?: MockRegistrationStudentOrderByWithRelationInput | MockRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for MockRegistrationStudents.
         */
        cursor?: MockRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrationStudents.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of MockRegistrationStudents.
         */
        distinct?: MockRegistrationStudentScalarFieldEnum | MockRegistrationStudentScalarFieldEnum[];
    };

    /**
     * MockRegistrationStudent findMany
     */
    export type MockRegistrationStudentFindManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentInclude<ExtArgs> | null;
        /**
         * Filter, which MockRegistrationStudents to fetch.
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of MockRegistrationStudents to fetch.
         */
        orderBy?: MockRegistrationStudentOrderByWithRelationInput | MockRegistrationStudentOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing MockRegistrationStudents.
         */
        cursor?: MockRegistrationStudentWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` MockRegistrationStudents from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` MockRegistrationStudents.
         */
        skip?: number;
        distinct?: MockRegistrationStudentScalarFieldEnum | MockRegistrationStudentScalarFieldEnum[];
    };

    /**
     * MockRegistrationStudent create
     */
    export type MockRegistrationStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the MockRegistrationStudent
             */
            select?: MockRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the MockRegistrationStudent
             */
            omit?: MockRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: MockRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The data needed to create a MockRegistrationStudent.
             */
            data: XOR<MockRegistrationStudentCreateInput, MockRegistrationStudentUncheckedCreateInput>;
        };

    /**
     * MockRegistrationStudent createMany
     */
    export type MockRegistrationStudentCreateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to create many MockRegistrationStudents.
         */
        data: MockRegistrationStudentCreateManyInput | MockRegistrationStudentCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * MockRegistrationStudent createManyAndReturn
     */
    export type MockRegistrationStudentCreateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * The data used to create many MockRegistrationStudents.
         */
        data: MockRegistrationStudentCreateManyInput | MockRegistrationStudentCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * MockRegistrationStudent update
     */
    export type MockRegistrationStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the MockRegistrationStudent
             */
            select?: MockRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the MockRegistrationStudent
             */
            omit?: MockRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: MockRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The data needed to update a MockRegistrationStudent.
             */
            data: XOR<MockRegistrationStudentUpdateInput, MockRegistrationStudentUncheckedUpdateInput>;
            /**
             * Choose, which MockRegistrationStudent to update.
             */
            where: MockRegistrationStudentWhereUniqueInput;
        };

    /**
     * MockRegistrationStudent updateMany
     */
    export type MockRegistrationStudentUpdateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to update MockRegistrationStudents.
         */
        data: XOR<MockRegistrationStudentUpdateManyMutationInput, MockRegistrationStudentUncheckedUpdateManyInput>;
        /**
         * Filter which MockRegistrationStudents to update
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * Limit how many MockRegistrationStudents to update.
         */
        limit?: number;
    };

    /**
     * MockRegistrationStudent updateManyAndReturn
     */
    export type MockRegistrationStudentUpdateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the MockRegistrationStudent
         */
        select?: MockRegistrationStudentSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the MockRegistrationStudent
         */
        omit?: MockRegistrationStudentOmit<ExtArgs> | null;
        /**
         * The data used to update MockRegistrationStudents.
         */
        data: XOR<MockRegistrationStudentUpdateManyMutationInput, MockRegistrationStudentUncheckedUpdateManyInput>;
        /**
         * Filter which MockRegistrationStudents to update
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * Limit how many MockRegistrationStudents to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: MockRegistrationStudentIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * MockRegistrationStudent upsert
     */
    export type MockRegistrationStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the MockRegistrationStudent
             */
            select?: MockRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the MockRegistrationStudent
             */
            omit?: MockRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: MockRegistrationStudentInclude<ExtArgs> | null;
            /**
             * The filter to search for the MockRegistrationStudent to update in case it exists.
             */
            where: MockRegistrationStudentWhereUniqueInput;
            /**
             * In case the MockRegistrationStudent found by the `where` argument doesn't exist, create a new MockRegistrationStudent with this data.
             */
            create: XOR<MockRegistrationStudentCreateInput, MockRegistrationStudentUncheckedCreateInput>;
            /**
             * In case the MockRegistrationStudent was found with the provided `where` argument, update it with this data.
             */
            update: XOR<MockRegistrationStudentUpdateInput, MockRegistrationStudentUncheckedUpdateInput>;
        };

    /**
     * MockRegistrationStudent delete
     */
    export type MockRegistrationStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the MockRegistrationStudent
             */
            select?: MockRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the MockRegistrationStudent
             */
            omit?: MockRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: MockRegistrationStudentInclude<ExtArgs> | null;
            /**
             * Filter which MockRegistrationStudent to delete.
             */
            where: MockRegistrationStudentWhereUniqueInput;
        };

    /**
     * MockRegistrationStudent deleteMany
     */
    export type MockRegistrationStudentDeleteManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which MockRegistrationStudents to delete
         */
        where?: MockRegistrationStudentWhereInput;
        /**
         * Limit how many MockRegistrationStudents to delete.
         */
        limit?: number;
    };

    /**
     * MockRegistrationStudent without action
     */
    export type MockRegistrationStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the MockRegistrationStudent
             */
            select?: MockRegistrationStudentSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the MockRegistrationStudent
             */
            omit?: MockRegistrationStudentOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: MockRegistrationStudentInclude<ExtArgs> | null;
        };

    /**
     * Model JobHunting
     */

    export type AggregateJobHunting = {
        _count: JobHuntingCountAggregateOutputType | null;
        _avg: JobHuntingAvgAggregateOutputType | null;
        _sum: JobHuntingSumAggregateOutputType | null;
        _min: JobHuntingMinAggregateOutputType | null;
        _max: JobHuntingMaxAggregateOutputType | null;
    };

    export type JobHuntingAvgAggregateOutputType = {
        salary: number | null;
    };

    export type JobHuntingSumAggregateOutputType = {
        salary: number | null;
    };

    export type JobHuntingMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        description: string | null;
        workExperience: $Enums.WorkExperience | null;
        companyId: string | null;
        cityId: string | null;
        certificateRequirements: string | null;
        workScheduleHours: $Enums.WorkScheduleHours | null;
        employmentType: $Enums.EmploymentType | null;
        workMode: $Enums.WorkMode | null;
        salary: number | null;
        responsibilities: string | null;
        requirements: string | null;
        conditions: string | null;
    };

    export type JobHuntingMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        description: string | null;
        workExperience: $Enums.WorkExperience | null;
        companyId: string | null;
        cityId: string | null;
        certificateRequirements: string | null;
        workScheduleHours: $Enums.WorkScheduleHours | null;
        employmentType: $Enums.EmploymentType | null;
        workMode: $Enums.WorkMode | null;
        salary: number | null;
        responsibilities: string | null;
        requirements: string | null;
        conditions: string | null;
    };

    export type JobHuntingCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        title: number;
        description: number;
        workExperience: number;
        companyId: number;
        cityId: number;
        certificateRequirements: number;
        workScheduleHours: number;
        employmentType: number;
        workMode: number;
        salary: number;
        responsibilities: number;
        requirements: number;
        conditions: number;
        _all: number;
    };

    export type JobHuntingAvgAggregateInputType = {
        salary?: true;
    };

    export type JobHuntingSumAggregateInputType = {
        salary?: true;
    };

    export type JobHuntingMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        workExperience?: true;
        companyId?: true;
        cityId?: true;
        certificateRequirements?: true;
        workScheduleHours?: true;
        employmentType?: true;
        workMode?: true;
        salary?: true;
        responsibilities?: true;
        requirements?: true;
        conditions?: true;
    };

    export type JobHuntingMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        workExperience?: true;
        companyId?: true;
        cityId?: true;
        certificateRequirements?: true;
        workScheduleHours?: true;
        employmentType?: true;
        workMode?: true;
        salary?: true;
        responsibilities?: true;
        requirements?: true;
        conditions?: true;
    };

    export type JobHuntingCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        workExperience?: true;
        companyId?: true;
        cityId?: true;
        certificateRequirements?: true;
        workScheduleHours?: true;
        employmentType?: true;
        workMode?: true;
        salary?: true;
        responsibilities?: true;
        requirements?: true;
        conditions?: true;
        _all?: true;
    };

    export type JobHuntingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which JobHunting to aggregate.
         */
        where?: JobHuntingWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of JobHuntings to fetch.
         */
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: JobHuntingWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` JobHuntings from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` JobHuntings.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned JobHuntings
         **/
        _count?: true | JobHuntingCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: JobHuntingAvgAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: JobHuntingSumAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: JobHuntingMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: JobHuntingMaxAggregateInputType;
    };

    export type GetJobHuntingAggregateType<T extends JobHuntingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobHunting]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateJobHunting[P]>
            : GetScalarType<T[P], AggregateJobHunting[P]>;
    };

    export type JobHuntingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: JobHuntingWhereInput;
        orderBy?: JobHuntingOrderByWithAggregationInput | JobHuntingOrderByWithAggregationInput[];
        by: JobHuntingScalarFieldEnum[] | JobHuntingScalarFieldEnum;
        having?: JobHuntingScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: JobHuntingCountAggregateInputType | true;
        _avg?: JobHuntingAvgAggregateInputType;
        _sum?: JobHuntingSumAggregateInputType;
        _min?: JobHuntingMinAggregateInputType;
        _max?: JobHuntingMaxAggregateInputType;
    };

    export type JobHuntingGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string;
        updatedAt: Date;
        updatedBy: string | null;
        title: string;
        description: string | null;
        workExperience: $Enums.WorkExperience;
        companyId: string | null;
        cityId: string | null;
        certificateRequirements: string | null;
        workScheduleHours: $Enums.WorkScheduleHours | null;
        employmentType: $Enums.EmploymentType | null;
        workMode: $Enums.WorkMode | null;
        salary: number | null;
        responsibilities: string | null;
        requirements: string | null;
        conditions: string | null;
        _count: JobHuntingCountAggregateOutputType | null;
        _avg: JobHuntingAvgAggregateOutputType | null;
        _sum: JobHuntingSumAggregateOutputType | null;
        _min: JobHuntingMinAggregateOutputType | null;
        _max: JobHuntingMaxAggregateOutputType | null;
    };

    type GetJobHuntingGroupByPayload<T extends JobHuntingGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<JobHuntingGroupByOutputType, T['by']> & {
                [P in keyof T & keyof JobHuntingGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], JobHuntingGroupByOutputType[P]>
                    : GetScalarType<T[P], JobHuntingGroupByOutputType[P]>;
            }
        >
    >;

    export type JobHuntingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                title?: boolean;
                description?: boolean;
                workExperience?: boolean;
                companyId?: boolean;
                cityId?: boolean;
                certificateRequirements?: boolean;
                workScheduleHours?: boolean;
                employmentType?: boolean;
                workMode?: boolean;
                salary?: boolean;
                responsibilities?: boolean;
                requirements?: boolean;
                conditions?: boolean;
                company?: boolean | JobHunting$companyArgs<ExtArgs>;
                city?: boolean | JobHunting$cityArgs<ExtArgs>;
            },
            ExtArgs['result']['jobHunting']
        >;

    export type JobHuntingSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            title?: boolean;
            description?: boolean;
            workExperience?: boolean;
            companyId?: boolean;
            cityId?: boolean;
            certificateRequirements?: boolean;
            workScheduleHours?: boolean;
            employmentType?: boolean;
            workMode?: boolean;
            salary?: boolean;
            responsibilities?: boolean;
            requirements?: boolean;
            conditions?: boolean;
            company?: boolean | JobHunting$companyArgs<ExtArgs>;
            city?: boolean | JobHunting$cityArgs<ExtArgs>;
        },
        ExtArgs['result']['jobHunting']
    >;

    export type JobHuntingSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            title?: boolean;
            description?: boolean;
            workExperience?: boolean;
            companyId?: boolean;
            cityId?: boolean;
            certificateRequirements?: boolean;
            workScheduleHours?: boolean;
            employmentType?: boolean;
            workMode?: boolean;
            salary?: boolean;
            responsibilities?: boolean;
            requirements?: boolean;
            conditions?: boolean;
            company?: boolean | JobHunting$companyArgs<ExtArgs>;
            city?: boolean | JobHunting$cityArgs<ExtArgs>;
        },
        ExtArgs['result']['jobHunting']
    >;

    export type JobHuntingSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        title?: boolean;
        description?: boolean;
        workExperience?: boolean;
        companyId?: boolean;
        cityId?: boolean;
        certificateRequirements?: boolean;
        workScheduleHours?: boolean;
        employmentType?: boolean;
        workMode?: boolean;
        salary?: boolean;
        responsibilities?: boolean;
        requirements?: boolean;
        conditions?: boolean;
    };

    export type JobHuntingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            | 'id'
            | 'createdAt'
            | 'createdBy'
            | 'updatedAt'
            | 'updatedBy'
            | 'title'
            | 'description'
            | 'workExperience'
            | 'companyId'
            | 'cityId'
            | 'certificateRequirements'
            | 'workScheduleHours'
            | 'employmentType'
            | 'workMode'
            | 'salary'
            | 'responsibilities'
            | 'requirements'
            | 'conditions',
            ExtArgs['result']['jobHunting']
        >;
    export type JobHuntingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        company?: boolean | JobHunting$companyArgs<ExtArgs>;
        city?: boolean | JobHunting$cityArgs<ExtArgs>;
    };
    export type JobHuntingIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        company?: boolean | JobHunting$companyArgs<ExtArgs>;
        city?: boolean | JobHunting$cityArgs<ExtArgs>;
    };
    export type JobHuntingIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        company?: boolean | JobHunting$companyArgs<ExtArgs>;
        city?: boolean | JobHunting$cityArgs<ExtArgs>;
    };

    export type $JobHuntingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'JobHunting';
        objects: {
            company: Prisma.$CompanyPayload<ExtArgs> | null;
            city: Prisma.$CityPayload<ExtArgs> | null;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string;
                updatedAt: Date;
                updatedBy: string | null;
                title: string;
                description: string | null;
                workExperience: $Enums.WorkExperience;
                companyId: string | null;
                cityId: string | null;
                certificateRequirements: string | null;
                workScheduleHours: $Enums.WorkScheduleHours | null;
                employmentType: $Enums.EmploymentType | null;
                workMode: $Enums.WorkMode | null;
                salary: number | null;
                responsibilities: string | null;
                requirements: string | null;
                conditions: string | null;
            },
            ExtArgs['result']['jobHunting']
        >;
        composites: {};
    };

    type JobHuntingGetPayload<S extends boolean | null | undefined | JobHuntingDefaultArgs> = $Result.GetResult<
        Prisma.$JobHuntingPayload,
        S
    >;

    type JobHuntingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        JobHuntingFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: JobHuntingCountAggregateInputType | true;
    };

    export interface JobHuntingDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobHunting']; meta: { name: 'JobHunting' } };
        /**
         * Find zero or one JobHunting that matches the filter.
         * @param {JobHuntingFindUniqueArgs} args - Arguments to find a JobHunting
         * @example
         * // Get one JobHunting
         * const jobHunting = await prisma.jobHunting.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends JobHuntingFindUniqueArgs>(
            args: SelectSubset<T, JobHuntingFindUniqueArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one JobHunting that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {JobHuntingFindUniqueOrThrowArgs} args - Arguments to find a JobHunting
         * @example
         * // Get one JobHunting
         * const jobHunting = await prisma.jobHunting.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends JobHuntingFindUniqueOrThrowArgs>(
            args: SelectSubset<T, JobHuntingFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first JobHunting that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingFindFirstArgs} args - Arguments to find a JobHunting
         * @example
         * // Get one JobHunting
         * const jobHunting = await prisma.jobHunting.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends JobHuntingFindFirstArgs>(
            args?: SelectSubset<T, JobHuntingFindFirstArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first JobHunting that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingFindFirstOrThrowArgs} args - Arguments to find a JobHunting
         * @example
         * // Get one JobHunting
         * const jobHunting = await prisma.jobHunting.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends JobHuntingFindFirstOrThrowArgs>(
            args?: SelectSubset<T, JobHuntingFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more JobHuntings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all JobHuntings
         * const jobHuntings = await prisma.jobHunting.findMany()
         *
         * // Get first 10 JobHuntings
         * const jobHuntings = await prisma.jobHunting.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const jobHuntingWithIdOnly = await prisma.jobHunting.findMany({ select: { id: true } })
         *
         */
        findMany<T extends JobHuntingFindManyArgs>(
            args?: SelectSubset<T, JobHuntingFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a JobHunting.
         * @param {JobHuntingCreateArgs} args - Arguments to create a JobHunting.
         * @example
         * // Create one JobHunting
         * const JobHunting = await prisma.jobHunting.create({
         *   data: {
         *     // ... data to create a JobHunting
         *   }
         * })
         *
         */
        create<T extends JobHuntingCreateArgs>(
            args: SelectSubset<T, JobHuntingCreateArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many JobHuntings.
         * @param {JobHuntingCreateManyArgs} args - Arguments to create many JobHuntings.
         * @example
         * // Create many JobHuntings
         * const jobHunting = await prisma.jobHunting.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends JobHuntingCreateManyArgs>(
            args?: SelectSubset<T, JobHuntingCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many JobHuntings and returns the data saved in the database.
         * @param {JobHuntingCreateManyAndReturnArgs} args - Arguments to create many JobHuntings.
         * @example
         * // Create many JobHuntings
         * const jobHunting = await prisma.jobHunting.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many JobHuntings and only return the `id`
         * const jobHuntingWithIdOnly = await prisma.jobHunting.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends JobHuntingCreateManyAndReturnArgs>(
            args?: SelectSubset<T, JobHuntingCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a JobHunting.
         * @param {JobHuntingDeleteArgs} args - Arguments to delete one JobHunting.
         * @example
         * // Delete one JobHunting
         * const JobHunting = await prisma.jobHunting.delete({
         *   where: {
         *     // ... filter to delete one JobHunting
         *   }
         * })
         *
         */
        delete<T extends JobHuntingDeleteArgs>(
            args: SelectSubset<T, JobHuntingDeleteArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one JobHunting.
         * @param {JobHuntingUpdateArgs} args - Arguments to update one JobHunting.
         * @example
         * // Update one JobHunting
         * const jobHunting = await prisma.jobHunting.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends JobHuntingUpdateArgs>(
            args: SelectSubset<T, JobHuntingUpdateArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more JobHuntings.
         * @param {JobHuntingDeleteManyArgs} args - Arguments to filter JobHuntings to delete.
         * @example
         * // Delete a few JobHuntings
         * const { count } = await prisma.jobHunting.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends JobHuntingDeleteManyArgs>(
            args?: SelectSubset<T, JobHuntingDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more JobHuntings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many JobHuntings
         * const jobHunting = await prisma.jobHunting.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends JobHuntingUpdateManyArgs>(
            args: SelectSubset<T, JobHuntingUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more JobHuntings and returns the data updated in the database.
         * @param {JobHuntingUpdateManyAndReturnArgs} args - Arguments to update many JobHuntings.
         * @example
         * // Update many JobHuntings
         * const jobHunting = await prisma.jobHunting.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more JobHuntings and only return the `id`
         * const jobHuntingWithIdOnly = await prisma.jobHunting.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends JobHuntingUpdateManyAndReturnArgs>(
            args: SelectSubset<T, JobHuntingUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one JobHunting.
         * @param {JobHuntingUpsertArgs} args - Arguments to update or create a JobHunting.
         * @example
         * // Update or create a JobHunting
         * const jobHunting = await prisma.jobHunting.upsert({
         *   create: {
         *     // ... data to create a JobHunting
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the JobHunting we want to update
         *   }
         * })
         */
        upsert<T extends JobHuntingUpsertArgs>(
            args: SelectSubset<T, JobHuntingUpsertArgs<ExtArgs>>,
        ): Prisma__JobHuntingClient<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of JobHuntings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingCountArgs} args - Arguments to filter JobHuntings to count.
         * @example
         * // Count the number of JobHuntings
         * const count = await prisma.jobHunting.count({
         *   where: {
         *     // ... the filter for the JobHuntings we want to count
         *   }
         * })
         **/
        count<T extends JobHuntingCountArgs>(
            args?: Subset<T, JobHuntingCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], JobHuntingCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a JobHunting.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends JobHuntingAggregateArgs>(
            args: Subset<T, JobHuntingAggregateArgs>,
        ): Prisma.PrismaPromise<GetJobHuntingAggregateType<T>>;

        /**
         * Group by JobHunting.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {JobHuntingGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends JobHuntingGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: JobHuntingGroupByArgs['orderBy'] }
                : { orderBy?: JobHuntingGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, JobHuntingGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetJobHuntingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the JobHunting model
         */
        readonly fields: JobHuntingFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for JobHunting.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__JobHuntingClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        company<T extends JobHunting$companyArgs<ExtArgs> = {}>(
            args?: Subset<T, JobHunting$companyArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        city<T extends JobHunting$cityArgs<ExtArgs> = {}>(
            args?: Subset<T, JobHunting$cityArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the JobHunting model
     */
    interface JobHuntingFieldRefs {
        readonly id: FieldRef<'JobHunting', 'String'>;
        readonly createdAt: FieldRef<'JobHunting', 'DateTime'>;
        readonly createdBy: FieldRef<'JobHunting', 'String'>;
        readonly updatedAt: FieldRef<'JobHunting', 'DateTime'>;
        readonly updatedBy: FieldRef<'JobHunting', 'String'>;
        readonly title: FieldRef<'JobHunting', 'String'>;
        readonly description: FieldRef<'JobHunting', 'String'>;
        readonly workExperience: FieldRef<'JobHunting', 'WorkExperience'>;
        readonly companyId: FieldRef<'JobHunting', 'String'>;
        readonly cityId: FieldRef<'JobHunting', 'String'>;
        readonly certificateRequirements: FieldRef<'JobHunting', 'String'>;
        readonly workScheduleHours: FieldRef<'JobHunting', 'WorkScheduleHours'>;
        readonly employmentType: FieldRef<'JobHunting', 'EmploymentType'>;
        readonly workMode: FieldRef<'JobHunting', 'WorkMode'>;
        readonly salary: FieldRef<'JobHunting', 'Int'>;
        readonly responsibilities: FieldRef<'JobHunting', 'String'>;
        readonly requirements: FieldRef<'JobHunting', 'String'>;
        readonly conditions: FieldRef<'JobHunting', 'String'>;
    }

    // Custom InputTypes
    /**
     * JobHunting findUnique
     */
    export type JobHuntingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter, which JobHunting to fetch.
         */
        where: JobHuntingWhereUniqueInput;
    };

    /**
     * JobHunting findUniqueOrThrow
     */
    export type JobHuntingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter, which JobHunting to fetch.
         */
        where: JobHuntingWhereUniqueInput;
    };

    /**
     * JobHunting findFirst
     */
    export type JobHuntingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter, which JobHunting to fetch.
         */
        where?: JobHuntingWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of JobHuntings to fetch.
         */
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for JobHuntings.
         */
        cursor?: JobHuntingWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` JobHuntings from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` JobHuntings.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of JobHuntings.
         */
        distinct?: JobHuntingScalarFieldEnum | JobHuntingScalarFieldEnum[];
    };

    /**
     * JobHunting findFirstOrThrow
     */
    export type JobHuntingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter, which JobHunting to fetch.
         */
        where?: JobHuntingWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of JobHuntings to fetch.
         */
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for JobHuntings.
         */
        cursor?: JobHuntingWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` JobHuntings from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` JobHuntings.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of JobHuntings.
         */
        distinct?: JobHuntingScalarFieldEnum | JobHuntingScalarFieldEnum[];
    };

    /**
     * JobHunting findMany
     */
    export type JobHuntingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter, which JobHuntings to fetch.
         */
        where?: JobHuntingWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of JobHuntings to fetch.
         */
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing JobHuntings.
         */
        cursor?: JobHuntingWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` JobHuntings from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` JobHuntings.
         */
        skip?: number;
        distinct?: JobHuntingScalarFieldEnum | JobHuntingScalarFieldEnum[];
    };

    /**
     * JobHunting create
     */
    export type JobHuntingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * The data needed to create a JobHunting.
         */
        data: XOR<JobHuntingCreateInput, JobHuntingUncheckedCreateInput>;
    };

    /**
     * JobHunting createMany
     */
    export type JobHuntingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many JobHuntings.
         */
        data: JobHuntingCreateManyInput | JobHuntingCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * JobHunting createManyAndReturn
     */
    export type JobHuntingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the JobHunting
             */
            select?: JobHuntingSelectCreateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the JobHunting
             */
            omit?: JobHuntingOmit<ExtArgs> | null;
            /**
             * The data used to create many JobHuntings.
             */
            data: JobHuntingCreateManyInput | JobHuntingCreateManyInput[];
            skipDuplicates?: boolean;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: JobHuntingIncludeCreateManyAndReturn<ExtArgs> | null;
        };

    /**
     * JobHunting update
     */
    export type JobHuntingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * The data needed to update a JobHunting.
         */
        data: XOR<JobHuntingUpdateInput, JobHuntingUncheckedUpdateInput>;
        /**
         * Choose, which JobHunting to update.
         */
        where: JobHuntingWhereUniqueInput;
    };

    /**
     * JobHunting updateMany
     */
    export type JobHuntingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update JobHuntings.
         */
        data: XOR<JobHuntingUpdateManyMutationInput, JobHuntingUncheckedUpdateManyInput>;
        /**
         * Filter which JobHuntings to update
         */
        where?: JobHuntingWhereInput;
        /**
         * Limit how many JobHuntings to update.
         */
        limit?: number;
    };

    /**
     * JobHunting updateManyAndReturn
     */
    export type JobHuntingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the JobHunting
             */
            select?: JobHuntingSelectUpdateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the JobHunting
             */
            omit?: JobHuntingOmit<ExtArgs> | null;
            /**
             * The data used to update JobHuntings.
             */
            data: XOR<JobHuntingUpdateManyMutationInput, JobHuntingUncheckedUpdateManyInput>;
            /**
             * Filter which JobHuntings to update
             */
            where?: JobHuntingWhereInput;
            /**
             * Limit how many JobHuntings to update.
             */
            limit?: number;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: JobHuntingIncludeUpdateManyAndReturn<ExtArgs> | null;
        };

    /**
     * JobHunting upsert
     */
    export type JobHuntingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * The filter to search for the JobHunting to update in case it exists.
         */
        where: JobHuntingWhereUniqueInput;
        /**
         * In case the JobHunting found by the `where` argument doesn't exist, create a new JobHunting with this data.
         */
        create: XOR<JobHuntingCreateInput, JobHuntingUncheckedCreateInput>;
        /**
         * In case the JobHunting was found with the provided `where` argument, update it with this data.
         */
        update: XOR<JobHuntingUpdateInput, JobHuntingUncheckedUpdateInput>;
    };

    /**
     * JobHunting delete
     */
    export type JobHuntingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        /**
         * Filter which JobHunting to delete.
         */
        where: JobHuntingWhereUniqueInput;
    };

    /**
     * JobHunting deleteMany
     */
    export type JobHuntingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which JobHuntings to delete
         */
        where?: JobHuntingWhereInput;
        /**
         * Limit how many JobHuntings to delete.
         */
        limit?: number;
    };

    /**
     * JobHunting.company
     */
    export type JobHunting$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        where?: CompanyWhereInput;
    };

    /**
     * JobHunting.city
     */
    export type JobHunting$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        where?: CityWhereInput;
    };

    /**
     * JobHunting without action
     */
    export type JobHuntingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
    };

    /**
     * Model Company
     */

    export type AggregateCompany = {
        _count: CompanyCountAggregateOutputType | null;
        _min: CompanyMinAggregateOutputType | null;
        _max: CompanyMaxAggregateOutputType | null;
    };

    export type CompanyMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        companyTitle: string | null;
        description: string | null;
        companyLogo: string | null;
    };

    export type CompanyMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        companyTitle: string | null;
        description: string | null;
        companyLogo: string | null;
    };

    export type CompanyCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        companyTitle: number;
        description: number;
        companyLogo: number;
        _all: number;
    };

    export type CompanyMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        companyTitle?: true;
        description?: true;
        companyLogo?: true;
    };

    export type CompanyMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        companyTitle?: true;
        description?: true;
        companyLogo?: true;
    };

    export type CompanyCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        companyTitle?: true;
        description?: true;
        companyLogo?: true;
        _all?: true;
    };

    export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Company to aggregate.
         */
        where?: CompanyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Companies to fetch.
         */
        orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CompanyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Companies from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Companies.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Companies
         **/
        _count?: true | CompanyCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CompanyMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CompanyMaxAggregateInputType;
    };

    export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCompany[P]>
            : GetScalarType<T[P], AggregateCompany[P]>;
    };

    export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CompanyWhereInput;
        orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[];
        by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum;
        having?: CompanyScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CompanyCountAggregateInputType | true;
        _min?: CompanyMinAggregateInputType;
        _max?: CompanyMaxAggregateInputType;
    };

    export type CompanyGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string;
        updatedAt: Date;
        updatedBy: string | null;
        companyTitle: string;
        description: string | null;
        companyLogo: string | null;
        _count: CompanyCountAggregateOutputType | null;
        _min: CompanyMinAggregateOutputType | null;
        _max: CompanyMaxAggregateOutputType | null;
    };

    type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CompanyGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CompanyGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CompanyGroupByOutputType[P]>
                    : GetScalarType<T[P], CompanyGroupByOutputType[P]>;
            }
        >
    >;

    export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                companyTitle?: boolean;
                description?: boolean;
                companyLogo?: boolean;
                jobHuntings?: boolean | Company$jobHuntingsArgs<ExtArgs>;
                _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['company']
        >;

    export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                companyTitle?: boolean;
                description?: boolean;
                companyLogo?: boolean;
            },
            ExtArgs['result']['company']
        >;

    export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                companyTitle?: boolean;
                description?: boolean;
                companyLogo?: boolean;
            },
            ExtArgs['result']['company']
        >;

    export type CompanySelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        companyTitle?: boolean;
        description?: boolean;
        companyLogo?: boolean;
    };

    export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'id' | 'createdAt' | 'createdBy' | 'updatedAt' | 'updatedBy' | 'companyTitle' | 'description' | 'companyLogo',
        ExtArgs['result']['company']
    >;
    export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        jobHuntings?: boolean | Company$jobHuntingsArgs<ExtArgs>;
        _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {};
    export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {};

    export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Company';
        objects: {
            jobHuntings: Prisma.$JobHuntingPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string;
                updatedAt: Date;
                updatedBy: string | null;
                companyTitle: string;
                description: string | null;
                companyLogo: string | null;
            },
            ExtArgs['result']['company']
        >;
        composites: {};
    };

    type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<
        Prisma.$CompanyPayload,
        S
    >;

    type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CompanyFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CompanyCountAggregateInputType | true;
    };

    export interface CompanyDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company']; meta: { name: 'Company' } };
        /**
         * Find zero or one Company that matches the filter.
         * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
         * @example
         * // Get one Company
         * const company = await prisma.company.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CompanyFindUniqueArgs>(
            args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Company that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
         * @example
         * // Get one Company
         * const company = await prisma.company.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Company that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyFindFirstArgs} args - Arguments to find a Company
         * @example
         * // Get one Company
         * const company = await prisma.company.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CompanyFindFirstArgs>(
            args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Company that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
         * @example
         * // Get one Company
         * const company = await prisma.company.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Companies that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Companies
         * const companies = await prisma.company.findMany()
         *
         * // Get first 10 Companies
         * const companies = await prisma.company.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
         *
         */
        findMany<T extends CompanyFindManyArgs>(
            args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a Company.
         * @param {CompanyCreateArgs} args - Arguments to create a Company.
         * @example
         * // Create one Company
         * const Company = await prisma.company.create({
         *   data: {
         *     // ... data to create a Company
         *   }
         * })
         *
         */
        create<T extends CompanyCreateArgs>(
            args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Companies.
         * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
         * @example
         * // Create many Companies
         * const company = await prisma.company.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CompanyCreateManyArgs>(
            args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Companies and returns the data saved in the database.
         * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
         * @example
         * // Create many Companies
         * const company = await prisma.company.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Companies and only return the `id`
         * const companyWithIdOnly = await prisma.company.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Company.
         * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
         * @example
         * // Delete one Company
         * const Company = await prisma.company.delete({
         *   where: {
         *     // ... filter to delete one Company
         *   }
         * })
         *
         */
        delete<T extends CompanyDeleteArgs>(
            args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Company.
         * @param {CompanyUpdateArgs} args - Arguments to update one Company.
         * @example
         * // Update one Company
         * const company = await prisma.company.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CompanyUpdateArgs>(
            args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Companies.
         * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
         * @example
         * // Delete a few Companies
         * const { count } = await prisma.company.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CompanyDeleteManyArgs>(
            args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Companies.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Companies
         * const company = await prisma.company.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CompanyUpdateManyArgs>(
            args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Companies and returns the data updated in the database.
         * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
         * @example
         * // Update many Companies
         * const company = await prisma.company.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Companies and only return the `id`
         * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Company.
         * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
         * @example
         * // Update or create a Company
         * const company = await prisma.company.upsert({
         *   create: {
         *     // ... data to create a Company
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Company we want to update
         *   }
         * })
         */
        upsert<T extends CompanyUpsertArgs>(
            args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>,
        ): Prisma__CompanyClient<
            $Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Companies.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
         * @example
         * // Count the number of Companies
         * const count = await prisma.company.count({
         *   where: {
         *     // ... the filter for the Companies we want to count
         *   }
         * })
         **/
        count<T extends CompanyCountArgs>(
            args?: Subset<T, CompanyCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CompanyCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Company.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CompanyAggregateArgs>(
            args: Subset<T, CompanyAggregateArgs>,
        ): Prisma.PrismaPromise<GetCompanyAggregateType<T>>;

        /**
         * Group by Company.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CompanyGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CompanyGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CompanyGroupByArgs['orderBy'] }
                : { orderBy?: CompanyGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Company model
         */
        readonly fields: CompanyFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Company.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CompanyClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        jobHuntings<T extends Company$jobHuntingsArgs<ExtArgs> = {}>(
            args?: Subset<T, Company$jobHuntingsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$JobHuntingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Company model
     */
    interface CompanyFieldRefs {
        readonly id: FieldRef<'Company', 'String'>;
        readonly createdAt: FieldRef<'Company', 'DateTime'>;
        readonly createdBy: FieldRef<'Company', 'String'>;
        readonly updatedAt: FieldRef<'Company', 'DateTime'>;
        readonly updatedBy: FieldRef<'Company', 'String'>;
        readonly companyTitle: FieldRef<'Company', 'String'>;
        readonly description: FieldRef<'Company', 'String'>;
        readonly companyLogo: FieldRef<'Company', 'String'>;
    }

    // Custom InputTypes
    /**
     * Company findUnique
     */
    export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter, which Company to fetch.
         */
        where: CompanyWhereUniqueInput;
    };

    /**
     * Company findUniqueOrThrow
     */
    export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter, which Company to fetch.
         */
        where: CompanyWhereUniqueInput;
    };

    /**
     * Company findFirst
     */
    export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter, which Company to fetch.
         */
        where?: CompanyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Companies to fetch.
         */
        orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Companies.
         */
        cursor?: CompanyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Companies from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Companies.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Companies.
         */
        distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
    };

    /**
     * Company findFirstOrThrow
     */
    export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter, which Company to fetch.
         */
        where?: CompanyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Companies to fetch.
         */
        orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Companies.
         */
        cursor?: CompanyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Companies from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Companies.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Companies.
         */
        distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
    };

    /**
     * Company findMany
     */
    export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter, which Companies to fetch.
         */
        where?: CompanyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Companies to fetch.
         */
        orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Companies.
         */
        cursor?: CompanyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Companies from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Companies.
         */
        skip?: number;
        distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[];
    };

    /**
     * Company create
     */
    export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * The data needed to create a Company.
         */
        data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
    };

    /**
     * Company createMany
     */
    export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Companies.
         */
        data: CompanyCreateManyInput | CompanyCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Company createManyAndReturn
     */
    export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * The data used to create many Companies.
         */
        data: CompanyCreateManyInput | CompanyCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Company update
     */
    export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * The data needed to update a Company.
         */
        data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
        /**
         * Choose, which Company to update.
         */
        where: CompanyWhereUniqueInput;
    };

    /**
     * Company updateMany
     */
    export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Companies.
         */
        data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
        /**
         * Filter which Companies to update
         */
        where?: CompanyWhereInput;
        /**
         * Limit how many Companies to update.
         */
        limit?: number;
    };

    /**
     * Company updateManyAndReturn
     */
    export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * The data used to update Companies.
         */
        data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>;
        /**
         * Filter which Companies to update
         */
        where?: CompanyWhereInput;
        /**
         * Limit how many Companies to update.
         */
        limit?: number;
    };

    /**
     * Company upsert
     */
    export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * The filter to search for the Company to update in case it exists.
         */
        where: CompanyWhereUniqueInput;
        /**
         * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
         */
        create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>;
        /**
         * In case the Company was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>;
    };

    /**
     * Company delete
     */
    export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
        /**
         * Filter which Company to delete.
         */
        where: CompanyWhereUniqueInput;
    };

    /**
     * Company deleteMany
     */
    export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Companies to delete
         */
        where?: CompanyWhereInput;
        /**
         * Limit how many Companies to delete.
         */
        limit?: number;
    };

    /**
     * Company.jobHuntings
     */
    export type Company$jobHuntingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the JobHunting
         */
        select?: JobHuntingSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the JobHunting
         */
        omit?: JobHuntingOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: JobHuntingInclude<ExtArgs> | null;
        where?: JobHuntingWhereInput;
        orderBy?: JobHuntingOrderByWithRelationInput | JobHuntingOrderByWithRelationInput[];
        cursor?: JobHuntingWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: JobHuntingScalarFieldEnum | JobHuntingScalarFieldEnum[];
    };

    /**
     * Company without action
     */
    export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Company
         */
        select?: CompanySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Company
         */
        omit?: CompanyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CompanyInclude<ExtArgs> | null;
    };

    /**
     * Model CV
     */

    export type AggregateCV = {
        _count: CVCountAggregateOutputType | null;
        _avg: CVAvgAggregateOutputType | null;
        _sum: CVSumAggregateOutputType | null;
        _min: CVMinAggregateOutputType | null;
        _max: CVMaxAggregateOutputType | null;
    };

    export type CVAvgAggregateOutputType = {
        graduationYear: number | null;
    };

    export type CVSumAggregateOutputType = {
        graduationYear: number | null;
    };

    export type CVMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        updatedAt: Date | null;
        studentId: string | null;
        description: string | null;
        cityId: string | null;
        degree: $Enums.Degree | null;
        universityTitle: string | null;
        universityMajor: string | null;
        graduationYear: number | null;
        companyName: string | null;
        position: string | null;
        responsibilities: string | null;
        startDate: Date | null;
        endDate: Date | null;
    };

    export type CVMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        updatedAt: Date | null;
        studentId: string | null;
        description: string | null;
        cityId: string | null;
        degree: $Enums.Degree | null;
        universityTitle: string | null;
        universityMajor: string | null;
        graduationYear: number | null;
        companyName: string | null;
        position: string | null;
        responsibilities: string | null;
        startDate: Date | null;
        endDate: Date | null;
    };

    export type CVCountAggregateOutputType = {
        id: number;
        createdAt: number;
        updatedAt: number;
        studentId: number;
        description: number;
        cityId: number;
        degree: number;
        universityTitle: number;
        universityMajor: number;
        graduationYear: number;
        companyName: number;
        position: number;
        responsibilities: number;
        startDate: number;
        endDate: number;
        _all: number;
    };

    export type CVAvgAggregateInputType = {
        graduationYear?: true;
    };

    export type CVSumAggregateInputType = {
        graduationYear?: true;
    };

    export type CVMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        updatedAt?: true;
        studentId?: true;
        description?: true;
        cityId?: true;
        degree?: true;
        universityTitle?: true;
        universityMajor?: true;
        graduationYear?: true;
        companyName?: true;
        position?: true;
        responsibilities?: true;
        startDate?: true;
        endDate?: true;
    };

    export type CVMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        updatedAt?: true;
        studentId?: true;
        description?: true;
        cityId?: true;
        degree?: true;
        universityTitle?: true;
        universityMajor?: true;
        graduationYear?: true;
        companyName?: true;
        position?: true;
        responsibilities?: true;
        startDate?: true;
        endDate?: true;
    };

    export type CVCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        updatedAt?: true;
        studentId?: true;
        description?: true;
        cityId?: true;
        degree?: true;
        universityTitle?: true;
        universityMajor?: true;
        graduationYear?: true;
        companyName?: true;
        position?: true;
        responsibilities?: true;
        startDate?: true;
        endDate?: true;
        _all?: true;
    };

    export type CVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CV to aggregate.
         */
        where?: CVWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CVS to fetch.
         */
        orderBy?: CVOrderByWithRelationInput | CVOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CVWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CVS from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CVS.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned CVS
         **/
        _count?: true | CVCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: CVAvgAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: CVSumAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CVMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CVMaxAggregateInputType;
    };

    export type GetCVAggregateType<T extends CVAggregateArgs> = {
        [P in keyof T & keyof AggregateCV]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCV[P]>
            : GetScalarType<T[P], AggregateCV[P]>;
    };

    export type CVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CVWhereInput;
        orderBy?: CVOrderByWithAggregationInput | CVOrderByWithAggregationInput[];
        by: CVScalarFieldEnum[] | CVScalarFieldEnum;
        having?: CVScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CVCountAggregateInputType | true;
        _avg?: CVAvgAggregateInputType;
        _sum?: CVSumAggregateInputType;
        _min?: CVMinAggregateInputType;
        _max?: CVMaxAggregateInputType;
    };

    export type CVGroupByOutputType = {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        studentId: string;
        description: string | null;
        cityId: string;
        degree: $Enums.Degree | null;
        universityTitle: string | null;
        universityMajor: string | null;
        graduationYear: number | null;
        companyName: string | null;
        position: string | null;
        responsibilities: string | null;
        startDate: Date | null;
        endDate: Date | null;
        _count: CVCountAggregateOutputType | null;
        _avg: CVAvgAggregateOutputType | null;
        _sum: CVSumAggregateOutputType | null;
        _min: CVMinAggregateOutputType | null;
        _max: CVMaxAggregateOutputType | null;
    };

    type GetCVGroupByPayload<T extends CVGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CVGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CVGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CVGroupByOutputType[P]>
                    : GetScalarType<T[P], CVGroupByOutputType[P]>;
            }
        >
    >;

    export type CVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            studentId?: boolean;
            description?: boolean;
            cityId?: boolean;
            degree?: boolean;
            universityTitle?: boolean;
            universityMajor?: boolean;
            graduationYear?: boolean;
            companyName?: boolean;
            position?: boolean;
            responsibilities?: boolean;
            startDate?: boolean;
            endDate?: boolean;
            city?: boolean | CityDefaultArgs<ExtArgs>;
            skills?: boolean | CV$skillsArgs<ExtArgs>;
            tools?: boolean | CV$toolsArgs<ExtArgs>;
            _count?: boolean | CVCountOutputTypeDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['cV']
    >;

    export type CVSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                updatedAt?: boolean;
                studentId?: boolean;
                description?: boolean;
                cityId?: boolean;
                degree?: boolean;
                universityTitle?: boolean;
                universityMajor?: boolean;
                graduationYear?: boolean;
                companyName?: boolean;
                position?: boolean;
                responsibilities?: boolean;
                startDate?: boolean;
                endDate?: boolean;
                city?: boolean | CityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cV']
        >;

    export type CVSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                updatedAt?: boolean;
                studentId?: boolean;
                description?: boolean;
                cityId?: boolean;
                degree?: boolean;
                universityTitle?: boolean;
                universityMajor?: boolean;
                graduationYear?: boolean;
                companyName?: boolean;
                position?: boolean;
                responsibilities?: boolean;
                startDate?: boolean;
                endDate?: boolean;
                city?: boolean | CityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cV']
        >;

    export type CVSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        studentId?: boolean;
        description?: boolean;
        cityId?: boolean;
        degree?: boolean;
        universityTitle?: boolean;
        universityMajor?: boolean;
        graduationYear?: boolean;
        companyName?: boolean;
        position?: boolean;
        responsibilities?: boolean;
        startDate?: boolean;
        endDate?: boolean;
    };

    export type CVOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        | 'id'
        | 'createdAt'
        | 'updatedAt'
        | 'studentId'
        | 'description'
        | 'cityId'
        | 'degree'
        | 'universityTitle'
        | 'universityMajor'
        | 'graduationYear'
        | 'companyName'
        | 'position'
        | 'responsibilities'
        | 'startDate'
        | 'endDate',
        ExtArgs['result']['cV']
    >;
    export type CVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
        skills?: boolean | CV$skillsArgs<ExtArgs>;
        tools?: boolean | CV$toolsArgs<ExtArgs>;
        _count?: boolean | CVCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type CVIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
    };
    export type CVIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        city?: boolean | CityDefaultArgs<ExtArgs>;
    };

    export type $CVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'CV';
        objects: {
            city: Prisma.$CityPayload<ExtArgs>;
            skills: Prisma.$CvSkillPayload<ExtArgs>[];
            tools: Prisma.$CvToolPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                updatedAt: Date;
                studentId: string;
                description: string | null;
                cityId: string;
                degree: $Enums.Degree | null;
                universityTitle: string | null;
                universityMajor: string | null;
                graduationYear: number | null;
                companyName: string | null;
                position: string | null;
                responsibilities: string | null;
                startDate: Date | null;
                endDate: Date | null;
            },
            ExtArgs['result']['cV']
        >;
        composites: {};
    };

    type CVGetPayload<S extends boolean | null | undefined | CVDefaultArgs> = $Result.GetResult<Prisma.$CVPayload, S>;

    type CVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CVFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CVCountAggregateInputType | true;
    };

    export interface CVDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CV']; meta: { name: 'CV' } };
        /**
         * Find zero or one CV that matches the filter.
         * @param {CVFindUniqueArgs} args - Arguments to find a CV
         * @example
         * // Get one CV
         * const cV = await prisma.cV.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CVFindUniqueArgs>(
            args: SelectSubset<T, CVFindUniqueArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one CV that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CVFindUniqueOrThrowArgs} args - Arguments to find a CV
         * @example
         * // Get one CV
         * const cV = await prisma.cV.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CVFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CVFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CV that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVFindFirstArgs} args - Arguments to find a CV
         * @example
         * // Get one CV
         * const cV = await prisma.cV.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CVFindFirstArgs>(
            args?: SelectSubset<T, CVFindFirstArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CV that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVFindFirstOrThrowArgs} args - Arguments to find a CV
         * @example
         * // Get one CV
         * const cV = await prisma.cV.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CVFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CVFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more CVS that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all CVS
         * const cVS = await prisma.cV.findMany()
         *
         * // Get first 10 CVS
         * const cVS = await prisma.cV.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const cVWithIdOnly = await prisma.cV.findMany({ select: { id: true } })
         *
         */
        findMany<T extends CVFindManyArgs>(
            args?: SelectSubset<T, CVFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a CV.
         * @param {CVCreateArgs} args - Arguments to create a CV.
         * @example
         * // Create one CV
         * const CV = await prisma.cV.create({
         *   data: {
         *     // ... data to create a CV
         *   }
         * })
         *
         */
        create<T extends CVCreateArgs>(
            args: SelectSubset<T, CVCreateArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many CVS.
         * @param {CVCreateManyArgs} args - Arguments to create many CVS.
         * @example
         * // Create many CVS
         * const cV = await prisma.cV.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CVCreateManyArgs>(
            args?: SelectSubset<T, CVCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many CVS and returns the data saved in the database.
         * @param {CVCreateManyAndReturnArgs} args - Arguments to create many CVS.
         * @example
         * // Create many CVS
         * const cV = await prisma.cV.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many CVS and only return the `id`
         * const cVWithIdOnly = await prisma.cV.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CVCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CVCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a CV.
         * @param {CVDeleteArgs} args - Arguments to delete one CV.
         * @example
         * // Delete one CV
         * const CV = await prisma.cV.delete({
         *   where: {
         *     // ... filter to delete one CV
         *   }
         * })
         *
         */
        delete<T extends CVDeleteArgs>(
            args: SelectSubset<T, CVDeleteArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one CV.
         * @param {CVUpdateArgs} args - Arguments to update one CV.
         * @example
         * // Update one CV
         * const cV = await prisma.cV.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CVUpdateArgs>(
            args: SelectSubset<T, CVUpdateArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more CVS.
         * @param {CVDeleteManyArgs} args - Arguments to filter CVS to delete.
         * @example
         * // Delete a few CVS
         * const { count } = await prisma.cV.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CVDeleteManyArgs>(
            args?: SelectSubset<T, CVDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CVS.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many CVS
         * const cV = await prisma.cV.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CVUpdateManyArgs>(
            args: SelectSubset<T, CVUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CVS and returns the data updated in the database.
         * @param {CVUpdateManyAndReturnArgs} args - Arguments to update many CVS.
         * @example
         * // Update many CVS
         * const cV = await prisma.cV.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more CVS and only return the `id`
         * const cVWithIdOnly = await prisma.cV.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CVUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CVUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one CV.
         * @param {CVUpsertArgs} args - Arguments to update or create a CV.
         * @example
         * // Update or create a CV
         * const cV = await prisma.cV.upsert({
         *   create: {
         *     // ... data to create a CV
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the CV we want to update
         *   }
         * })
         */
        upsert<T extends CVUpsertArgs>(
            args: SelectSubset<T, CVUpsertArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of CVS.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVCountArgs} args - Arguments to filter CVS to count.
         * @example
         * // Count the number of CVS
         * const count = await prisma.cV.count({
         *   where: {
         *     // ... the filter for the CVS we want to count
         *   }
         * })
         **/
        count<T extends CVCountArgs>(
            args?: Subset<T, CVCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CVCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a CV.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CVAggregateArgs>(
            args: Subset<T, CVAggregateArgs>,
        ): Prisma.PrismaPromise<GetCVAggregateType<T>>;

        /**
         * Group by CV.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CVGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CVGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CVGroupByArgs['orderBy'] }
                : { orderBy?: CVGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CVGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the CV model
         */
        readonly fields: CVFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for CV.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CVClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        city<T extends CityDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, CityDefaultArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        skills<T extends CV$skillsArgs<ExtArgs> = {}>(
            args?: Subset<T, CV$skillsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        tools<T extends CV$toolsArgs<ExtArgs> = {}>(
            args?: Subset<T, CV$toolsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the CV model
     */
    interface CVFieldRefs {
        readonly id: FieldRef<'CV', 'String'>;
        readonly createdAt: FieldRef<'CV', 'DateTime'>;
        readonly updatedAt: FieldRef<'CV', 'DateTime'>;
        readonly studentId: FieldRef<'CV', 'String'>;
        readonly description: FieldRef<'CV', 'String'>;
        readonly cityId: FieldRef<'CV', 'String'>;
        readonly degree: FieldRef<'CV', 'Degree'>;
        readonly universityTitle: FieldRef<'CV', 'String'>;
        readonly universityMajor: FieldRef<'CV', 'String'>;
        readonly graduationYear: FieldRef<'CV', 'Int'>;
        readonly companyName: FieldRef<'CV', 'String'>;
        readonly position: FieldRef<'CV', 'String'>;
        readonly responsibilities: FieldRef<'CV', 'String'>;
        readonly startDate: FieldRef<'CV', 'DateTime'>;
        readonly endDate: FieldRef<'CV', 'DateTime'>;
    }

    // Custom InputTypes
    /**
     * CV findUnique
     */
    export type CVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter, which CV to fetch.
         */
        where: CVWhereUniqueInput;
    };

    /**
     * CV findUniqueOrThrow
     */
    export type CVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter, which CV to fetch.
         */
        where: CVWhereUniqueInput;
    };

    /**
     * CV findFirst
     */
    export type CVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter, which CV to fetch.
         */
        where?: CVWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CVS to fetch.
         */
        orderBy?: CVOrderByWithRelationInput | CVOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CVS.
         */
        cursor?: CVWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CVS from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CVS.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CVS.
         */
        distinct?: CVScalarFieldEnum | CVScalarFieldEnum[];
    };

    /**
     * CV findFirstOrThrow
     */
    export type CVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter, which CV to fetch.
         */
        where?: CVWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CVS to fetch.
         */
        orderBy?: CVOrderByWithRelationInput | CVOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CVS.
         */
        cursor?: CVWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CVS from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CVS.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CVS.
         */
        distinct?: CVScalarFieldEnum | CVScalarFieldEnum[];
    };

    /**
     * CV findMany
     */
    export type CVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter, which CVS to fetch.
         */
        where?: CVWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CVS to fetch.
         */
        orderBy?: CVOrderByWithRelationInput | CVOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing CVS.
         */
        cursor?: CVWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CVS from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CVS.
         */
        skip?: number;
        distinct?: CVScalarFieldEnum | CVScalarFieldEnum[];
    };

    /**
     * CV create
     */
    export type CVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * The data needed to create a CV.
         */
        data: XOR<CVCreateInput, CVUncheckedCreateInput>;
    };

    /**
     * CV createMany
     */
    export type CVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many CVS.
         */
        data: CVCreateManyInput | CVCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * CV createManyAndReturn
     */
    export type CVCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * The data used to create many CVS.
         */
        data: CVCreateManyInput | CVCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CV update
     */
    export type CVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * The data needed to update a CV.
         */
        data: XOR<CVUpdateInput, CVUncheckedUpdateInput>;
        /**
         * Choose, which CV to update.
         */
        where: CVWhereUniqueInput;
    };

    /**
     * CV updateMany
     */
    export type CVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update CVS.
         */
        data: XOR<CVUpdateManyMutationInput, CVUncheckedUpdateManyInput>;
        /**
         * Filter which CVS to update
         */
        where?: CVWhereInput;
        /**
         * Limit how many CVS to update.
         */
        limit?: number;
    };

    /**
     * CV updateManyAndReturn
     */
    export type CVUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * The data used to update CVS.
         */
        data: XOR<CVUpdateManyMutationInput, CVUncheckedUpdateManyInput>;
        /**
         * Filter which CVS to update
         */
        where?: CVWhereInput;
        /**
         * Limit how many CVS to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CV upsert
     */
    export type CVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * The filter to search for the CV to update in case it exists.
         */
        where: CVWhereUniqueInput;
        /**
         * In case the CV found by the `where` argument doesn't exist, create a new CV with this data.
         */
        create: XOR<CVCreateInput, CVUncheckedCreateInput>;
        /**
         * In case the CV was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CVUpdateInput, CVUncheckedUpdateInput>;
    };

    /**
     * CV delete
     */
    export type CVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
        /**
         * Filter which CV to delete.
         */
        where: CVWhereUniqueInput;
    };

    /**
     * CV deleteMany
     */
    export type CVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CVS to delete
         */
        where?: CVWhereInput;
        /**
         * Limit how many CVS to delete.
         */
        limit?: number;
    };

    /**
     * CV.skills
     */
    export type CV$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        where?: CvSkillWhereInput;
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        cursor?: CvSkillWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: CvSkillScalarFieldEnum | CvSkillScalarFieldEnum[];
    };

    /**
     * CV.tools
     */
    export type CV$toolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        where?: CvToolWhereInput;
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        cursor?: CvToolWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: CvToolScalarFieldEnum | CvToolScalarFieldEnum[];
    };

    /**
     * CV without action
     */
    export type CVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CV
         */
        select?: CVSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CV
         */
        omit?: CVOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CVInclude<ExtArgs> | null;
    };

    /**
     * Model Skill
     */

    export type AggregateSkill = {
        _count: SkillCountAggregateOutputType | null;
        _min: SkillMinAggregateOutputType | null;
        _max: SkillMaxAggregateOutputType | null;
    };

    export type SkillMinAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type SkillMaxAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type SkillCountAggregateOutputType = {
        id: number;
        name: number;
        _all: number;
    };

    export type SkillMinAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type SkillMaxAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type SkillCountAggregateInputType = {
        id?: true;
        name?: true;
        _all?: true;
    };

    export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Skill to aggregate.
         */
        where?: SkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Skills to fetch.
         */
        orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: SkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Skills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Skills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Skills
         **/
        _count?: true | SkillCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SkillMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SkillMaxAggregateInputType;
    };

    export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSkill[P]>
            : GetScalarType<T[P], AggregateSkill[P]>;
    };

    export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: SkillWhereInput;
        orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[];
        by: SkillScalarFieldEnum[] | SkillScalarFieldEnum;
        having?: SkillScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: SkillCountAggregateInputType | true;
        _min?: SkillMinAggregateInputType;
        _max?: SkillMaxAggregateInputType;
    };

    export type SkillGroupByOutputType = {
        id: string;
        name: string;
        _count: SkillCountAggregateOutputType | null;
        _min: SkillMinAggregateOutputType | null;
        _max: SkillMaxAggregateOutputType | null;
    };

    type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<SkillGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SkillGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SkillGroupByOutputType[P]>
                    : GetScalarType<T[P], SkillGroupByOutputType[P]>;
            }
        >
    >;

    export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
        {
            id?: boolean;
            name?: boolean;
            cvs?: boolean | Skill$cvsArgs<ExtArgs>;
            _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['skill']
    >;

    export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['skill']
        >;

    export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['skill']
        >;

    export type SkillSelectScalar = {
        id?: boolean;
        name?: boolean;
    };

    export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'id' | 'name',
        ExtArgs['result']['skill']
    >;
    export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cvs?: boolean | Skill$cvsArgs<ExtArgs>;
        _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {};
    export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {};

    export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Skill';
        objects: {
            cvs: Prisma.$CvSkillPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                name: string;
            },
            ExtArgs['result']['skill']
        >;
        composites: {};
    };

    type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<
        Prisma.$SkillPayload,
        S
    >;

    type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        SkillFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: SkillCountAggregateInputType | true;
    };

    export interface SkillDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill']; meta: { name: 'Skill' } };
        /**
         * Find zero or one Skill that matches the filter.
         * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
         * @example
         * // Get one Skill
         * const skill = await prisma.skill.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends SkillFindUniqueArgs>(
            args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
         * @example
         * // Get one Skill
         * const skill = await prisma.skill.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(
            args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Skill that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillFindFirstArgs} args - Arguments to find a Skill
         * @example
         * // Get one Skill
         * const skill = await prisma.skill.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends SkillFindFirstArgs>(
            args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Skill that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
         * @example
         * // Get one Skill
         * const skill = await prisma.skill.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Skills that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Skills
         * const skills = await prisma.skill.findMany()
         *
         * // Get first 10 Skills
         * const skills = await prisma.skill.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
         *
         */
        findMany<T extends SkillFindManyArgs>(
            args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a Skill.
         * @param {SkillCreateArgs} args - Arguments to create a Skill.
         * @example
         * // Create one Skill
         * const Skill = await prisma.skill.create({
         *   data: {
         *     // ... data to create a Skill
         *   }
         * })
         *
         */
        create<T extends SkillCreateArgs>(
            args: SelectSubset<T, SkillCreateArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Skills.
         * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
         * @example
         * // Create many Skills
         * const skill = await prisma.skill.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends SkillCreateManyArgs>(
            args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Skills and returns the data saved in the database.
         * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
         * @example
         * // Create many Skills
         * const skill = await prisma.skill.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Skills and only return the `id`
         * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(
            args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Skill.
         * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
         * @example
         * // Delete one Skill
         * const Skill = await prisma.skill.delete({
         *   where: {
         *     // ... filter to delete one Skill
         *   }
         * })
         *
         */
        delete<T extends SkillDeleteArgs>(
            args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Skill.
         * @param {SkillUpdateArgs} args - Arguments to update one Skill.
         * @example
         * // Update one Skill
         * const skill = await prisma.skill.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends SkillUpdateArgs>(
            args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Skills.
         * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
         * @example
         * // Delete a few Skills
         * const { count } = await prisma.skill.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends SkillDeleteManyArgs>(
            args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Skills.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Skills
         * const skill = await prisma.skill.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends SkillUpdateManyArgs>(
            args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Skills and returns the data updated in the database.
         * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
         * @example
         * // Update many Skills
         * const skill = await prisma.skill.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Skills and only return the `id`
         * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(
            args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Skill.
         * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
         * @example
         * // Update or create a Skill
         * const skill = await prisma.skill.upsert({
         *   create: {
         *     // ... data to create a Skill
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Skill we want to update
         *   }
         * })
         */
        upsert<T extends SkillUpsertArgs>(
            args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Skills.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillCountArgs} args - Arguments to filter Skills to count.
         * @example
         * // Count the number of Skills
         * const count = await prisma.skill.count({
         *   where: {
         *     // ... the filter for the Skills we want to count
         *   }
         * })
         **/
        count<T extends SkillCountArgs>(
            args?: Subset<T, SkillCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SkillCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Skill.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SkillAggregateArgs>(
            args: Subset<T, SkillAggregateArgs>,
        ): Prisma.PrismaPromise<GetSkillAggregateType<T>>;

        /**
         * Group by Skill.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SkillGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SkillGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SkillGroupByArgs['orderBy'] }
                : { orderBy?: SkillGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Skill model
         */
        readonly fields: SkillFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Skill.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__SkillClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        cvs<T extends Skill$cvsArgs<ExtArgs> = {}>(
            args?: Subset<T, Skill$cvsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Skill model
     */
    interface SkillFieldRefs {
        readonly id: FieldRef<'Skill', 'String'>;
        readonly name: FieldRef<'Skill', 'String'>;
    }

    // Custom InputTypes
    /**
     * Skill findUnique
     */
    export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter, which Skill to fetch.
         */
        where: SkillWhereUniqueInput;
    };

    /**
     * Skill findUniqueOrThrow
     */
    export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter, which Skill to fetch.
         */
        where: SkillWhereUniqueInput;
    };

    /**
     * Skill findFirst
     */
    export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter, which Skill to fetch.
         */
        where?: SkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Skills to fetch.
         */
        orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Skills.
         */
        cursor?: SkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Skills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Skills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Skills.
         */
        distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[];
    };

    /**
     * Skill findFirstOrThrow
     */
    export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter, which Skill to fetch.
         */
        where?: SkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Skills to fetch.
         */
        orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Skills.
         */
        cursor?: SkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Skills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Skills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Skills.
         */
        distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[];
    };

    /**
     * Skill findMany
     */
    export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter, which Skills to fetch.
         */
        where?: SkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Skills to fetch.
         */
        orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Skills.
         */
        cursor?: SkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Skills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Skills.
         */
        skip?: number;
        distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[];
    };

    /**
     * Skill create
     */
    export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * The data needed to create a Skill.
         */
        data: XOR<SkillCreateInput, SkillUncheckedCreateInput>;
    };

    /**
     * Skill createMany
     */
    export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Skills.
         */
        data: SkillCreateManyInput | SkillCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Skill createManyAndReturn
     */
    export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * The data used to create many Skills.
         */
        data: SkillCreateManyInput | SkillCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Skill update
     */
    export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * The data needed to update a Skill.
         */
        data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>;
        /**
         * Choose, which Skill to update.
         */
        where: SkillWhereUniqueInput;
    };

    /**
     * Skill updateMany
     */
    export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Skills.
         */
        data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>;
        /**
         * Filter which Skills to update
         */
        where?: SkillWhereInput;
        /**
         * Limit how many Skills to update.
         */
        limit?: number;
    };

    /**
     * Skill updateManyAndReturn
     */
    export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * The data used to update Skills.
         */
        data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>;
        /**
         * Filter which Skills to update
         */
        where?: SkillWhereInput;
        /**
         * Limit how many Skills to update.
         */
        limit?: number;
    };

    /**
     * Skill upsert
     */
    export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * The filter to search for the Skill to update in case it exists.
         */
        where: SkillWhereUniqueInput;
        /**
         * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
         */
        create: XOR<SkillCreateInput, SkillUncheckedCreateInput>;
        /**
         * In case the Skill was found with the provided `where` argument, update it with this data.
         */
        update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>;
    };

    /**
     * Skill delete
     */
    export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
        /**
         * Filter which Skill to delete.
         */
        where: SkillWhereUniqueInput;
    };

    /**
     * Skill deleteMany
     */
    export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Skills to delete
         */
        where?: SkillWhereInput;
        /**
         * Limit how many Skills to delete.
         */
        limit?: number;
    };

    /**
     * Skill.cvs
     */
    export type Skill$cvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        where?: CvSkillWhereInput;
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        cursor?: CvSkillWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: CvSkillScalarFieldEnum | CvSkillScalarFieldEnum[];
    };

    /**
     * Skill without action
     */
    export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Skill
         */
        select?: SkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Skill
         */
        omit?: SkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: SkillInclude<ExtArgs> | null;
    };

    /**
     * Model Tool
     */

    export type AggregateTool = {
        _count: ToolCountAggregateOutputType | null;
        _min: ToolMinAggregateOutputType | null;
        _max: ToolMaxAggregateOutputType | null;
    };

    export type ToolMinAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type ToolMaxAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type ToolCountAggregateOutputType = {
        id: number;
        name: number;
        _all: number;
    };

    export type ToolMinAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type ToolMaxAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type ToolCountAggregateInputType = {
        id?: true;
        name?: true;
        _all?: true;
    };

    export type ToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Tool to aggregate.
         */
        where?: ToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tools to fetch.
         */
        orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: ToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Tools
         **/
        _count?: true | ToolCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: ToolMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: ToolMaxAggregateInputType;
    };

    export type GetToolAggregateType<T extends ToolAggregateArgs> = {
        [P in keyof T & keyof AggregateTool]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateTool[P]>
            : GetScalarType<T[P], AggregateTool[P]>;
    };

    export type ToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: ToolWhereInput;
        orderBy?: ToolOrderByWithAggregationInput | ToolOrderByWithAggregationInput[];
        by: ToolScalarFieldEnum[] | ToolScalarFieldEnum;
        having?: ToolScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: ToolCountAggregateInputType | true;
        _min?: ToolMinAggregateInputType;
        _max?: ToolMaxAggregateInputType;
    };

    export type ToolGroupByOutputType = {
        id: string;
        name: string;
        _count: ToolCountAggregateOutputType | null;
        _min: ToolMinAggregateOutputType | null;
        _max: ToolMaxAggregateOutputType | null;
    };

    type GetToolGroupByPayload<T extends ToolGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<ToolGroupByOutputType, T['by']> & {
                [P in keyof T & keyof ToolGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], ToolGroupByOutputType[P]>
                    : GetScalarType<T[P], ToolGroupByOutputType[P]>;
            }
        >
    >;

    export type ToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
        {
            id?: boolean;
            name?: boolean;
            cvs?: boolean | Tool$cvsArgs<ExtArgs>;
            _count?: boolean | ToolCountOutputTypeDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['tool']
    >;

    export type ToolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['tool']
        >;

    export type ToolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['tool']
        >;

    export type ToolSelectScalar = {
        id?: boolean;
        name?: boolean;
    };

    export type ToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'id' | 'name',
        ExtArgs['result']['tool']
    >;
    export type ToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cvs?: boolean | Tool$cvsArgs<ExtArgs>;
        _count?: boolean | ToolCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type ToolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
    export type ToolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

    export type $ToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Tool';
        objects: {
            cvs: Prisma.$CvToolPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                name: string;
            },
            ExtArgs['result']['tool']
        >;
        composites: {};
    };

    type ToolGetPayload<S extends boolean | null | undefined | ToolDefaultArgs> = $Result.GetResult<
        Prisma.$ToolPayload,
        S
    >;

    type ToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        ToolFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: ToolCountAggregateInputType | true;
    };

    export interface ToolDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tool']; meta: { name: 'Tool' } };
        /**
         * Find zero or one Tool that matches the filter.
         * @param {ToolFindUniqueArgs} args - Arguments to find a Tool
         * @example
         * // Get one Tool
         * const tool = await prisma.tool.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends ToolFindUniqueArgs>(
            args: SelectSubset<T, ToolFindUniqueArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Tool that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {ToolFindUniqueOrThrowArgs} args - Arguments to find a Tool
         * @example
         * // Get one Tool
         * const tool = await prisma.tool.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends ToolFindUniqueOrThrowArgs>(
            args: SelectSubset<T, ToolFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Tool that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolFindFirstArgs} args - Arguments to find a Tool
         * @example
         * // Get one Tool
         * const tool = await prisma.tool.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends ToolFindFirstArgs>(
            args?: SelectSubset<T, ToolFindFirstArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Tool that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolFindFirstOrThrowArgs} args - Arguments to find a Tool
         * @example
         * // Get one Tool
         * const tool = await prisma.tool.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends ToolFindFirstOrThrowArgs>(
            args?: SelectSubset<T, ToolFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Tools that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Tools
         * const tools = await prisma.tool.findMany()
         *
         * // Get first 10 Tools
         * const tools = await prisma.tool.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const toolWithIdOnly = await prisma.tool.findMany({ select: { id: true } })
         *
         */
        findMany<T extends ToolFindManyArgs>(
            args?: SelectSubset<T, ToolFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a Tool.
         * @param {ToolCreateArgs} args - Arguments to create a Tool.
         * @example
         * // Create one Tool
         * const Tool = await prisma.tool.create({
         *   data: {
         *     // ... data to create a Tool
         *   }
         * })
         *
         */
        create<T extends ToolCreateArgs>(
            args: SelectSubset<T, ToolCreateArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Tools.
         * @param {ToolCreateManyArgs} args - Arguments to create many Tools.
         * @example
         * // Create many Tools
         * const tool = await prisma.tool.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends ToolCreateManyArgs>(
            args?: SelectSubset<T, ToolCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Tools and returns the data saved in the database.
         * @param {ToolCreateManyAndReturnArgs} args - Arguments to create many Tools.
         * @example
         * // Create many Tools
         * const tool = await prisma.tool.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Tools and only return the `id`
         * const toolWithIdOnly = await prisma.tool.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends ToolCreateManyAndReturnArgs>(
            args?: SelectSubset<T, ToolCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Tool.
         * @param {ToolDeleteArgs} args - Arguments to delete one Tool.
         * @example
         * // Delete one Tool
         * const Tool = await prisma.tool.delete({
         *   where: {
         *     // ... filter to delete one Tool
         *   }
         * })
         *
         */
        delete<T extends ToolDeleteArgs>(
            args: SelectSubset<T, ToolDeleteArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Tool.
         * @param {ToolUpdateArgs} args - Arguments to update one Tool.
         * @example
         * // Update one Tool
         * const tool = await prisma.tool.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends ToolUpdateArgs>(
            args: SelectSubset<T, ToolUpdateArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Tools.
         * @param {ToolDeleteManyArgs} args - Arguments to filter Tools to delete.
         * @example
         * // Delete a few Tools
         * const { count } = await prisma.tool.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends ToolDeleteManyArgs>(
            args?: SelectSubset<T, ToolDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Tools.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Tools
         * const tool = await prisma.tool.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends ToolUpdateManyArgs>(
            args: SelectSubset<T, ToolUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Tools and returns the data updated in the database.
         * @param {ToolUpdateManyAndReturnArgs} args - Arguments to update many Tools.
         * @example
         * // Update many Tools
         * const tool = await prisma.tool.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Tools and only return the `id`
         * const toolWithIdOnly = await prisma.tool.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends ToolUpdateManyAndReturnArgs>(
            args: SelectSubset<T, ToolUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Tool.
         * @param {ToolUpsertArgs} args - Arguments to update or create a Tool.
         * @example
         * // Update or create a Tool
         * const tool = await prisma.tool.upsert({
         *   create: {
         *     // ... data to create a Tool
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Tool we want to update
         *   }
         * })
         */
        upsert<T extends ToolUpsertArgs>(
            args: SelectSubset<T, ToolUpsertArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Tools.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolCountArgs} args - Arguments to filter Tools to count.
         * @example
         * // Count the number of Tools
         * const count = await prisma.tool.count({
         *   where: {
         *     // ... the filter for the Tools we want to count
         *   }
         * })
         **/
        count<T extends ToolCountArgs>(
            args?: Subset<T, ToolCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], ToolCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Tool.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends ToolAggregateArgs>(
            args: Subset<T, ToolAggregateArgs>,
        ): Prisma.PrismaPromise<GetToolAggregateType<T>>;

        /**
         * Group by Tool.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ToolGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends ToolGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: ToolGroupByArgs['orderBy'] }
                : { orderBy?: ToolGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, ToolGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Tool model
         */
        readonly fields: ToolFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Tool.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__ToolClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        cvs<T extends Tool$cvsArgs<ExtArgs> = {}>(
            args?: Subset<T, Tool$cvsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Tool model
     */
    interface ToolFieldRefs {
        readonly id: FieldRef<'Tool', 'String'>;
        readonly name: FieldRef<'Tool', 'String'>;
    }

    // Custom InputTypes
    /**
     * Tool findUnique
     */
    export type ToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter, which Tool to fetch.
         */
        where: ToolWhereUniqueInput;
    };

    /**
     * Tool findUniqueOrThrow
     */
    export type ToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter, which Tool to fetch.
         */
        where: ToolWhereUniqueInput;
    };

    /**
     * Tool findFirst
     */
    export type ToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter, which Tool to fetch.
         */
        where?: ToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tools to fetch.
         */
        orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Tools.
         */
        cursor?: ToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Tools.
         */
        distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[];
    };

    /**
     * Tool findFirstOrThrow
     */
    export type ToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter, which Tool to fetch.
         */
        where?: ToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tools to fetch.
         */
        orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Tools.
         */
        cursor?: ToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Tools.
         */
        distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[];
    };

    /**
     * Tool findMany
     */
    export type ToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter, which Tools to fetch.
         */
        where?: ToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tools to fetch.
         */
        orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Tools.
         */
        cursor?: ToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tools.
         */
        skip?: number;
        distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[];
    };

    /**
     * Tool create
     */
    export type ToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * The data needed to create a Tool.
         */
        data: XOR<ToolCreateInput, ToolUncheckedCreateInput>;
    };

    /**
     * Tool createMany
     */
    export type ToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Tools.
         */
        data: ToolCreateManyInput | ToolCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Tool createManyAndReturn
     */
    export type ToolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * The data used to create many Tools.
         */
        data: ToolCreateManyInput | ToolCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Tool update
     */
    export type ToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * The data needed to update a Tool.
         */
        data: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>;
        /**
         * Choose, which Tool to update.
         */
        where: ToolWhereUniqueInput;
    };

    /**
     * Tool updateMany
     */
    export type ToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Tools.
         */
        data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyInput>;
        /**
         * Filter which Tools to update
         */
        where?: ToolWhereInput;
        /**
         * Limit how many Tools to update.
         */
        limit?: number;
    };

    /**
     * Tool updateManyAndReturn
     */
    export type ToolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * The data used to update Tools.
         */
        data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyInput>;
        /**
         * Filter which Tools to update
         */
        where?: ToolWhereInput;
        /**
         * Limit how many Tools to update.
         */
        limit?: number;
    };

    /**
     * Tool upsert
     */
    export type ToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * The filter to search for the Tool to update in case it exists.
         */
        where: ToolWhereUniqueInput;
        /**
         * In case the Tool found by the `where` argument doesn't exist, create a new Tool with this data.
         */
        create: XOR<ToolCreateInput, ToolUncheckedCreateInput>;
        /**
         * In case the Tool was found with the provided `where` argument, update it with this data.
         */
        update: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>;
    };

    /**
     * Tool delete
     */
    export type ToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
        /**
         * Filter which Tool to delete.
         */
        where: ToolWhereUniqueInput;
    };

    /**
     * Tool deleteMany
     */
    export type ToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Tools to delete
         */
        where?: ToolWhereInput;
        /**
         * Limit how many Tools to delete.
         */
        limit?: number;
    };

    /**
     * Tool.cvs
     */
    export type Tool$cvsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        where?: CvToolWhereInput;
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        cursor?: CvToolWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: CvToolScalarFieldEnum | CvToolScalarFieldEnum[];
    };

    /**
     * Tool without action
     */
    export type ToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Tool
         */
        select?: ToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Tool
         */
        omit?: ToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ToolInclude<ExtArgs> | null;
    };

    /**
     * Model CvSkill
     */

    export type AggregateCvSkill = {
        _count: CvSkillCountAggregateOutputType | null;
        _min: CvSkillMinAggregateOutputType | null;
        _max: CvSkillMaxAggregateOutputType | null;
    };

    export type CvSkillMinAggregateOutputType = {
        cvId: string | null;
        skillId: string | null;
    };

    export type CvSkillMaxAggregateOutputType = {
        cvId: string | null;
        skillId: string | null;
    };

    export type CvSkillCountAggregateOutputType = {
        cvId: number;
        skillId: number;
        _all: number;
    };

    export type CvSkillMinAggregateInputType = {
        cvId?: true;
        skillId?: true;
    };

    export type CvSkillMaxAggregateInputType = {
        cvId?: true;
        skillId?: true;
    };

    export type CvSkillCountAggregateInputType = {
        cvId?: true;
        skillId?: true;
        _all?: true;
    };

    export type CvSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CvSkill to aggregate.
         */
        where?: CvSkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvSkills to fetch.
         */
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CvSkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvSkills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvSkills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned CvSkills
         **/
        _count?: true | CvSkillCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CvSkillMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CvSkillMaxAggregateInputType;
    };

    export type GetCvSkillAggregateType<T extends CvSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCvSkill]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCvSkill[P]>
            : GetScalarType<T[P], AggregateCvSkill[P]>;
    };

    export type CvSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvSkillWhereInput;
        orderBy?: CvSkillOrderByWithAggregationInput | CvSkillOrderByWithAggregationInput[];
        by: CvSkillScalarFieldEnum[] | CvSkillScalarFieldEnum;
        having?: CvSkillScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CvSkillCountAggregateInputType | true;
        _min?: CvSkillMinAggregateInputType;
        _max?: CvSkillMaxAggregateInputType;
    };

    export type CvSkillGroupByOutputType = {
        cvId: string;
        skillId: string;
        _count: CvSkillCountAggregateOutputType | null;
        _min: CvSkillMinAggregateOutputType | null;
        _max: CvSkillMaxAggregateOutputType | null;
    };

    type GetCvSkillGroupByPayload<T extends CvSkillGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CvSkillGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CvSkillGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CvSkillGroupByOutputType[P]>
                    : GetScalarType<T[P], CvSkillGroupByOutputType[P]>;
            }
        >
    >;

    export type CvSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                skillId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                skill?: boolean | SkillDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvSkill']
        >;

    export type CvSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                skillId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                skill?: boolean | SkillDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvSkill']
        >;

    export type CvSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                skillId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                skill?: boolean | SkillDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvSkill']
        >;

    export type CvSkillSelectScalar = {
        cvId?: boolean;
        skillId?: boolean;
    };

    export type CvSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'cvId' | 'skillId',
        ExtArgs['result']['cvSkill']
    >;
    export type CvSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cv?: boolean | CVDefaultArgs<ExtArgs>;
        skill?: boolean | SkillDefaultArgs<ExtArgs>;
    };
    export type CvSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            cv?: boolean | CVDefaultArgs<ExtArgs>;
            skill?: boolean | SkillDefaultArgs<ExtArgs>;
        };
    export type CvSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            cv?: boolean | CVDefaultArgs<ExtArgs>;
            skill?: boolean | SkillDefaultArgs<ExtArgs>;
        };

    export type $CvSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'CvSkill';
        objects: {
            cv: Prisma.$CVPayload<ExtArgs>;
            skill: Prisma.$SkillPayload<ExtArgs>;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                cvId: string;
                skillId: string;
            },
            ExtArgs['result']['cvSkill']
        >;
        composites: {};
    };

    type CvSkillGetPayload<S extends boolean | null | undefined | CvSkillDefaultArgs> = $Result.GetResult<
        Prisma.$CvSkillPayload,
        S
    >;

    type CvSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CvSkillFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CvSkillCountAggregateInputType | true;
    };

    export interface CvSkillDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CvSkill']; meta: { name: 'CvSkill' } };
        /**
         * Find zero or one CvSkill that matches the filter.
         * @param {CvSkillFindUniqueArgs} args - Arguments to find a CvSkill
         * @example
         * // Get one CvSkill
         * const cvSkill = await prisma.cvSkill.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CvSkillFindUniqueArgs>(
            args: SelectSubset<T, CvSkillFindUniqueArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one CvSkill that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CvSkillFindUniqueOrThrowArgs} args - Arguments to find a CvSkill
         * @example
         * // Get one CvSkill
         * const cvSkill = await prisma.cvSkill.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CvSkillFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CvSkillFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CvSkill that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillFindFirstArgs} args - Arguments to find a CvSkill
         * @example
         * // Get one CvSkill
         * const cvSkill = await prisma.cvSkill.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CvSkillFindFirstArgs>(
            args?: SelectSubset<T, CvSkillFindFirstArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CvSkill that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillFindFirstOrThrowArgs} args - Arguments to find a CvSkill
         * @example
         * // Get one CvSkill
         * const cvSkill = await prisma.cvSkill.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CvSkillFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CvSkillFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more CvSkills that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all CvSkills
         * const cvSkills = await prisma.cvSkill.findMany()
         *
         * // Get first 10 CvSkills
         * const cvSkills = await prisma.cvSkill.findMany({ take: 10 })
         *
         * // Only select the `cvId`
         * const cvSkillWithCvIdOnly = await prisma.cvSkill.findMany({ select: { cvId: true } })
         *
         */
        findMany<T extends CvSkillFindManyArgs>(
            args?: SelectSubset<T, CvSkillFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a CvSkill.
         * @param {CvSkillCreateArgs} args - Arguments to create a CvSkill.
         * @example
         * // Create one CvSkill
         * const CvSkill = await prisma.cvSkill.create({
         *   data: {
         *     // ... data to create a CvSkill
         *   }
         * })
         *
         */
        create<T extends CvSkillCreateArgs>(
            args: SelectSubset<T, CvSkillCreateArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many CvSkills.
         * @param {CvSkillCreateManyArgs} args - Arguments to create many CvSkills.
         * @example
         * // Create many CvSkills
         * const cvSkill = await prisma.cvSkill.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CvSkillCreateManyArgs>(
            args?: SelectSubset<T, CvSkillCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many CvSkills and returns the data saved in the database.
         * @param {CvSkillCreateManyAndReturnArgs} args - Arguments to create many CvSkills.
         * @example
         * // Create many CvSkills
         * const cvSkill = await prisma.cvSkill.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many CvSkills and only return the `cvId`
         * const cvSkillWithCvIdOnly = await prisma.cvSkill.createManyAndReturn({
         *   select: { cvId: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CvSkillCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CvSkillCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a CvSkill.
         * @param {CvSkillDeleteArgs} args - Arguments to delete one CvSkill.
         * @example
         * // Delete one CvSkill
         * const CvSkill = await prisma.cvSkill.delete({
         *   where: {
         *     // ... filter to delete one CvSkill
         *   }
         * })
         *
         */
        delete<T extends CvSkillDeleteArgs>(
            args: SelectSubset<T, CvSkillDeleteArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one CvSkill.
         * @param {CvSkillUpdateArgs} args - Arguments to update one CvSkill.
         * @example
         * // Update one CvSkill
         * const cvSkill = await prisma.cvSkill.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CvSkillUpdateArgs>(
            args: SelectSubset<T, CvSkillUpdateArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more CvSkills.
         * @param {CvSkillDeleteManyArgs} args - Arguments to filter CvSkills to delete.
         * @example
         * // Delete a few CvSkills
         * const { count } = await prisma.cvSkill.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CvSkillDeleteManyArgs>(
            args?: SelectSubset<T, CvSkillDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CvSkills.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many CvSkills
         * const cvSkill = await prisma.cvSkill.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CvSkillUpdateManyArgs>(
            args: SelectSubset<T, CvSkillUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CvSkills and returns the data updated in the database.
         * @param {CvSkillUpdateManyAndReturnArgs} args - Arguments to update many CvSkills.
         * @example
         * // Update many CvSkills
         * const cvSkill = await prisma.cvSkill.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more CvSkills and only return the `cvId`
         * const cvSkillWithCvIdOnly = await prisma.cvSkill.updateManyAndReturn({
         *   select: { cvId: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CvSkillUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CvSkillUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one CvSkill.
         * @param {CvSkillUpsertArgs} args - Arguments to update or create a CvSkill.
         * @example
         * // Update or create a CvSkill
         * const cvSkill = await prisma.cvSkill.upsert({
         *   create: {
         *     // ... data to create a CvSkill
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the CvSkill we want to update
         *   }
         * })
         */
        upsert<T extends CvSkillUpsertArgs>(
            args: SelectSubset<T, CvSkillUpsertArgs<ExtArgs>>,
        ): Prisma__CvSkillClient<
            $Result.GetResult<Prisma.$CvSkillPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of CvSkills.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillCountArgs} args - Arguments to filter CvSkills to count.
         * @example
         * // Count the number of CvSkills
         * const count = await prisma.cvSkill.count({
         *   where: {
         *     // ... the filter for the CvSkills we want to count
         *   }
         * })
         **/
        count<T extends CvSkillCountArgs>(
            args?: Subset<T, CvSkillCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CvSkillCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a CvSkill.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CvSkillAggregateArgs>(
            args: Subset<T, CvSkillAggregateArgs>,
        ): Prisma.PrismaPromise<GetCvSkillAggregateType<T>>;

        /**
         * Group by CvSkill.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvSkillGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CvSkillGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CvSkillGroupByArgs['orderBy'] }
                : { orderBy?: CvSkillGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CvSkillGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCvSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the CvSkill model
         */
        readonly fields: CvSkillFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for CvSkill.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CvSkillClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        cv<T extends CVDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, CVDefaultArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        skill<T extends SkillDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, SkillDefaultArgs<ExtArgs>>,
        ): Prisma__SkillClient<
            $Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the CvSkill model
     */
    interface CvSkillFieldRefs {
        readonly cvId: FieldRef<'CvSkill', 'String'>;
        readonly skillId: FieldRef<'CvSkill', 'String'>;
    }

    // Custom InputTypes
    /**
     * CvSkill findUnique
     */
    export type CvSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter, which CvSkill to fetch.
         */
        where: CvSkillWhereUniqueInput;
    };

    /**
     * CvSkill findUniqueOrThrow
     */
    export type CvSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter, which CvSkill to fetch.
         */
        where: CvSkillWhereUniqueInput;
    };

    /**
     * CvSkill findFirst
     */
    export type CvSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter, which CvSkill to fetch.
         */
        where?: CvSkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvSkills to fetch.
         */
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CvSkills.
         */
        cursor?: CvSkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvSkills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvSkills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CvSkills.
         */
        distinct?: CvSkillScalarFieldEnum | CvSkillScalarFieldEnum[];
    };

    /**
     * CvSkill findFirstOrThrow
     */
    export type CvSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter, which CvSkill to fetch.
         */
        where?: CvSkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvSkills to fetch.
         */
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CvSkills.
         */
        cursor?: CvSkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvSkills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvSkills.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CvSkills.
         */
        distinct?: CvSkillScalarFieldEnum | CvSkillScalarFieldEnum[];
    };

    /**
     * CvSkill findMany
     */
    export type CvSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter, which CvSkills to fetch.
         */
        where?: CvSkillWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvSkills to fetch.
         */
        orderBy?: CvSkillOrderByWithRelationInput | CvSkillOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing CvSkills.
         */
        cursor?: CvSkillWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvSkills from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvSkills.
         */
        skip?: number;
        distinct?: CvSkillScalarFieldEnum | CvSkillScalarFieldEnum[];
    };

    /**
     * CvSkill create
     */
    export type CvSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * The data needed to create a CvSkill.
         */
        data: XOR<CvSkillCreateInput, CvSkillUncheckedCreateInput>;
    };

    /**
     * CvSkill createMany
     */
    export type CvSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many CvSkills.
         */
        data: CvSkillCreateManyInput | CvSkillCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * CvSkill createManyAndReturn
     */
    export type CvSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * The data used to create many CvSkills.
         */
        data: CvSkillCreateManyInput | CvSkillCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CvSkill update
     */
    export type CvSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * The data needed to update a CvSkill.
         */
        data: XOR<CvSkillUpdateInput, CvSkillUncheckedUpdateInput>;
        /**
         * Choose, which CvSkill to update.
         */
        where: CvSkillWhereUniqueInput;
    };

    /**
     * CvSkill updateMany
     */
    export type CvSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update CvSkills.
         */
        data: XOR<CvSkillUpdateManyMutationInput, CvSkillUncheckedUpdateManyInput>;
        /**
         * Filter which CvSkills to update
         */
        where?: CvSkillWhereInput;
        /**
         * Limit how many CvSkills to update.
         */
        limit?: number;
    };

    /**
     * CvSkill updateManyAndReturn
     */
    export type CvSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * The data used to update CvSkills.
         */
        data: XOR<CvSkillUpdateManyMutationInput, CvSkillUncheckedUpdateManyInput>;
        /**
         * Filter which CvSkills to update
         */
        where?: CvSkillWhereInput;
        /**
         * Limit how many CvSkills to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CvSkill upsert
     */
    export type CvSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * The filter to search for the CvSkill to update in case it exists.
         */
        where: CvSkillWhereUniqueInput;
        /**
         * In case the CvSkill found by the `where` argument doesn't exist, create a new CvSkill with this data.
         */
        create: XOR<CvSkillCreateInput, CvSkillUncheckedCreateInput>;
        /**
         * In case the CvSkill was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CvSkillUpdateInput, CvSkillUncheckedUpdateInput>;
    };

    /**
     * CvSkill delete
     */
    export type CvSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
        /**
         * Filter which CvSkill to delete.
         */
        where: CvSkillWhereUniqueInput;
    };

    /**
     * CvSkill deleteMany
     */
    export type CvSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CvSkills to delete
         */
        where?: CvSkillWhereInput;
        /**
         * Limit how many CvSkills to delete.
         */
        limit?: number;
    };

    /**
     * CvSkill without action
     */
    export type CvSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvSkill
         */
        select?: CvSkillSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvSkill
         */
        omit?: CvSkillOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvSkillInclude<ExtArgs> | null;
    };

    /**
     * Model CvTool
     */

    export type AggregateCvTool = {
        _count: CvToolCountAggregateOutputType | null;
        _min: CvToolMinAggregateOutputType | null;
        _max: CvToolMaxAggregateOutputType | null;
    };

    export type CvToolMinAggregateOutputType = {
        cvId: string | null;
        toolId: string | null;
    };

    export type CvToolMaxAggregateOutputType = {
        cvId: string | null;
        toolId: string | null;
    };

    export type CvToolCountAggregateOutputType = {
        cvId: number;
        toolId: number;
        _all: number;
    };

    export type CvToolMinAggregateInputType = {
        cvId?: true;
        toolId?: true;
    };

    export type CvToolMaxAggregateInputType = {
        cvId?: true;
        toolId?: true;
    };

    export type CvToolCountAggregateInputType = {
        cvId?: true;
        toolId?: true;
        _all?: true;
    };

    export type CvToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CvTool to aggregate.
         */
        where?: CvToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvTools to fetch.
         */
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CvToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvTools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvTools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned CvTools
         **/
        _count?: true | CvToolCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CvToolMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CvToolMaxAggregateInputType;
    };

    export type GetCvToolAggregateType<T extends CvToolAggregateArgs> = {
        [P in keyof T & keyof AggregateCvTool]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCvTool[P]>
            : GetScalarType<T[P], AggregateCvTool[P]>;
    };

    export type CvToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CvToolWhereInput;
        orderBy?: CvToolOrderByWithAggregationInput | CvToolOrderByWithAggregationInput[];
        by: CvToolScalarFieldEnum[] | CvToolScalarFieldEnum;
        having?: CvToolScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CvToolCountAggregateInputType | true;
        _min?: CvToolMinAggregateInputType;
        _max?: CvToolMaxAggregateInputType;
    };

    export type CvToolGroupByOutputType = {
        cvId: string;
        toolId: string;
        _count: CvToolCountAggregateOutputType | null;
        _min: CvToolMinAggregateOutputType | null;
        _max: CvToolMaxAggregateOutputType | null;
    };

    type GetCvToolGroupByPayload<T extends CvToolGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CvToolGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CvToolGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CvToolGroupByOutputType[P]>
                    : GetScalarType<T[P], CvToolGroupByOutputType[P]>;
            }
        >
    >;

    export type CvToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                toolId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                tool?: boolean | ToolDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvTool']
        >;

    export type CvToolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                toolId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                tool?: boolean | ToolDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvTool']
        >;

    export type CvToolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                cvId?: boolean;
                toolId?: boolean;
                cv?: boolean | CVDefaultArgs<ExtArgs>;
                tool?: boolean | ToolDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['cvTool']
        >;

    export type CvToolSelectScalar = {
        cvId?: boolean;
        toolId?: boolean;
    };

    export type CvToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'cvId' | 'toolId',
        ExtArgs['result']['cvTool']
    >;
    export type CvToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cv?: boolean | CVDefaultArgs<ExtArgs>;
        tool?: boolean | ToolDefaultArgs<ExtArgs>;
    };
    export type CvToolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cv?: boolean | CVDefaultArgs<ExtArgs>;
        tool?: boolean | ToolDefaultArgs<ExtArgs>;
    };
    export type CvToolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        cv?: boolean | CVDefaultArgs<ExtArgs>;
        tool?: boolean | ToolDefaultArgs<ExtArgs>;
    };

    export type $CvToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'CvTool';
        objects: {
            cv: Prisma.$CVPayload<ExtArgs>;
            tool: Prisma.$ToolPayload<ExtArgs>;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                cvId: string;
                toolId: string;
            },
            ExtArgs['result']['cvTool']
        >;
        composites: {};
    };

    type CvToolGetPayload<S extends boolean | null | undefined | CvToolDefaultArgs> = $Result.GetResult<
        Prisma.$CvToolPayload,
        S
    >;

    type CvToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CvToolFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CvToolCountAggregateInputType | true;
    };

    export interface CvToolDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CvTool']; meta: { name: 'CvTool' } };
        /**
         * Find zero or one CvTool that matches the filter.
         * @param {CvToolFindUniqueArgs} args - Arguments to find a CvTool
         * @example
         * // Get one CvTool
         * const cvTool = await prisma.cvTool.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CvToolFindUniqueArgs>(
            args: SelectSubset<T, CvToolFindUniqueArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one CvTool that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CvToolFindUniqueOrThrowArgs} args - Arguments to find a CvTool
         * @example
         * // Get one CvTool
         * const cvTool = await prisma.cvTool.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CvToolFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CvToolFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CvTool that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolFindFirstArgs} args - Arguments to find a CvTool
         * @example
         * // Get one CvTool
         * const cvTool = await prisma.cvTool.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CvToolFindFirstArgs>(
            args?: SelectSubset<T, CvToolFindFirstArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CvTool that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolFindFirstOrThrowArgs} args - Arguments to find a CvTool
         * @example
         * // Get one CvTool
         * const cvTool = await prisma.cvTool.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CvToolFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CvToolFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more CvTools that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all CvTools
         * const cvTools = await prisma.cvTool.findMany()
         *
         * // Get first 10 CvTools
         * const cvTools = await prisma.cvTool.findMany({ take: 10 })
         *
         * // Only select the `cvId`
         * const cvToolWithCvIdOnly = await prisma.cvTool.findMany({ select: { cvId: true } })
         *
         */
        findMany<T extends CvToolFindManyArgs>(
            args?: SelectSubset<T, CvToolFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a CvTool.
         * @param {CvToolCreateArgs} args - Arguments to create a CvTool.
         * @example
         * // Create one CvTool
         * const CvTool = await prisma.cvTool.create({
         *   data: {
         *     // ... data to create a CvTool
         *   }
         * })
         *
         */
        create<T extends CvToolCreateArgs>(
            args: SelectSubset<T, CvToolCreateArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many CvTools.
         * @param {CvToolCreateManyArgs} args - Arguments to create many CvTools.
         * @example
         * // Create many CvTools
         * const cvTool = await prisma.cvTool.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CvToolCreateManyArgs>(
            args?: SelectSubset<T, CvToolCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many CvTools and returns the data saved in the database.
         * @param {CvToolCreateManyAndReturnArgs} args - Arguments to create many CvTools.
         * @example
         * // Create many CvTools
         * const cvTool = await prisma.cvTool.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many CvTools and only return the `cvId`
         * const cvToolWithCvIdOnly = await prisma.cvTool.createManyAndReturn({
         *   select: { cvId: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CvToolCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CvToolCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a CvTool.
         * @param {CvToolDeleteArgs} args - Arguments to delete one CvTool.
         * @example
         * // Delete one CvTool
         * const CvTool = await prisma.cvTool.delete({
         *   where: {
         *     // ... filter to delete one CvTool
         *   }
         * })
         *
         */
        delete<T extends CvToolDeleteArgs>(
            args: SelectSubset<T, CvToolDeleteArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one CvTool.
         * @param {CvToolUpdateArgs} args - Arguments to update one CvTool.
         * @example
         * // Update one CvTool
         * const cvTool = await prisma.cvTool.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CvToolUpdateArgs>(
            args: SelectSubset<T, CvToolUpdateArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more CvTools.
         * @param {CvToolDeleteManyArgs} args - Arguments to filter CvTools to delete.
         * @example
         * // Delete a few CvTools
         * const { count } = await prisma.cvTool.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CvToolDeleteManyArgs>(
            args?: SelectSubset<T, CvToolDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CvTools.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many CvTools
         * const cvTool = await prisma.cvTool.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CvToolUpdateManyArgs>(
            args: SelectSubset<T, CvToolUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CvTools and returns the data updated in the database.
         * @param {CvToolUpdateManyAndReturnArgs} args - Arguments to update many CvTools.
         * @example
         * // Update many CvTools
         * const cvTool = await prisma.cvTool.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more CvTools and only return the `cvId`
         * const cvToolWithCvIdOnly = await prisma.cvTool.updateManyAndReturn({
         *   select: { cvId: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CvToolUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CvToolUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one CvTool.
         * @param {CvToolUpsertArgs} args - Arguments to update or create a CvTool.
         * @example
         * // Update or create a CvTool
         * const cvTool = await prisma.cvTool.upsert({
         *   create: {
         *     // ... data to create a CvTool
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the CvTool we want to update
         *   }
         * })
         */
        upsert<T extends CvToolUpsertArgs>(
            args: SelectSubset<T, CvToolUpsertArgs<ExtArgs>>,
        ): Prisma__CvToolClient<
            $Result.GetResult<Prisma.$CvToolPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of CvTools.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolCountArgs} args - Arguments to filter CvTools to count.
         * @example
         * // Count the number of CvTools
         * const count = await prisma.cvTool.count({
         *   where: {
         *     // ... the filter for the CvTools we want to count
         *   }
         * })
         **/
        count<T extends CvToolCountArgs>(
            args?: Subset<T, CvToolCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CvToolCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a CvTool.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CvToolAggregateArgs>(
            args: Subset<T, CvToolAggregateArgs>,
        ): Prisma.PrismaPromise<GetCvToolAggregateType<T>>;

        /**
         * Group by CvTool.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CvToolGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CvToolGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CvToolGroupByArgs['orderBy'] }
                : { orderBy?: CvToolGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CvToolGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCvToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the CvTool model
         */
        readonly fields: CvToolFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for CvTool.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CvToolClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        cv<T extends CVDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, CVDefaultArgs<ExtArgs>>,
        ): Prisma__CVClient<
            $Result.GetResult<Prisma.$CVPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        tool<T extends ToolDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, ToolDefaultArgs<ExtArgs>>,
        ): Prisma__ToolClient<
            $Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the CvTool model
     */
    interface CvToolFieldRefs {
        readonly cvId: FieldRef<'CvTool', 'String'>;
        readonly toolId: FieldRef<'CvTool', 'String'>;
    }

    // Custom InputTypes
    /**
     * CvTool findUnique
     */
    export type CvToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter, which CvTool to fetch.
         */
        where: CvToolWhereUniqueInput;
    };

    /**
     * CvTool findUniqueOrThrow
     */
    export type CvToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter, which CvTool to fetch.
         */
        where: CvToolWhereUniqueInput;
    };

    /**
     * CvTool findFirst
     */
    export type CvToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter, which CvTool to fetch.
         */
        where?: CvToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvTools to fetch.
         */
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CvTools.
         */
        cursor?: CvToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvTools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvTools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CvTools.
         */
        distinct?: CvToolScalarFieldEnum | CvToolScalarFieldEnum[];
    };

    /**
     * CvTool findFirstOrThrow
     */
    export type CvToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter, which CvTool to fetch.
         */
        where?: CvToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvTools to fetch.
         */
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CvTools.
         */
        cursor?: CvToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvTools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvTools.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CvTools.
         */
        distinct?: CvToolScalarFieldEnum | CvToolScalarFieldEnum[];
    };

    /**
     * CvTool findMany
     */
    export type CvToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter, which CvTools to fetch.
         */
        where?: CvToolWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CvTools to fetch.
         */
        orderBy?: CvToolOrderByWithRelationInput | CvToolOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing CvTools.
         */
        cursor?: CvToolWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CvTools from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CvTools.
         */
        skip?: number;
        distinct?: CvToolScalarFieldEnum | CvToolScalarFieldEnum[];
    };

    /**
     * CvTool create
     */
    export type CvToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * The data needed to create a CvTool.
         */
        data: XOR<CvToolCreateInput, CvToolUncheckedCreateInput>;
    };

    /**
     * CvTool createMany
     */
    export type CvToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many CvTools.
         */
        data: CvToolCreateManyInput | CvToolCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * CvTool createManyAndReturn
     */
    export type CvToolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * The data used to create many CvTools.
         */
        data: CvToolCreateManyInput | CvToolCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CvTool update
     */
    export type CvToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * The data needed to update a CvTool.
         */
        data: XOR<CvToolUpdateInput, CvToolUncheckedUpdateInput>;
        /**
         * Choose, which CvTool to update.
         */
        where: CvToolWhereUniqueInput;
    };

    /**
     * CvTool updateMany
     */
    export type CvToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update CvTools.
         */
        data: XOR<CvToolUpdateManyMutationInput, CvToolUncheckedUpdateManyInput>;
        /**
         * Filter which CvTools to update
         */
        where?: CvToolWhereInput;
        /**
         * Limit how many CvTools to update.
         */
        limit?: number;
    };

    /**
     * CvTool updateManyAndReturn
     */
    export type CvToolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * The data used to update CvTools.
         */
        data: XOR<CvToolUpdateManyMutationInput, CvToolUncheckedUpdateManyInput>;
        /**
         * Filter which CvTools to update
         */
        where?: CvToolWhereInput;
        /**
         * Limit how many CvTools to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * CvTool upsert
     */
    export type CvToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * The filter to search for the CvTool to update in case it exists.
         */
        where: CvToolWhereUniqueInput;
        /**
         * In case the CvTool found by the `where` argument doesn't exist, create a new CvTool with this data.
         */
        create: XOR<CvToolCreateInput, CvToolUncheckedCreateInput>;
        /**
         * In case the CvTool was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CvToolUpdateInput, CvToolUncheckedUpdateInput>;
    };

    /**
     * CvTool delete
     */
    export type CvToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
        /**
         * Filter which CvTool to delete.
         */
        where: CvToolWhereUniqueInput;
    };

    /**
     * CvTool deleteMany
     */
    export type CvToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which CvTools to delete
         */
        where?: CvToolWhereInput;
        /**
         * Limit how many CvTools to delete.
         */
        limit?: number;
    };

    /**
     * CvTool without action
     */
    export type CvToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the CvTool
         */
        select?: CvToolSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CvTool
         */
        omit?: CvToolOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CvToolInclude<ExtArgs> | null;
    };

    /**
     * Model Certificate
     */

    export type AggregateCertificate = {
        _count: CertificateCountAggregateOutputType | null;
        _min: CertificateMinAggregateOutputType | null;
        _max: CertificateMaxAggregateOutputType | null;
    };

    export type CertificateMinAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type CertificateMaxAggregateOutputType = {
        id: string | null;
        name: string | null;
    };

    export type CertificateCountAggregateOutputType = {
        id: number;
        name: number;
        _all: number;
    };

    export type CertificateMinAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type CertificateMaxAggregateInputType = {
        id?: true;
        name?: true;
    };

    export type CertificateCountAggregateInputType = {
        id?: true;
        name?: true;
        _all?: true;
    };

    export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Certificate to aggregate.
         */
        where?: CertificateWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Certificates to fetch.
         */
        orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CertificateWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Certificates from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Certificates.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Certificates
         **/
        _count?: true | CertificateCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CertificateMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CertificateMaxAggregateInputType;
    };

    export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCertificate[P]>
            : GetScalarType<T[P], AggregateCertificate[P]>;
    };

    export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: CertificateWhereInput;
        orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[];
        by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum;
        having?: CertificateScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: CertificateCountAggregateInputType | true;
        _min?: CertificateMinAggregateInputType;
        _max?: CertificateMaxAggregateInputType;
    };

    export type CertificateGroupByOutputType = {
        id: string;
        name: string;
        _count: CertificateCountAggregateOutputType | null;
        _min: CertificateMinAggregateOutputType | null;
        _max: CertificateMaxAggregateOutputType | null;
    };

    type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CertificateGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CertificateGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CertificateGroupByOutputType[P]>
                    : GetScalarType<T[P], CertificateGroupByOutputType[P]>;
            }
        >
    >;

    export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                name?: boolean;
            },
            ExtArgs['result']['certificate']
        >;

    export type CertificateSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            name?: boolean;
        },
        ExtArgs['result']['certificate']
    >;

    export type CertificateSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            name?: boolean;
        },
        ExtArgs['result']['certificate']
    >;

    export type CertificateSelectScalar = {
        id?: boolean;
        name?: boolean;
    };

    export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<'id' | 'name', ExtArgs['result']['certificate']>;

    export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Certificate';
        objects: {};
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                name: string;
            },
            ExtArgs['result']['certificate']
        >;
        composites: {};
    };

    type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<
        Prisma.$CertificatePayload,
        S
    >;

    type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CertificateFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CertificateCountAggregateInputType | true;
    };

    export interface CertificateDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate']; meta: { name: 'Certificate' } };
        /**
         * Find zero or one Certificate that matches the filter.
         * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
         * @example
         * // Get one Certificate
         * const certificate = await prisma.certificate.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CertificateFindUniqueArgs>(
            args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
         * @example
         * // Get one Certificate
         * const certificate = await prisma.certificate.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Certificate that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
         * @example
         * // Get one Certificate
         * const certificate = await prisma.certificate.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CertificateFindFirstArgs>(
            args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Certificate that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
         * @example
         * // Get one Certificate
         * const certificate = await prisma.certificate.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Certificates that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Certificates
         * const certificates = await prisma.certificate.findMany()
         *
         * // Get first 10 Certificates
         * const certificates = await prisma.certificate.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
         *
         */
        findMany<T extends CertificateFindManyArgs>(
            args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a Certificate.
         * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
         * @example
         * // Create one Certificate
         * const Certificate = await prisma.certificate.create({
         *   data: {
         *     // ... data to create a Certificate
         *   }
         * })
         *
         */
        create<T extends CertificateCreateArgs>(
            args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Certificates.
         * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
         * @example
         * // Create many Certificates
         * const certificate = await prisma.certificate.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CertificateCreateManyArgs>(
            args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Certificates and returns the data saved in the database.
         * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
         * @example
         * // Create many Certificates
         * const certificate = await prisma.certificate.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Certificates and only return the `id`
         * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Certificate.
         * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
         * @example
         * // Delete one Certificate
         * const Certificate = await prisma.certificate.delete({
         *   where: {
         *     // ... filter to delete one Certificate
         *   }
         * })
         *
         */
        delete<T extends CertificateDeleteArgs>(
            args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Certificate.
         * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
         * @example
         * // Update one Certificate
         * const certificate = await prisma.certificate.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CertificateUpdateArgs>(
            args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Certificates.
         * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
         * @example
         * // Delete a few Certificates
         * const { count } = await prisma.certificate.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CertificateDeleteManyArgs>(
            args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Certificates.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Certificates
         * const certificate = await prisma.certificate.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CertificateUpdateManyArgs>(
            args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Certificates and returns the data updated in the database.
         * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
         * @example
         * // Update many Certificates
         * const certificate = await prisma.certificate.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Certificates and only return the `id`
         * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Certificate.
         * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
         * @example
         * // Update or create a Certificate
         * const certificate = await prisma.certificate.upsert({
         *   create: {
         *     // ... data to create a Certificate
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Certificate we want to update
         *   }
         * })
         */
        upsert<T extends CertificateUpsertArgs>(
            args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>,
        ): Prisma__CertificateClient<
            $Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Certificates.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
         * @example
         * // Count the number of Certificates
         * const count = await prisma.certificate.count({
         *   where: {
         *     // ... the filter for the Certificates we want to count
         *   }
         * })
         **/
        count<T extends CertificateCountArgs>(
            args?: Subset<T, CertificateCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CertificateCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Certificate.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CertificateAggregateArgs>(
            args: Subset<T, CertificateAggregateArgs>,
        ): Prisma.PrismaPromise<GetCertificateAggregateType<T>>;

        /**
         * Group by Certificate.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CertificateGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CertificateGroupByArgs['orderBy'] }
                : { orderBy?: CertificateGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Certificate model
         */
        readonly fields: CertificateFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Certificate.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CertificateClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Certificate model
     */
    interface CertificateFieldRefs {
        readonly id: FieldRef<'Certificate', 'String'>;
        readonly name: FieldRef<'Certificate', 'String'>;
    }

    // Custom InputTypes
    /**
     * Certificate findUnique
     */
    export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter, which Certificate to fetch.
         */
        where: CertificateWhereUniqueInput;
    };

    /**
     * Certificate findUniqueOrThrow
     */
    export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter, which Certificate to fetch.
         */
        where: CertificateWhereUniqueInput;
    };

    /**
     * Certificate findFirst
     */
    export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter, which Certificate to fetch.
         */
        where?: CertificateWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Certificates to fetch.
         */
        orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Certificates.
         */
        cursor?: CertificateWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Certificates from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Certificates.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Certificates.
         */
        distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
    };

    /**
     * Certificate findFirstOrThrow
     */
    export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter, which Certificate to fetch.
         */
        where?: CertificateWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Certificates to fetch.
         */
        orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Certificates.
         */
        cursor?: CertificateWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Certificates from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Certificates.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Certificates.
         */
        distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
    };

    /**
     * Certificate findMany
     */
    export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter, which Certificates to fetch.
         */
        where?: CertificateWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Certificates to fetch.
         */
        orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Certificates.
         */
        cursor?: CertificateWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Certificates from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Certificates.
         */
        skip?: number;
        distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[];
    };

    /**
     * Certificate create
     */
    export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * The data needed to create a Certificate.
         */
        data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>;
    };

    /**
     * Certificate createMany
     */
    export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Certificates.
         */
        data: CertificateCreateManyInput | CertificateCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Certificate createManyAndReturn
     */
    export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the Certificate
             */
            select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the Certificate
             */
            omit?: CertificateOmit<ExtArgs> | null;
            /**
             * The data used to create many Certificates.
             */
            data: CertificateCreateManyInput | CertificateCreateManyInput[];
            skipDuplicates?: boolean;
        };

    /**
     * Certificate update
     */
    export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * The data needed to update a Certificate.
         */
        data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>;
        /**
         * Choose, which Certificate to update.
         */
        where: CertificateWhereUniqueInput;
    };

    /**
     * Certificate updateMany
     */
    export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Certificates.
         */
        data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>;
        /**
         * Filter which Certificates to update
         */
        where?: CertificateWhereInput;
        /**
         * Limit how many Certificates to update.
         */
        limit?: number;
    };

    /**
     * Certificate updateManyAndReturn
     */
    export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the Certificate
             */
            select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the Certificate
             */
            omit?: CertificateOmit<ExtArgs> | null;
            /**
             * The data used to update Certificates.
             */
            data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>;
            /**
             * Filter which Certificates to update
             */
            where?: CertificateWhereInput;
            /**
             * Limit how many Certificates to update.
             */
            limit?: number;
        };

    /**
     * Certificate upsert
     */
    export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * The filter to search for the Certificate to update in case it exists.
         */
        where: CertificateWhereUniqueInput;
        /**
         * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
         */
        create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>;
        /**
         * In case the Certificate was found with the provided `where` argument, update it with this data.
         */
        update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>;
    };

    /**
     * Certificate delete
     */
    export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
        /**
         * Filter which Certificate to delete.
         */
        where: CertificateWhereUniqueInput;
    };

    /**
     * Certificate deleteMany
     */
    export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Certificates to delete
         */
        where?: CertificateWhereInput;
        /**
         * Limit how many Certificates to delete.
         */
        limit?: number;
    };

    /**
     * Certificate without action
     */
    export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Certificate
         */
        select?: CertificateSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Certificate
         */
        omit?: CertificateOmit<ExtArgs> | null;
    };

    /**
     * Model University
     */

    export type AggregateUniversity = {
        _count: UniversityCountAggregateOutputType | null;
        _avg: UniversityAvgAggregateOutputType | null;
        _sum: UniversitySumAggregateOutputType | null;
        _min: UniversityMinAggregateOutputType | null;
        _max: UniversityMaxAggregateOutputType | null;
    };

    export type UniversityAvgAggregateOutputType = {
        contacts: number | null;
    };

    export type UniversitySumAggregateOutputType = {
        contacts: number | null;
    };

    export type UniversityMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        description: string | null;
        registrationDate: Date | null;
        type: $Enums.UniType | null;
        status: boolean | null;
        contract: string | null;
        contacts: number | null;
        website: string | null;
        email: string | null;
        address: string | null;
        cityId: string | null;
        logo: string | null;
        license: string | null;
        certificateRequirementId: string | null;
    };

    export type UniversityMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        description: string | null;
        registrationDate: Date | null;
        type: $Enums.UniType | null;
        status: boolean | null;
        contract: string | null;
        contacts: number | null;
        website: string | null;
        email: string | null;
        address: string | null;
        cityId: string | null;
        logo: string | null;
        license: string | null;
        certificateRequirementId: string | null;
    };

    export type UniversityCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        title: number;
        description: number;
        registrationDate: number;
        type: number;
        status: number;
        contract: number;
        contacts: number;
        website: number;
        email: number;
        address: number;
        cityId: number;
        logo: number;
        license: number;
        certificateRequirementId: number;
        _all: number;
    };

    export type UniversityAvgAggregateInputType = {
        contacts?: true;
    };

    export type UniversitySumAggregateInputType = {
        contacts?: true;
    };

    export type UniversityMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        registrationDate?: true;
        type?: true;
        status?: true;
        contract?: true;
        contacts?: true;
        website?: true;
        email?: true;
        address?: true;
        cityId?: true;
        logo?: true;
        license?: true;
        certificateRequirementId?: true;
    };

    export type UniversityMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        registrationDate?: true;
        type?: true;
        status?: true;
        contract?: true;
        contacts?: true;
        website?: true;
        email?: true;
        address?: true;
        cityId?: true;
        logo?: true;
        license?: true;
        certificateRequirementId?: true;
    };

    export type UniversityCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        description?: true;
        registrationDate?: true;
        type?: true;
        status?: true;
        contract?: true;
        contacts?: true;
        website?: true;
        email?: true;
        address?: true;
        cityId?: true;
        logo?: true;
        license?: true;
        certificateRequirementId?: true;
        _all?: true;
    };

    export type UniversityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which University to aggregate.
         */
        where?: UniversityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Universities to fetch.
         */
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: UniversityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Universities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Universities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Universities
         **/
        _count?: true | UniversityCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: UniversityAvgAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: UniversitySumAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: UniversityMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: UniversityMaxAggregateInputType;
    };

    export type GetUniversityAggregateType<T extends UniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversity]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateUniversity[P]>
            : GetScalarType<T[P], AggregateUniversity[P]>;
    };

    export type UniversityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: UniversityWhereInput;
        orderBy?: UniversityOrderByWithAggregationInput | UniversityOrderByWithAggregationInput[];
        by: UniversityScalarFieldEnum[] | UniversityScalarFieldEnum;
        having?: UniversityScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: UniversityCountAggregateInputType | true;
        _avg?: UniversityAvgAggregateInputType;
        _sum?: UniversitySumAggregateInputType;
        _min?: UniversityMinAggregateInputType;
        _max?: UniversityMaxAggregateInputType;
    };

    export type UniversityGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string | null;
        updatedAt: Date;
        updatedBy: string | null;
        title: string;
        description: string | null;
        registrationDate: Date;
        type: $Enums.UniType | null;
        status: boolean | null;
        contract: string;
        contacts: number | null;
        website: string | null;
        email: string | null;
        address: string | null;
        cityId: string | null;
        logo: string | null;
        license: string | null;
        certificateRequirementId: string | null;
        _count: UniversityCountAggregateOutputType | null;
        _avg: UniversityAvgAggregateOutputType | null;
        _sum: UniversitySumAggregateOutputType | null;
        _min: UniversityMinAggregateOutputType | null;
        _max: UniversityMaxAggregateOutputType | null;
    };

    type GetUniversityGroupByPayload<T extends UniversityGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<UniversityGroupByOutputType, T['by']> & {
                [P in keyof T & keyof UniversityGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], UniversityGroupByOutputType[P]>
                    : GetScalarType<T[P], UniversityGroupByOutputType[P]>;
            }
        >
    >;

    export type UniversitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                title?: boolean;
                description?: boolean;
                registrationDate?: boolean;
                type?: boolean;
                status?: boolean;
                contract?: boolean;
                contacts?: boolean;
                website?: boolean;
                email?: boolean;
                address?: boolean;
                cityId?: boolean;
                logo?: boolean;
                license?: boolean;
                certificateRequirementId?: boolean;
                city?: boolean | University$cityArgs<ExtArgs>;
                certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
                programs?: boolean | University$programsArgs<ExtArgs>;
                faculties?: boolean | University$facultiesArgs<ExtArgs>;
                _count?: boolean | UniversityCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['university']
        >;

    export type UniversitySelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            title?: boolean;
            description?: boolean;
            registrationDate?: boolean;
            type?: boolean;
            status?: boolean;
            contract?: boolean;
            contacts?: boolean;
            website?: boolean;
            email?: boolean;
            address?: boolean;
            cityId?: boolean;
            logo?: boolean;
            license?: boolean;
            certificateRequirementId?: boolean;
            city?: boolean | University$cityArgs<ExtArgs>;
            certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
        },
        ExtArgs['result']['university']
    >;

    export type UniversitySelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            title?: boolean;
            description?: boolean;
            registrationDate?: boolean;
            type?: boolean;
            status?: boolean;
            contract?: boolean;
            contacts?: boolean;
            website?: boolean;
            email?: boolean;
            address?: boolean;
            cityId?: boolean;
            logo?: boolean;
            license?: boolean;
            certificateRequirementId?: boolean;
            city?: boolean | University$cityArgs<ExtArgs>;
            certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
        },
        ExtArgs['result']['university']
    >;

    export type UniversitySelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        title?: boolean;
        description?: boolean;
        registrationDate?: boolean;
        type?: boolean;
        status?: boolean;
        contract?: boolean;
        contacts?: boolean;
        website?: boolean;
        email?: boolean;
        address?: boolean;
        cityId?: boolean;
        logo?: boolean;
        license?: boolean;
        certificateRequirementId?: boolean;
    };

    export type UniversityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            | 'id'
            | 'createdAt'
            | 'createdBy'
            | 'updatedAt'
            | 'updatedBy'
            | 'title'
            | 'description'
            | 'registrationDate'
            | 'type'
            | 'status'
            | 'contract'
            | 'contacts'
            | 'website'
            | 'email'
            | 'address'
            | 'cityId'
            | 'logo'
            | 'license'
            | 'certificateRequirementId',
            ExtArgs['result']['university']
        >;
    export type UniversityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        city?: boolean | University$cityArgs<ExtArgs>;
        certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
        programs?: boolean | University$programsArgs<ExtArgs>;
        faculties?: boolean | University$facultiesArgs<ExtArgs>;
        _count?: boolean | UniversityCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type UniversityIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        city?: boolean | University$cityArgs<ExtArgs>;
        certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
    };
    export type UniversityIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        city?: boolean | University$cityArgs<ExtArgs>;
        certificateRequirement?: boolean | University$certificateRequirementArgs<ExtArgs>;
    };

    export type $UniversityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'University';
        objects: {
            city: Prisma.$CityPayload<ExtArgs> | null;
            certificateRequirement: Prisma.$CertificateRequirementsPayload<ExtArgs> | null;
            programs: Prisma.$ProgramPayload<ExtArgs>[];
            faculties: Prisma.$FacultyPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string | null;
                updatedAt: Date;
                updatedBy: string | null;
                title: string;
                description: string | null;
                registrationDate: Date;
                type: $Enums.UniType | null;
                status: boolean | null;
                contract: string;
                contacts: number | null;
                website: string | null;
                email: string | null;
                address: string | null;
                cityId: string | null;
                logo: string | null;
                license: string | null;
                certificateRequirementId: string | null;
            },
            ExtArgs['result']['university']
        >;
        composites: {};
    };

    type UniversityGetPayload<S extends boolean | null | undefined | UniversityDefaultArgs> = $Result.GetResult<
        Prisma.$UniversityPayload,
        S
    >;

    type UniversityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        UniversityFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: UniversityCountAggregateInputType | true;
    };

    export interface UniversityDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['University']; meta: { name: 'University' } };
        /**
         * Find zero or one University that matches the filter.
         * @param {UniversityFindUniqueArgs} args - Arguments to find a University
         * @example
         * // Get one University
         * const university = await prisma.university.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends UniversityFindUniqueArgs>(
            args: SelectSubset<T, UniversityFindUniqueArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one University that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {UniversityFindUniqueOrThrowArgs} args - Arguments to find a University
         * @example
         * // Get one University
         * const university = await prisma.university.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends UniversityFindUniqueOrThrowArgs>(
            args: SelectSubset<T, UniversityFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first University that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityFindFirstArgs} args - Arguments to find a University
         * @example
         * // Get one University
         * const university = await prisma.university.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends UniversityFindFirstArgs>(
            args?: SelectSubset<T, UniversityFindFirstArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first University that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityFindFirstOrThrowArgs} args - Arguments to find a University
         * @example
         * // Get one University
         * const university = await prisma.university.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends UniversityFindFirstOrThrowArgs>(
            args?: SelectSubset<T, UniversityFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Universities that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Universities
         * const universities = await prisma.university.findMany()
         *
         * // Get first 10 Universities
         * const universities = await prisma.university.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const universityWithIdOnly = await prisma.university.findMany({ select: { id: true } })
         *
         */
        findMany<T extends UniversityFindManyArgs>(
            args?: SelectSubset<T, UniversityFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a University.
         * @param {UniversityCreateArgs} args - Arguments to create a University.
         * @example
         * // Create one University
         * const University = await prisma.university.create({
         *   data: {
         *     // ... data to create a University
         *   }
         * })
         *
         */
        create<T extends UniversityCreateArgs>(
            args: SelectSubset<T, UniversityCreateArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Universities.
         * @param {UniversityCreateManyArgs} args - Arguments to create many Universities.
         * @example
         * // Create many Universities
         * const university = await prisma.university.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends UniversityCreateManyArgs>(
            args?: SelectSubset<T, UniversityCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Universities and returns the data saved in the database.
         * @param {UniversityCreateManyAndReturnArgs} args - Arguments to create many Universities.
         * @example
         * // Create many Universities
         * const university = await prisma.university.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Universities and only return the `id`
         * const universityWithIdOnly = await prisma.university.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends UniversityCreateManyAndReturnArgs>(
            args?: SelectSubset<T, UniversityCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a University.
         * @param {UniversityDeleteArgs} args - Arguments to delete one University.
         * @example
         * // Delete one University
         * const University = await prisma.university.delete({
         *   where: {
         *     // ... filter to delete one University
         *   }
         * })
         *
         */
        delete<T extends UniversityDeleteArgs>(
            args: SelectSubset<T, UniversityDeleteArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one University.
         * @param {UniversityUpdateArgs} args - Arguments to update one University.
         * @example
         * // Update one University
         * const university = await prisma.university.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends UniversityUpdateArgs>(
            args: SelectSubset<T, UniversityUpdateArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Universities.
         * @param {UniversityDeleteManyArgs} args - Arguments to filter Universities to delete.
         * @example
         * // Delete a few Universities
         * const { count } = await prisma.university.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends UniversityDeleteManyArgs>(
            args?: SelectSubset<T, UniversityDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Universities.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Universities
         * const university = await prisma.university.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends UniversityUpdateManyArgs>(
            args: SelectSubset<T, UniversityUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Universities and returns the data updated in the database.
         * @param {UniversityUpdateManyAndReturnArgs} args - Arguments to update many Universities.
         * @example
         * // Update many Universities
         * const university = await prisma.university.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Universities and only return the `id`
         * const universityWithIdOnly = await prisma.university.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends UniversityUpdateManyAndReturnArgs>(
            args: SelectSubset<T, UniversityUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one University.
         * @param {UniversityUpsertArgs} args - Arguments to update or create a University.
         * @example
         * // Update or create a University
         * const university = await prisma.university.upsert({
         *   create: {
         *     // ... data to create a University
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the University we want to update
         *   }
         * })
         */
        upsert<T extends UniversityUpsertArgs>(
            args: SelectSubset<T, UniversityUpsertArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Universities.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityCountArgs} args - Arguments to filter Universities to count.
         * @example
         * // Count the number of Universities
         * const count = await prisma.university.count({
         *   where: {
         *     // ... the filter for the Universities we want to count
         *   }
         * })
         **/
        count<T extends UniversityCountArgs>(
            args?: Subset<T, UniversityCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], UniversityCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a University.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends UniversityAggregateArgs>(
            args: Subset<T, UniversityAggregateArgs>,
        ): Prisma.PrismaPromise<GetUniversityAggregateType<T>>;

        /**
         * Group by University.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UniversityGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends UniversityGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: UniversityGroupByArgs['orderBy'] }
                : { orderBy?: UniversityGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, UniversityGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the University model
         */
        readonly fields: UniversityFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for University.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__UniversityClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        city<T extends University$cityArgs<ExtArgs> = {}>(
            args?: Subset<T, University$cityArgs<ExtArgs>>,
        ): Prisma__CityClient<
            $Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        certificateRequirement<T extends University$certificateRequirementArgs<ExtArgs> = {}>(
            args?: Subset<T, University$certificateRequirementArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findUniqueOrThrow',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        programs<T extends University$programsArgs<ExtArgs> = {}>(
            args?: Subset<T, University$programsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        faculties<T extends University$facultiesArgs<ExtArgs> = {}>(
            args?: Subset<T, University$facultiesArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the University model
     */
    interface UniversityFieldRefs {
        readonly id: FieldRef<'University', 'String'>;
        readonly createdAt: FieldRef<'University', 'DateTime'>;
        readonly createdBy: FieldRef<'University', 'String'>;
        readonly updatedAt: FieldRef<'University', 'DateTime'>;
        readonly updatedBy: FieldRef<'University', 'String'>;
        readonly title: FieldRef<'University', 'String'>;
        readonly description: FieldRef<'University', 'String'>;
        readonly registrationDate: FieldRef<'University', 'DateTime'>;
        readonly type: FieldRef<'University', 'UniType'>;
        readonly status: FieldRef<'University', 'Boolean'>;
        readonly contract: FieldRef<'University', 'String'>;
        readonly contacts: FieldRef<'University', 'Int'>;
        readonly website: FieldRef<'University', 'String'>;
        readonly email: FieldRef<'University', 'String'>;
        readonly address: FieldRef<'University', 'String'>;
        readonly cityId: FieldRef<'University', 'String'>;
        readonly logo: FieldRef<'University', 'String'>;
        readonly license: FieldRef<'University', 'String'>;
        readonly certificateRequirementId: FieldRef<'University', 'String'>;
    }

    // Custom InputTypes
    /**
     * University findUnique
     */
    export type UniversityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter, which University to fetch.
         */
        where: UniversityWhereUniqueInput;
    };

    /**
     * University findUniqueOrThrow
     */
    export type UniversityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter, which University to fetch.
         */
        where: UniversityWhereUniqueInput;
    };

    /**
     * University findFirst
     */
    export type UniversityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter, which University to fetch.
         */
        where?: UniversityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Universities to fetch.
         */
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Universities.
         */
        cursor?: UniversityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Universities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Universities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Universities.
         */
        distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[];
    };

    /**
     * University findFirstOrThrow
     */
    export type UniversityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter, which University to fetch.
         */
        where?: UniversityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Universities to fetch.
         */
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Universities.
         */
        cursor?: UniversityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Universities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Universities.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Universities.
         */
        distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[];
    };

    /**
     * University findMany
     */
    export type UniversityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter, which Universities to fetch.
         */
        where?: UniversityWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Universities to fetch.
         */
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Universities.
         */
        cursor?: UniversityWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Universities from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Universities.
         */
        skip?: number;
        distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[];
    };

    /**
     * University create
     */
    export type UniversityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * The data needed to create a University.
         */
        data: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>;
    };

    /**
     * University createMany
     */
    export type UniversityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Universities.
         */
        data: UniversityCreateManyInput | UniversityCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * University createManyAndReturn
     */
    export type UniversityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the University
             */
            select?: UniversitySelectCreateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the University
             */
            omit?: UniversityOmit<ExtArgs> | null;
            /**
             * The data used to create many Universities.
             */
            data: UniversityCreateManyInput | UniversityCreateManyInput[];
            skipDuplicates?: boolean;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: UniversityIncludeCreateManyAndReturn<ExtArgs> | null;
        };

    /**
     * University update
     */
    export type UniversityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * The data needed to update a University.
         */
        data: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>;
        /**
         * Choose, which University to update.
         */
        where: UniversityWhereUniqueInput;
    };

    /**
     * University updateMany
     */
    export type UniversityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Universities.
         */
        data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>;
        /**
         * Filter which Universities to update
         */
        where?: UniversityWhereInput;
        /**
         * Limit how many Universities to update.
         */
        limit?: number;
    };

    /**
     * University updateManyAndReturn
     */
    export type UniversityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the University
             */
            select?: UniversitySelectUpdateManyAndReturn<ExtArgs> | null;
            /**
             * Omit specific fields from the University
             */
            omit?: UniversityOmit<ExtArgs> | null;
            /**
             * The data used to update Universities.
             */
            data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>;
            /**
             * Filter which Universities to update
             */
            where?: UniversityWhereInput;
            /**
             * Limit how many Universities to update.
             */
            limit?: number;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: UniversityIncludeUpdateManyAndReturn<ExtArgs> | null;
        };

    /**
     * University upsert
     */
    export type UniversityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * The filter to search for the University to update in case it exists.
         */
        where: UniversityWhereUniqueInput;
        /**
         * In case the University found by the `where` argument doesn't exist, create a new University with this data.
         */
        create: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>;
        /**
         * In case the University was found with the provided `where` argument, update it with this data.
         */
        update: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>;
    };

    /**
     * University delete
     */
    export type UniversityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        /**
         * Filter which University to delete.
         */
        where: UniversityWhereUniqueInput;
    };

    /**
     * University deleteMany
     */
    export type UniversityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Universities to delete
         */
        where?: UniversityWhereInput;
        /**
         * Limit how many Universities to delete.
         */
        limit?: number;
    };

    /**
     * University.city
     */
    export type University$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the City
         */
        select?: CitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the City
         */
        omit?: CityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CityInclude<ExtArgs> | null;
        where?: CityWhereInput;
    };

    /**
     * University.certificateRequirement
     */
    export type University$certificateRequirementArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        where?: CertificateRequirementsWhereInput;
    };

    /**
     * University.programs
     */
    export type University$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        where?: ProgramWhereInput;
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        cursor?: ProgramWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * University.faculties
     */
    export type University$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        where?: FacultyWhereInput;
        orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[];
        cursor?: FacultyWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
    };

    /**
     * University without action
     */
    export type UniversityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
    };

    /**
     * Model Program
     */

    export type AggregateProgram = {
        _count: ProgramCountAggregateOutputType | null;
        _avg: ProgramAvgAggregateOutputType | null;
        _sum: ProgramSumAggregateOutputType | null;
        _min: ProgramMinAggregateOutputType | null;
        _max: ProgramMaxAggregateOutputType | null;
    };

    export type ProgramAvgAggregateOutputType = {
        contract: number | null;
    };

    export type ProgramSumAggregateOutputType = {
        contract: number | null;
    };

    export type ProgramMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        studyLanguage: $Enums.StudyLanguage | null;
        contract: number | null;
        degree: $Enums.Degree | null;
        certificateRequirementId: string | null;
        studyType: $Enums.StudyType | null;
        universityId: string | null;
        facultyId: string | null;
    };

    export type ProgramMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        title: string | null;
        studyLanguage: $Enums.StudyLanguage | null;
        contract: number | null;
        degree: $Enums.Degree | null;
        certificateRequirementId: string | null;
        studyType: $Enums.StudyType | null;
        universityId: string | null;
        facultyId: string | null;
    };

    export type ProgramCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        title: number;
        studyLanguage: number;
        contract: number;
        degree: number;
        certificateRequirementId: number;
        studyType: number;
        universityId: number;
        facultyId: number;
        _all: number;
    };

    export type ProgramAvgAggregateInputType = {
        contract?: true;
    };

    export type ProgramSumAggregateInputType = {
        contract?: true;
    };

    export type ProgramMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        studyLanguage?: true;
        contract?: true;
        degree?: true;
        certificateRequirementId?: true;
        studyType?: true;
        universityId?: true;
        facultyId?: true;
    };

    export type ProgramMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        studyLanguage?: true;
        contract?: true;
        degree?: true;
        certificateRequirementId?: true;
        studyType?: true;
        universityId?: true;
        facultyId?: true;
    };

    export type ProgramCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        title?: true;
        studyLanguage?: true;
        contract?: true;
        degree?: true;
        certificateRequirementId?: true;
        studyType?: true;
        universityId?: true;
        facultyId?: true;
        _all?: true;
    };

    export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Program to aggregate.
         */
        where?: ProgramWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Programs to fetch.
         */
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: ProgramWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Programs from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Programs.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Programs
         **/
        _count?: true | ProgramCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: ProgramAvgAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: ProgramSumAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: ProgramMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: ProgramMaxAggregateInputType;
    };

    export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateProgram[P]>
            : GetScalarType<T[P], AggregateProgram[P]>;
    };

    export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: ProgramWhereInput;
        orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[];
        by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum;
        having?: ProgramScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: ProgramCountAggregateInputType | true;
        _avg?: ProgramAvgAggregateInputType;
        _sum?: ProgramSumAggregateInputType;
        _min?: ProgramMinAggregateInputType;
        _max?: ProgramMaxAggregateInputType;
    };

    export type ProgramGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string | null;
        updatedAt: Date;
        updatedBy: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId: string | null;
        studyType: $Enums.StudyType | null;
        universityId: string;
        facultyId: string | null;
        _count: ProgramCountAggregateOutputType | null;
        _avg: ProgramAvgAggregateOutputType | null;
        _sum: ProgramSumAggregateOutputType | null;
        _min: ProgramMinAggregateOutputType | null;
        _max: ProgramMaxAggregateOutputType | null;
    };

    type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<ProgramGroupByOutputType, T['by']> & {
                [P in keyof T & keyof ProgramGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], ProgramGroupByOutputType[P]>
                    : GetScalarType<T[P], ProgramGroupByOutputType[P]>;
            }
        >
    >;

    export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                title?: boolean;
                studyLanguage?: boolean;
                contract?: boolean;
                degree?: boolean;
                certificateRequirementId?: boolean;
                studyType?: boolean;
                universityId?: boolean;
                facultyId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
                faculty?: boolean | Program$facultyArgs<ExtArgs>;
                certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
            },
            ExtArgs['result']['program']
        >;

    export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                title?: boolean;
                studyLanguage?: boolean;
                contract?: boolean;
                degree?: boolean;
                certificateRequirementId?: boolean;
                studyType?: boolean;
                universityId?: boolean;
                facultyId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
                faculty?: boolean | Program$facultyArgs<ExtArgs>;
                certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
            },
            ExtArgs['result']['program']
        >;

    export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                title?: boolean;
                studyLanguage?: boolean;
                contract?: boolean;
                degree?: boolean;
                certificateRequirementId?: boolean;
                studyType?: boolean;
                universityId?: boolean;
                facultyId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
                faculty?: boolean | Program$facultyArgs<ExtArgs>;
                certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
            },
            ExtArgs['result']['program']
        >;

    export type ProgramSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        title?: boolean;
        studyLanguage?: boolean;
        contract?: boolean;
        degree?: boolean;
        certificateRequirementId?: boolean;
        studyType?: boolean;
        universityId?: boolean;
        facultyId?: boolean;
    };

    export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        | 'id'
        | 'createdAt'
        | 'createdBy'
        | 'updatedAt'
        | 'updatedBy'
        | 'title'
        | 'studyLanguage'
        | 'contract'
        | 'degree'
        | 'certificateRequirementId'
        | 'studyType'
        | 'universityId'
        | 'facultyId',
        ExtArgs['result']['program']
    >;
    export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        university?: boolean | UniversityDefaultArgs<ExtArgs>;
        faculty?: boolean | Program$facultyArgs<ExtArgs>;
        certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
    };
    export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            university?: boolean | UniversityDefaultArgs<ExtArgs>;
            faculty?: boolean | Program$facultyArgs<ExtArgs>;
            certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
        };
    export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            university?: boolean | UniversityDefaultArgs<ExtArgs>;
            faculty?: boolean | Program$facultyArgs<ExtArgs>;
            certificateRequirement?: boolean | Program$certificateRequirementArgs<ExtArgs>;
        };

    export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Program';
        objects: {
            university: Prisma.$UniversityPayload<ExtArgs>;
            faculty: Prisma.$FacultyPayload<ExtArgs> | null;
            certificateRequirement: Prisma.$CertificateRequirementsPayload<ExtArgs> | null;
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string | null;
                updatedAt: Date;
                updatedBy: string | null;
                title: string;
                studyLanguage: $Enums.StudyLanguage;
                contract: number;
                degree: $Enums.Degree;
                certificateRequirementId: string | null;
                studyType: $Enums.StudyType | null;
                universityId: string;
                facultyId: string | null;
            },
            ExtArgs['result']['program']
        >;
        composites: {};
    };

    type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<
        Prisma.$ProgramPayload,
        S
    >;

    type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        ProgramFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: ProgramCountAggregateInputType | true;
    };

    export interface ProgramDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program']; meta: { name: 'Program' } };
        /**
         * Find zero or one Program that matches the filter.
         * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
         * @example
         * // Get one Program
         * const program = await prisma.program.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends ProgramFindUniqueArgs>(
            args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Program that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
         * @example
         * // Get one Program
         * const program = await prisma.program.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(
            args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Program that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramFindFirstArgs} args - Arguments to find a Program
         * @example
         * // Get one Program
         * const program = await prisma.program.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends ProgramFindFirstArgs>(
            args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Program that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
         * @example
         * // Get one Program
         * const program = await prisma.program.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(
            args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Programs that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Programs
         * const programs = await prisma.program.findMany()
         *
         * // Get first 10 Programs
         * const programs = await prisma.program.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
         *
         */
        findMany<T extends ProgramFindManyArgs>(
            args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a Program.
         * @param {ProgramCreateArgs} args - Arguments to create a Program.
         * @example
         * // Create one Program
         * const Program = await prisma.program.create({
         *   data: {
         *     // ... data to create a Program
         *   }
         * })
         *
         */
        create<T extends ProgramCreateArgs>(
            args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Programs.
         * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
         * @example
         * // Create many Programs
         * const program = await prisma.program.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends ProgramCreateManyArgs>(
            args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Programs and returns the data saved in the database.
         * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
         * @example
         * // Create many Programs
         * const program = await prisma.program.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Programs and only return the `id`
         * const programWithIdOnly = await prisma.program.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(
            args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Program.
         * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
         * @example
         * // Delete one Program
         * const Program = await prisma.program.delete({
         *   where: {
         *     // ... filter to delete one Program
         *   }
         * })
         *
         */
        delete<T extends ProgramDeleteArgs>(
            args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Program.
         * @param {ProgramUpdateArgs} args - Arguments to update one Program.
         * @example
         * // Update one Program
         * const program = await prisma.program.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends ProgramUpdateArgs>(
            args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Programs.
         * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
         * @example
         * // Delete a few Programs
         * const { count } = await prisma.program.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends ProgramDeleteManyArgs>(
            args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Programs.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Programs
         * const program = await prisma.program.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends ProgramUpdateManyArgs>(
            args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Programs and returns the data updated in the database.
         * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
         * @example
         * // Update many Programs
         * const program = await prisma.program.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Programs and only return the `id`
         * const programWithIdOnly = await prisma.program.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(
            args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Program.
         * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
         * @example
         * // Update or create a Program
         * const program = await prisma.program.upsert({
         *   create: {
         *     // ... data to create a Program
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Program we want to update
         *   }
         * })
         */
        upsert<T extends ProgramUpsertArgs>(
            args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>,
        ): Prisma__ProgramClient<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Programs.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
         * @example
         * // Count the number of Programs
         * const count = await prisma.program.count({
         *   where: {
         *     // ... the filter for the Programs we want to count
         *   }
         * })
         **/
        count<T extends ProgramCountArgs>(
            args?: Subset<T, ProgramCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], ProgramCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Program.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends ProgramAggregateArgs>(
            args: Subset<T, ProgramAggregateArgs>,
        ): Prisma.PrismaPromise<GetProgramAggregateType<T>>;

        /**
         * Group by Program.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {ProgramGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends ProgramGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: ProgramGroupByArgs['orderBy'] }
                : { orderBy?: ProgramGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Program model
         */
        readonly fields: ProgramFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Program.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__ProgramClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        university<T extends UniversityDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, UniversityDefaultArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        faculty<T extends Program$facultyArgs<ExtArgs> = {}>(
            args?: Subset<T, Program$facultyArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        certificateRequirement<T extends Program$certificateRequirementArgs<ExtArgs> = {}>(
            args?: Subset<T, Program$certificateRequirementArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findUniqueOrThrow',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Program model
     */
    interface ProgramFieldRefs {
        readonly id: FieldRef<'Program', 'String'>;
        readonly createdAt: FieldRef<'Program', 'DateTime'>;
        readonly createdBy: FieldRef<'Program', 'String'>;
        readonly updatedAt: FieldRef<'Program', 'DateTime'>;
        readonly updatedBy: FieldRef<'Program', 'String'>;
        readonly title: FieldRef<'Program', 'String'>;
        readonly studyLanguage: FieldRef<'Program', 'StudyLanguage'>;
        readonly contract: FieldRef<'Program', 'Int'>;
        readonly degree: FieldRef<'Program', 'Degree'>;
        readonly certificateRequirementId: FieldRef<'Program', 'String'>;
        readonly studyType: FieldRef<'Program', 'StudyType'>;
        readonly universityId: FieldRef<'Program', 'String'>;
        readonly facultyId: FieldRef<'Program', 'String'>;
    }

    // Custom InputTypes
    /**
     * Program findUnique
     */
    export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter, which Program to fetch.
         */
        where: ProgramWhereUniqueInput;
    };

    /**
     * Program findUniqueOrThrow
     */
    export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter, which Program to fetch.
         */
        where: ProgramWhereUniqueInput;
    };

    /**
     * Program findFirst
     */
    export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter, which Program to fetch.
         */
        where?: ProgramWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Programs to fetch.
         */
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Programs.
         */
        cursor?: ProgramWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Programs from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Programs.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Programs.
         */
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * Program findFirstOrThrow
     */
    export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter, which Program to fetch.
         */
        where?: ProgramWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Programs to fetch.
         */
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Programs.
         */
        cursor?: ProgramWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Programs from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Programs.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Programs.
         */
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * Program findMany
     */
    export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter, which Programs to fetch.
         */
        where?: ProgramWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Programs to fetch.
         */
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Programs.
         */
        cursor?: ProgramWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Programs from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Programs.
         */
        skip?: number;
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * Program create
     */
    export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * The data needed to create a Program.
         */
        data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>;
    };

    /**
     * Program createMany
     */
    export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Programs.
         */
        data: ProgramCreateManyInput | ProgramCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Program createManyAndReturn
     */
    export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * The data used to create many Programs.
         */
        data: ProgramCreateManyInput | ProgramCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * Program update
     */
    export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * The data needed to update a Program.
         */
        data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>;
        /**
         * Choose, which Program to update.
         */
        where: ProgramWhereUniqueInput;
    };

    /**
     * Program updateMany
     */
    export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Programs.
         */
        data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>;
        /**
         * Filter which Programs to update
         */
        where?: ProgramWhereInput;
        /**
         * Limit how many Programs to update.
         */
        limit?: number;
    };

    /**
     * Program updateManyAndReturn
     */
    export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * The data used to update Programs.
         */
        data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>;
        /**
         * Filter which Programs to update
         */
        where?: ProgramWhereInput;
        /**
         * Limit how many Programs to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * Program upsert
     */
    export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * The filter to search for the Program to update in case it exists.
         */
        where: ProgramWhereUniqueInput;
        /**
         * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
         */
        create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>;
        /**
         * In case the Program was found with the provided `where` argument, update it with this data.
         */
        update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>;
    };

    /**
     * Program delete
     */
    export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        /**
         * Filter which Program to delete.
         */
        where: ProgramWhereUniqueInput;
    };

    /**
     * Program deleteMany
     */
    export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Programs to delete
         */
        where?: ProgramWhereInput;
        /**
         * Limit how many Programs to delete.
         */
        limit?: number;
    };

    /**
     * Program.faculty
     */
    export type Program$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        where?: FacultyWhereInput;
    };

    /**
     * Program.certificateRequirement
     */
    export type Program$certificateRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
            where?: CertificateRequirementsWhereInput;
        };

    /**
     * Program without action
     */
    export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
    };

    /**
     * Model Faculty
     */

    export type AggregateFaculty = {
        _count: FacultyCountAggregateOutputType | null;
        _min: FacultyMinAggregateOutputType | null;
        _max: FacultyMaxAggregateOutputType | null;
    };

    export type FacultyMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        facultyTitle: string | null;
        description: string | null;
        universityId: string | null;
    };

    export type FacultyMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        facultyTitle: string | null;
        description: string | null;
        universityId: string | null;
    };

    export type FacultyCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        facultyTitle: number;
        description: number;
        universityId: number;
        _all: number;
    };

    export type FacultyMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        facultyTitle?: true;
        description?: true;
        universityId?: true;
    };

    export type FacultyMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        facultyTitle?: true;
        description?: true;
        universityId?: true;
    };

    export type FacultyCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        facultyTitle?: true;
        description?: true;
        universityId?: true;
        _all?: true;
    };

    export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Faculty to aggregate.
         */
        where?: FacultyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Faculties to fetch.
         */
        orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: FacultyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Faculties from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Faculties.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Faculties
         **/
        _count?: true | FacultyCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: FacultyMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: FacultyMaxAggregateInputType;
    };

    export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFaculty[P]>
            : GetScalarType<T[P], AggregateFaculty[P]>;
    };

    export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        where?: FacultyWhereInput;
        orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[];
        by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum;
        having?: FacultyScalarWhereWithAggregatesInput;
        take?: number;
        skip?: number;
        _count?: FacultyCountAggregateInputType | true;
        _min?: FacultyMinAggregateInputType;
        _max?: FacultyMaxAggregateInputType;
    };

    export type FacultyGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string | null;
        updatedAt: Date;
        updatedBy: string | null;
        facultyTitle: string;
        description: string | null;
        universityId: string;
        _count: FacultyCountAggregateOutputType | null;
        _min: FacultyMinAggregateOutputType | null;
        _max: FacultyMaxAggregateOutputType | null;
    };

    type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<FacultyGroupByOutputType, T['by']> & {
                [P in keyof T & keyof FacultyGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], FacultyGroupByOutputType[P]>
                    : GetScalarType<T[P], FacultyGroupByOutputType[P]>;
            }
        >
    >;

    export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                facultyTitle?: boolean;
                description?: boolean;
                universityId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
                programs?: boolean | Faculty$programsArgs<ExtArgs>;
                _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['faculty']
        >;

    export type FacultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                facultyTitle?: boolean;
                description?: boolean;
                universityId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['faculty']
        >;

    export type FacultySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                facultyTitle?: boolean;
                description?: boolean;
                universityId?: boolean;
                university?: boolean | UniversityDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['faculty']
        >;

    export type FacultySelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        facultyTitle?: boolean;
        description?: boolean;
        universityId?: boolean;
    };

    export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
        'id' | 'createdAt' | 'createdBy' | 'updatedAt' | 'updatedBy' | 'facultyTitle' | 'description' | 'universityId',
        ExtArgs['result']['faculty']
    >;
    export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        university?: boolean | UniversityDefaultArgs<ExtArgs>;
        programs?: boolean | Faculty$programsArgs<ExtArgs>;
        _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type FacultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            university?: boolean | UniversityDefaultArgs<ExtArgs>;
        };
    export type FacultyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            university?: boolean | UniversityDefaultArgs<ExtArgs>;
        };

    export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'Faculty';
        objects: {
            university: Prisma.$UniversityPayload<ExtArgs>;
            programs: Prisma.$ProgramPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string | null;
                updatedAt: Date;
                updatedBy: string | null;
                facultyTitle: string;
                description: string | null;
                universityId: string;
            },
            ExtArgs['result']['faculty']
        >;
        composites: {};
    };

    type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<
        Prisma.$FacultyPayload,
        S
    >;

    type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        FacultyFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: FacultyCountAggregateInputType | true;
    };

    export interface FacultyDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty']; meta: { name: 'Faculty' } };
        /**
         * Find zero or one Faculty that matches the filter.
         * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
         * @example
         * // Get one Faculty
         * const faculty = await prisma.faculty.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends FacultyFindUniqueArgs>(
            args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
         * @example
         * // Get one Faculty
         * const faculty = await prisma.faculty.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(
            args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Faculty that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
         * @example
         * // Get one Faculty
         * const faculty = await prisma.faculty.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends FacultyFindFirstArgs>(
            args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first Faculty that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
         * @example
         * // Get one Faculty
         * const faculty = await prisma.faculty.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(
            args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more Faculties that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Faculties
         * const faculties = await prisma.faculty.findMany()
         *
         * // Get first 10 Faculties
         * const faculties = await prisma.faculty.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
         *
         */
        findMany<T extends FacultyFindManyArgs>(
            args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

        /**
         * Create a Faculty.
         * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
         * @example
         * // Create one Faculty
         * const Faculty = await prisma.faculty.create({
         *   data: {
         *     // ... data to create a Faculty
         *   }
         * })
         *
         */
        create<T extends FacultyCreateArgs>(
            args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many Faculties.
         * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
         * @example
         * // Create many Faculties
         * const faculty = await prisma.faculty.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends FacultyCreateManyArgs>(
            args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many Faculties and returns the data saved in the database.
         * @param {FacultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
         * @example
         * // Create many Faculties
         * const faculty = await prisma.faculty.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many Faculties and only return the `id`
         * const facultyWithIdOnly = await prisma.faculty.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends FacultyCreateManyAndReturnArgs>(
            args?: SelectSubset<T, FacultyCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Delete a Faculty.
         * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
         * @example
         * // Delete one Faculty
         * const Faculty = await prisma.faculty.delete({
         *   where: {
         *     // ... filter to delete one Faculty
         *   }
         * })
         *
         */
        delete<T extends FacultyDeleteArgs>(
            args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one Faculty.
         * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
         * @example
         * // Update one Faculty
         * const faculty = await prisma.faculty.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends FacultyUpdateArgs>(
            args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more Faculties.
         * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
         * @example
         * // Delete a few Faculties
         * const { count } = await prisma.faculty.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends FacultyDeleteManyArgs>(
            args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Faculties.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Faculties
         * const faculty = await prisma.faculty.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends FacultyUpdateManyArgs>(
            args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more Faculties and returns the data updated in the database.
         * @param {FacultyUpdateManyAndReturnArgs} args - Arguments to update many Faculties.
         * @example
         * // Update many Faculties
         * const faculty = await prisma.faculty.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more Faculties and only return the `id`
         * const facultyWithIdOnly = await prisma.faculty.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends FacultyUpdateManyAndReturnArgs>(
            args: SelectSubset<T, FacultyUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
        >;

        /**
         * Create or update one Faculty.
         * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
         * @example
         * // Update or create a Faculty
         * const faculty = await prisma.faculty.upsert({
         *   create: {
         *     // ... data to create a Faculty
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Faculty we want to update
         *   }
         * })
         */
        upsert<T extends FacultyUpsertArgs>(
            args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>,
        ): Prisma__FacultyClient<
            $Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of Faculties.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
         * @example
         * // Count the number of Faculties
         * const count = await prisma.faculty.count({
         *   where: {
         *     // ... the filter for the Faculties we want to count
         *   }
         * })
         **/
        count<T extends FacultyCountArgs>(
            args?: Subset<T, FacultyCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], FacultyCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a Faculty.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends FacultyAggregateArgs>(
            args: Subset<T, FacultyAggregateArgs>,
        ): Prisma.PrismaPromise<GetFacultyAggregateType<T>>;

        /**
         * Group by Faculty.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FacultyGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends FacultyGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: FacultyGroupByArgs['orderBy'] }
                : { orderBy?: FacultyGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the Faculty model
         */
        readonly fields: FacultyFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for Faculty.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__FacultyClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        university<T extends UniversityDefaultArgs<ExtArgs> = {}>(
            args?: Subset<T, UniversityDefaultArgs<ExtArgs>>,
        ): Prisma__UniversityClient<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
            Null,
            ExtArgs,
            GlobalOmitOptions
        >;
        programs<T extends Faculty$programsArgs<ExtArgs> = {}>(
            args?: Subset<T, Faculty$programsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the Faculty model
     */
    interface FacultyFieldRefs {
        readonly id: FieldRef<'Faculty', 'String'>;
        readonly createdAt: FieldRef<'Faculty', 'DateTime'>;
        readonly createdBy: FieldRef<'Faculty', 'String'>;
        readonly updatedAt: FieldRef<'Faculty', 'DateTime'>;
        readonly updatedBy: FieldRef<'Faculty', 'String'>;
        readonly facultyTitle: FieldRef<'Faculty', 'String'>;
        readonly description: FieldRef<'Faculty', 'String'>;
        readonly universityId: FieldRef<'Faculty', 'String'>;
    }

    // Custom InputTypes
    /**
     * Faculty findUnique
     */
    export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter, which Faculty to fetch.
         */
        where: FacultyWhereUniqueInput;
    };

    /**
     * Faculty findUniqueOrThrow
     */
    export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter, which Faculty to fetch.
         */
        where: FacultyWhereUniqueInput;
    };

    /**
     * Faculty findFirst
     */
    export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter, which Faculty to fetch.
         */
        where?: FacultyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Faculties to fetch.
         */
        orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Faculties.
         */
        cursor?: FacultyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Faculties from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Faculties.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Faculties.
         */
        distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
    };

    /**
     * Faculty findFirstOrThrow
     */
    export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter, which Faculty to fetch.
         */
        where?: FacultyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Faculties to fetch.
         */
        orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Faculties.
         */
        cursor?: FacultyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Faculties from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Faculties.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Faculties.
         */
        distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
    };

    /**
     * Faculty findMany
     */
    export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter, which Faculties to fetch.
         */
        where?: FacultyWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Faculties to fetch.
         */
        orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Faculties.
         */
        cursor?: FacultyWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Faculties from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Faculties.
         */
        skip?: number;
        distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[];
    };

    /**
     * Faculty create
     */
    export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * The data needed to create a Faculty.
         */
        data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>;
    };

    /**
     * Faculty createMany
     */
    export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to create many Faculties.
         */
        data: FacultyCreateManyInput | FacultyCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * Faculty createManyAndReturn
     */
    export type FacultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * The data used to create many Faculties.
         */
        data: FacultyCreateManyInput | FacultyCreateManyInput[];
        skipDuplicates?: boolean;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyIncludeCreateManyAndReturn<ExtArgs> | null;
    };

    /**
     * Faculty update
     */
    export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * The data needed to update a Faculty.
         */
        data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>;
        /**
         * Choose, which Faculty to update.
         */
        where: FacultyWhereUniqueInput;
    };

    /**
     * Faculty updateMany
     */
    export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * The data used to update Faculties.
         */
        data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>;
        /**
         * Filter which Faculties to update
         */
        where?: FacultyWhereInput;
        /**
         * Limit how many Faculties to update.
         */
        limit?: number;
    };

    /**
     * Faculty updateManyAndReturn
     */
    export type FacultyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * The data used to update Faculties.
         */
        data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>;
        /**
         * Filter which Faculties to update
         */
        where?: FacultyWhereInput;
        /**
         * Limit how many Faculties to update.
         */
        limit?: number;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

    /**
     * Faculty upsert
     */
    export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * The filter to search for the Faculty to update in case it exists.
         */
        where: FacultyWhereUniqueInput;
        /**
         * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
         */
        create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>;
        /**
         * In case the Faculty was found with the provided `where` argument, update it with this data.
         */
        update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>;
    };

    /**
     * Faculty delete
     */
    export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
        /**
         * Filter which Faculty to delete.
         */
        where: FacultyWhereUniqueInput;
    };

    /**
     * Faculty deleteMany
     */
    export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Filter which Faculties to delete
         */
        where?: FacultyWhereInput;
        /**
         * Limit how many Faculties to delete.
         */
        limit?: number;
    };

    /**
     * Faculty.programs
     */
    export type Faculty$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        where?: ProgramWhereInput;
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        cursor?: ProgramWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * Faculty without action
     */
    export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        /**
         * Select specific fields to fetch from the Faculty
         */
        select?: FacultySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Faculty
         */
        omit?: FacultyOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: FacultyInclude<ExtArgs> | null;
    };

    /**
     * Model CertificateRequirements
     */

    export type AggregateCertificateRequirements = {
        _count: CertificateRequirementsCountAggregateOutputType | null;
        _min: CertificateRequirementsMinAggregateOutputType | null;
        _max: CertificateRequirementsMaxAggregateOutputType | null;
    };

    export type CertificateRequirementsMinAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        certificateRequirementsTitle: string | null;
        description: string | null;
    };

    export type CertificateRequirementsMaxAggregateOutputType = {
        id: string | null;
        createdAt: Date | null;
        createdBy: string | null;
        updatedAt: Date | null;
        updatedBy: string | null;
        certificateRequirementsTitle: string | null;
        description: string | null;
    };

    export type CertificateRequirementsCountAggregateOutputType = {
        id: number;
        createdAt: number;
        createdBy: number;
        updatedAt: number;
        updatedBy: number;
        certificateRequirementsTitle: number;
        description: number;
        _all: number;
    };

    export type CertificateRequirementsMinAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        certificateRequirementsTitle?: true;
        description?: true;
    };

    export type CertificateRequirementsMaxAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        certificateRequirementsTitle?: true;
        description?: true;
    };

    export type CertificateRequirementsCountAggregateInputType = {
        id?: true;
        createdAt?: true;
        createdBy?: true;
        updatedAt?: true;
        updatedBy?: true;
        certificateRequirementsTitle?: true;
        description?: true;
        _all?: true;
    };

    export type CertificateRequirementsAggregateArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which CertificateRequirements to aggregate.
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CertificateRequirements to fetch.
         */
        orderBy?: CertificateRequirementsOrderByWithRelationInput | CertificateRequirementsOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         */
        cursor?: CertificateRequirementsWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CertificateRequirements from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CertificateRequirements.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned CertificateRequirements
         **/
        _count?: true | CertificateRequirementsCountAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CertificateRequirementsMinAggregateInputType;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CertificateRequirementsMaxAggregateInputType;
    };

    export type GetCertificateRequirementsAggregateType<T extends CertificateRequirementsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificateRequirements]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCertificateRequirements[P]>
            : GetScalarType<T[P], AggregateCertificateRequirements[P]>;
    };

    export type CertificateRequirementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            where?: CertificateRequirementsWhereInput;
            orderBy?:
                | CertificateRequirementsOrderByWithAggregationInput
                | CertificateRequirementsOrderByWithAggregationInput[];
            by: CertificateRequirementsScalarFieldEnum[] | CertificateRequirementsScalarFieldEnum;
            having?: CertificateRequirementsScalarWhereWithAggregatesInput;
            take?: number;
            skip?: number;
            _count?: CertificateRequirementsCountAggregateInputType | true;
            _min?: CertificateRequirementsMinAggregateInputType;
            _max?: CertificateRequirementsMaxAggregateInputType;
        };

    export type CertificateRequirementsGroupByOutputType = {
        id: string;
        createdAt: Date;
        createdBy: string | null;
        updatedAt: Date;
        updatedBy: string | null;
        certificateRequirementsTitle: string;
        description: string | null;
        _count: CertificateRequirementsCountAggregateOutputType | null;
        _min: CertificateRequirementsMinAggregateOutputType | null;
        _max: CertificateRequirementsMaxAggregateOutputType | null;
    };

    type GetCertificateRequirementsGroupByPayload<T extends CertificateRequirementsGroupByArgs> = Prisma.PrismaPromise<
        Array<
            PickEnumerable<CertificateRequirementsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CertificateRequirementsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CertificateRequirementsGroupByOutputType[P]>
                    : GetScalarType<T[P], CertificateRequirementsGroupByOutputType[P]>;
            }
        >
    >;

    export type CertificateRequirementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetSelect<
            {
                id?: boolean;
                createdAt?: boolean;
                createdBy?: boolean;
                updatedAt?: boolean;
                updatedBy?: boolean;
                certificateRequirementsTitle?: boolean;
                description?: boolean;
                universities?: boolean | CertificateRequirements$universitiesArgs<ExtArgs>;
                programs?: boolean | CertificateRequirements$programsArgs<ExtArgs>;
                _count?: boolean | CertificateRequirementsCountOutputTypeDefaultArgs<ExtArgs>;
            },
            ExtArgs['result']['certificateRequirements']
        >;

    export type CertificateRequirementsSelectCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            certificateRequirementsTitle?: boolean;
            description?: boolean;
        },
        ExtArgs['result']['certificateRequirements']
    >;

    export type CertificateRequirementsSelectUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = $Extensions.GetSelect<
        {
            id?: boolean;
            createdAt?: boolean;
            createdBy?: boolean;
            updatedAt?: boolean;
            updatedBy?: boolean;
            certificateRequirementsTitle?: boolean;
            description?: boolean;
        },
        ExtArgs['result']['certificateRequirements']
    >;

    export type CertificateRequirementsSelectScalar = {
        id?: boolean;
        createdAt?: boolean;
        createdBy?: boolean;
        updatedAt?: boolean;
        updatedBy?: boolean;
        certificateRequirementsTitle?: boolean;
        description?: boolean;
    };

    export type CertificateRequirementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        $Extensions.GetOmit<
            | 'id'
            | 'createdAt'
            | 'createdBy'
            | 'updatedAt'
            | 'updatedBy'
            | 'certificateRequirementsTitle'
            | 'description',
            ExtArgs['result']['certificateRequirements']
        >;
    export type CertificateRequirementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        universities?: boolean | CertificateRequirements$universitiesArgs<ExtArgs>;
        programs?: boolean | CertificateRequirements$programsArgs<ExtArgs>;
        _count?: boolean | CertificateRequirementsCountOutputTypeDefaultArgs<ExtArgs>;
    };
    export type CertificateRequirementsIncludeCreateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {};
    export type CertificateRequirementsIncludeUpdateManyAndReturn<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {};

    export type $CertificateRequirementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
        name: 'CertificateRequirements';
        objects: {
            universities: Prisma.$UniversityPayload<ExtArgs>[];
            programs: Prisma.$ProgramPayload<ExtArgs>[];
        };
        scalars: $Extensions.GetPayloadResult<
            {
                id: string;
                createdAt: Date;
                createdBy: string | null;
                updatedAt: Date;
                updatedBy: string | null;
                certificateRequirementsTitle: string;
                description: string | null;
            },
            ExtArgs['result']['certificateRequirements']
        >;
        composites: {};
    };

    type CertificateRequirementsGetPayload<S extends boolean | null | undefined | CertificateRequirementsDefaultArgs> =
        $Result.GetResult<Prisma.$CertificateRequirementsPayload, S>;

    type CertificateRequirementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
        CertificateRequirementsFindManyArgs,
        'select' | 'include' | 'distinct' | 'omit'
    > & {
        select?: CertificateRequirementsCountAggregateInputType | true;
    };

    export interface CertificateRequirementsDelegate<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > {
        [K: symbol]: {
            types: Prisma.TypeMap<ExtArgs>['model']['CertificateRequirements'];
            meta: { name: 'CertificateRequirements' };
        };
        /**
         * Find zero or one CertificateRequirements that matches the filter.
         * @param {CertificateRequirementsFindUniqueArgs} args - Arguments to find a CertificateRequirements
         * @example
         * // Get one CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUnique<T extends CertificateRequirementsFindUniqueArgs>(
            args: SelectSubset<T, CertificateRequirementsFindUniqueArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findUnique',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find one CertificateRequirements that matches the filter or throw an error with `error.code='P2025'`
         * if no matches were found.
         * @param {CertificateRequirementsFindUniqueOrThrowArgs} args - Arguments to find a CertificateRequirements
         * @example
         * // Get one CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findUniqueOrThrow<T extends CertificateRequirementsFindUniqueOrThrowArgs>(
            args: SelectSubset<T, CertificateRequirementsFindUniqueOrThrowArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findUniqueOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CertificateRequirements that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsFindFirstArgs} args - Arguments to find a CertificateRequirements
         * @example
         * // Get one CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirst<T extends CertificateRequirementsFindFirstArgs>(
            args?: SelectSubset<T, CertificateRequirementsFindFirstArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findFirst',
                GlobalOmitOptions
            > | null,
            null,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find the first CertificateRequirements that matches the filter or
         * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsFindFirstOrThrowArgs} args - Arguments to find a CertificateRequirements
         * @example
         * // Get one CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         */
        findFirstOrThrow<T extends CertificateRequirementsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CertificateRequirementsFindFirstOrThrowArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'findFirstOrThrow',
                GlobalOmitOptions
            >,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Find zero or more CertificateRequirements that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsFindManyArgs} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findMany()
         *
         * // Get first 10 CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const certificateRequirementsWithIdOnly = await prisma.certificateRequirements.findMany({ select: { id: true } })
         *
         */
        findMany<T extends CertificateRequirementsFindManyArgs>(
            args?: SelectSubset<T, CertificateRequirementsFindManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$CertificateRequirementsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
        >;

        /**
         * Create a CertificateRequirements.
         * @param {CertificateRequirementsCreateArgs} args - Arguments to create a CertificateRequirements.
         * @example
         * // Create one CertificateRequirements
         * const CertificateRequirements = await prisma.certificateRequirements.create({
         *   data: {
         *     // ... data to create a CertificateRequirements
         *   }
         * })
         *
         */
        create<T extends CertificateRequirementsCreateArgs>(
            args: SelectSubset<T, CertificateRequirementsCreateArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<Prisma.$CertificateRequirementsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Create many CertificateRequirements.
         * @param {CertificateRequirementsCreateManyArgs} args - Arguments to create many CertificateRequirements.
         * @example
         * // Create many CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.createMany({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         */
        createMany<T extends CertificateRequirementsCreateManyArgs>(
            args?: SelectSubset<T, CertificateRequirementsCreateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Create many CertificateRequirements and returns the data saved in the database.
         * @param {CertificateRequirementsCreateManyAndReturnArgs} args - Arguments to create many CertificateRequirements.
         * @example
         * // Create many CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.createManyAndReturn({
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Create many CertificateRequirements and only return the `id`
         * const certificateRequirementsWithIdOnly = await prisma.certificateRequirements.createManyAndReturn({
         *   select: { id: true },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        createManyAndReturn<T extends CertificateRequirementsCreateManyAndReturnArgs>(
            args?: SelectSubset<T, CertificateRequirementsCreateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'createManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Delete a CertificateRequirements.
         * @param {CertificateRequirementsDeleteArgs} args - Arguments to delete one CertificateRequirements.
         * @example
         * // Delete one CertificateRequirements
         * const CertificateRequirements = await prisma.certificateRequirements.delete({
         *   where: {
         *     // ... filter to delete one CertificateRequirements
         *   }
         * })
         *
         */
        delete<T extends CertificateRequirementsDeleteArgs>(
            args: SelectSubset<T, CertificateRequirementsDeleteArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<Prisma.$CertificateRequirementsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Update one CertificateRequirements.
         * @param {CertificateRequirementsUpdateArgs} args - Arguments to update one CertificateRequirements.
         * @example
         * // Update one CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        update<T extends CertificateRequirementsUpdateArgs>(
            args: SelectSubset<T, CertificateRequirementsUpdateArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<Prisma.$CertificateRequirementsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Delete zero or more CertificateRequirements.
         * @param {CertificateRequirementsDeleteManyArgs} args - Arguments to filter CertificateRequirements to delete.
         * @example
         * // Delete a few CertificateRequirements
         * const { count } = await prisma.certificateRequirements.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         */
        deleteMany<T extends CertificateRequirementsDeleteManyArgs>(
            args?: SelectSubset<T, CertificateRequirementsDeleteManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CertificateRequirements.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         */
        updateMany<T extends CertificateRequirementsUpdateManyArgs>(
            args: SelectSubset<T, CertificateRequirementsUpdateManyArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<BatchPayload>;

        /**
         * Update zero or more CertificateRequirements and returns the data updated in the database.
         * @param {CertificateRequirementsUpdateManyAndReturnArgs} args - Arguments to update many CertificateRequirements.
         * @example
         * // Update many CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.updateManyAndReturn({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         *
         * // Update zero or more CertificateRequirements and only return the `id`
         * const certificateRequirementsWithIdOnly = await prisma.certificateRequirements.updateManyAndReturn({
         *   select: { id: true },
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: [
         *     // ... provide data here
         *   ]
         * })
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         *
         */
        updateManyAndReturn<T extends CertificateRequirementsUpdateManyAndReturnArgs>(
            args: SelectSubset<T, CertificateRequirementsUpdateManyAndReturnArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<
                Prisma.$CertificateRequirementsPayload<ExtArgs>,
                T,
                'updateManyAndReturn',
                GlobalOmitOptions
            >
        >;

        /**
         * Create or update one CertificateRequirements.
         * @param {CertificateRequirementsUpsertArgs} args - Arguments to update or create a CertificateRequirements.
         * @example
         * // Update or create a CertificateRequirements
         * const certificateRequirements = await prisma.certificateRequirements.upsert({
         *   create: {
         *     // ... data to create a CertificateRequirements
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the CertificateRequirements we want to update
         *   }
         * })
         */
        upsert<T extends CertificateRequirementsUpsertArgs>(
            args: SelectSubset<T, CertificateRequirementsUpsertArgs<ExtArgs>>,
        ): Prisma__CertificateRequirementsClient<
            $Result.GetResult<Prisma.$CertificateRequirementsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
            never,
            ExtArgs,
            GlobalOmitOptions
        >;

        /**
         * Count the number of CertificateRequirements.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsCountArgs} args - Arguments to filter CertificateRequirements to count.
         * @example
         * // Count the number of CertificateRequirements
         * const count = await prisma.certificateRequirements.count({
         *   where: {
         *     // ... the filter for the CertificateRequirements we want to count
         *   }
         * })
         **/
        count<T extends CertificateRequirementsCountArgs>(
            args?: Subset<T, CertificateRequirementsCountArgs>,
        ): Prisma.PrismaPromise<
            T extends $Utils.Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CertificateRequirementsCountAggregateOutputType>
                : number
        >;

        /**
         * Allows you to perform aggregations operations on a CertificateRequirements.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CertificateRequirementsAggregateArgs>(
            args: Subset<T, CertificateRequirementsAggregateArgs>,
        ): Prisma.PrismaPromise<GetCertificateRequirementsAggregateType<T>>;

        /**
         * Group by CertificateRequirements.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CertificateRequirementsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CertificateRequirementsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CertificateRequirementsGroupByArgs['orderBy'] }
                : { orderBy?: CertificateRequirementsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends MaybeTupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields],
        >(
            args: SubsetIntersection<T, CertificateRequirementsGroupByArgs, OrderByArg> & InputErrors,
        ): {} extends InputErrors ? GetCertificateRequirementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
        /**
         * Fields of the CertificateRequirements model
         */
        readonly fields: CertificateRequirementsFieldRefs;
    }

    /**
     * The delegate class that acts as a "Promise-like" for CertificateRequirements.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export interface Prisma__CertificateRequirementsClient<
        T,
        Null = never,
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
        GlobalOmitOptions = {},
    > extends Prisma.PrismaPromise<T> {
        readonly [Symbol.toStringTag]: 'PrismaPromise';
        universities<T extends CertificateRequirements$universitiesArgs<ExtArgs> = {}>(
            args?: Subset<T, CertificateRequirements$universitiesArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        programs<T extends CertificateRequirements$programsArgs<ExtArgs> = {}>(
            args?: Subset<T, CertificateRequirements$programsArgs<ExtArgs>>,
        ): Prisma.PrismaPromise<
            $Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
        >;
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): $Utils.JsPromise<TResult1 | TResult2>;
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
        ): $Utils.JsPromise<T | TResult>;
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
    }

    /**
     * Fields of the CertificateRequirements model
     */
    interface CertificateRequirementsFieldRefs {
        readonly id: FieldRef<'CertificateRequirements', 'String'>;
        readonly createdAt: FieldRef<'CertificateRequirements', 'DateTime'>;
        readonly createdBy: FieldRef<'CertificateRequirements', 'String'>;
        readonly updatedAt: FieldRef<'CertificateRequirements', 'DateTime'>;
        readonly updatedBy: FieldRef<'CertificateRequirements', 'String'>;
        readonly certificateRequirementsTitle: FieldRef<'CertificateRequirements', 'String'>;
        readonly description: FieldRef<'CertificateRequirements', 'String'>;
    }

    // Custom InputTypes
    /**
     * CertificateRequirements findUnique
     */
    export type CertificateRequirementsFindUniqueArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        /**
         * Filter, which CertificateRequirements to fetch.
         */
        where: CertificateRequirementsWhereUniqueInput;
    };

    /**
     * CertificateRequirements findUniqueOrThrow
     */
    export type CertificateRequirementsFindUniqueOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        /**
         * Filter, which CertificateRequirements to fetch.
         */
        where: CertificateRequirementsWhereUniqueInput;
    };

    /**
     * CertificateRequirements findFirst
     */
    export type CertificateRequirementsFindFirstArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        /**
         * Filter, which CertificateRequirements to fetch.
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CertificateRequirements to fetch.
         */
        orderBy?: CertificateRequirementsOrderByWithRelationInput | CertificateRequirementsOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CertificateRequirements.
         */
        cursor?: CertificateRequirementsWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CertificateRequirements from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CertificateRequirements.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CertificateRequirements.
         */
        distinct?: CertificateRequirementsScalarFieldEnum | CertificateRequirementsScalarFieldEnum[];
    };

    /**
     * CertificateRequirements findFirstOrThrow
     */
    export type CertificateRequirementsFindFirstOrThrowArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        /**
         * Filter, which CertificateRequirements to fetch.
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CertificateRequirements to fetch.
         */
        orderBy?: CertificateRequirementsOrderByWithRelationInput | CertificateRequirementsOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for CertificateRequirements.
         */
        cursor?: CertificateRequirementsWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CertificateRequirements from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CertificateRequirements.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of CertificateRequirements.
         */
        distinct?: CertificateRequirementsScalarFieldEnum | CertificateRequirementsScalarFieldEnum[];
    };

    /**
     * CertificateRequirements findMany
     */
    export type CertificateRequirementsFindManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: CertificateRequirementsInclude<ExtArgs> | null;
        /**
         * Filter, which CertificateRequirements to fetch.
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of CertificateRequirements to fetch.
         */
        orderBy?: CertificateRequirementsOrderByWithRelationInput | CertificateRequirementsOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing CertificateRequirements.
         */
        cursor?: CertificateRequirementsWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` CertificateRequirements from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` CertificateRequirements.
         */
        skip?: number;
        distinct?: CertificateRequirementsScalarFieldEnum | CertificateRequirementsScalarFieldEnum[];
    };

    /**
     * CertificateRequirements create
     */
    export type CertificateRequirementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
            /**
             * The data needed to create a CertificateRequirements.
             */
            data: XOR<CertificateRequirementsCreateInput, CertificateRequirementsUncheckedCreateInput>;
        };

    /**
     * CertificateRequirements createMany
     */
    export type CertificateRequirementsCreateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to create many CertificateRequirements.
         */
        data: CertificateRequirementsCreateManyInput | CertificateRequirementsCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * CertificateRequirements createManyAndReturn
     */
    export type CertificateRequirementsCreateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelectCreateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * The data used to create many CertificateRequirements.
         */
        data: CertificateRequirementsCreateManyInput | CertificateRequirementsCreateManyInput[];
        skipDuplicates?: boolean;
    };

    /**
     * CertificateRequirements update
     */
    export type CertificateRequirementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
            /**
             * The data needed to update a CertificateRequirements.
             */
            data: XOR<CertificateRequirementsUpdateInput, CertificateRequirementsUncheckedUpdateInput>;
            /**
             * Choose, which CertificateRequirements to update.
             */
            where: CertificateRequirementsWhereUniqueInput;
        };

    /**
     * CertificateRequirements updateMany
     */
    export type CertificateRequirementsUpdateManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * The data used to update CertificateRequirements.
         */
        data: XOR<CertificateRequirementsUpdateManyMutationInput, CertificateRequirementsUncheckedUpdateManyInput>;
        /**
         * Filter which CertificateRequirements to update
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * Limit how many CertificateRequirements to update.
         */
        limit?: number;
    };

    /**
     * CertificateRequirements updateManyAndReturn
     */
    export type CertificateRequirementsUpdateManyAndReturnArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the CertificateRequirements
         */
        select?: CertificateRequirementsSelectUpdateManyAndReturn<ExtArgs> | null;
        /**
         * Omit specific fields from the CertificateRequirements
         */
        omit?: CertificateRequirementsOmit<ExtArgs> | null;
        /**
         * The data used to update CertificateRequirements.
         */
        data: XOR<CertificateRequirementsUpdateManyMutationInput, CertificateRequirementsUncheckedUpdateManyInput>;
        /**
         * Filter which CertificateRequirements to update
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * Limit how many CertificateRequirements to update.
         */
        limit?: number;
    };

    /**
     * CertificateRequirements upsert
     */
    export type CertificateRequirementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
            /**
             * The filter to search for the CertificateRequirements to update in case it exists.
             */
            where: CertificateRequirementsWhereUniqueInput;
            /**
             * In case the CertificateRequirements found by the `where` argument doesn't exist, create a new CertificateRequirements with this data.
             */
            create: XOR<CertificateRequirementsCreateInput, CertificateRequirementsUncheckedCreateInput>;
            /**
             * In case the CertificateRequirements was found with the provided `where` argument, update it with this data.
             */
            update: XOR<CertificateRequirementsUpdateInput, CertificateRequirementsUncheckedUpdateInput>;
        };

    /**
     * CertificateRequirements delete
     */
    export type CertificateRequirementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
            /**
             * Filter which CertificateRequirements to delete.
             */
            where: CertificateRequirementsWhereUniqueInput;
        };

    /**
     * CertificateRequirements deleteMany
     */
    export type CertificateRequirementsDeleteManyArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Filter which CertificateRequirements to delete
         */
        where?: CertificateRequirementsWhereInput;
        /**
         * Limit how many CertificateRequirements to delete.
         */
        limit?: number;
    };

    /**
     * CertificateRequirements.universities
     */
    export type CertificateRequirements$universitiesArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the University
         */
        select?: UniversitySelect<ExtArgs> | null;
        /**
         * Omit specific fields from the University
         */
        omit?: UniversityOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: UniversityInclude<ExtArgs> | null;
        where?: UniversityWhereInput;
        orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[];
        cursor?: UniversityWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[];
    };

    /**
     * CertificateRequirements.programs
     */
    export type CertificateRequirements$programsArgs<
        ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    > = {
        /**
         * Select specific fields to fetch from the Program
         */
        select?: ProgramSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the Program
         */
        omit?: ProgramOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: ProgramInclude<ExtArgs> | null;
        where?: ProgramWhereInput;
        orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[];
        cursor?: ProgramWhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[];
    };

    /**
     * CertificateRequirements without action
     */
    export type CertificateRequirementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
        {
            /**
             * Select specific fields to fetch from the CertificateRequirements
             */
            select?: CertificateRequirementsSelect<ExtArgs> | null;
            /**
             * Omit specific fields from the CertificateRequirements
             */
            omit?: CertificateRequirementsOmit<ExtArgs> | null;
            /**
             * Choose, which related nodes to fetch as well
             */
            include?: CertificateRequirementsInclude<ExtArgs> | null;
        };

    /**
     * Enums
     */

    export const TransactionIsolationLevel: {
        ReadUncommitted: 'ReadUncommitted';
        ReadCommitted: 'ReadCommitted';
        RepeatableRead: 'RepeatableRead';
        Serializable: 'Serializable';
    };

    export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

    export const IeltsExamScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        dateExam: 'dateExam';
        cityId: 'cityId';
        isActive: 'isActive';
        commentUser: 'commentUser';
        commentAdmin: 'commentAdmin';
    };

    export type IeltsExamScalarFieldEnum = (typeof IeltsExamScalarFieldEnum)[keyof typeof IeltsExamScalarFieldEnum];

    export const IeltsRegistrationStudentScalarFieldEnum: {
        id: 'id';
        examId: 'examId';
        studentId: 'studentId';
        registeredAt: 'registeredAt';
    };

    export type IeltsRegistrationStudentScalarFieldEnum =
        (typeof IeltsRegistrationStudentScalarFieldEnum)[keyof typeof IeltsRegistrationStudentScalarFieldEnum];

    export const CityScalarFieldEnum: {
        id: 'id';
        name: 'name';
    };

    export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum];

    export const MockRegistrationScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        commentUser: 'commentUser';
        commentAdmin: 'commentAdmin';
        title: 'title';
        date: 'date';
        branchId: 'branchId';
        isActive: 'isActive';
    };

    export type MockRegistrationScalarFieldEnum =
        (typeof MockRegistrationScalarFieldEnum)[keyof typeof MockRegistrationScalarFieldEnum];

    export const MockRegistrationStudentScalarFieldEnum: {
        id: 'id';
        studentId: 'studentId';
        mockRegistrationId: 'mockRegistrationId';
        registeredAt: 'registeredAt';
    };

    export type MockRegistrationStudentScalarFieldEnum =
        (typeof MockRegistrationStudentScalarFieldEnum)[keyof typeof MockRegistrationStudentScalarFieldEnum];

    export const JobHuntingScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        title: 'title';
        description: 'description';
        workExperience: 'workExperience';
        companyId: 'companyId';
        cityId: 'cityId';
        certificateRequirements: 'certificateRequirements';
        workScheduleHours: 'workScheduleHours';
        employmentType: 'employmentType';
        workMode: 'workMode';
        salary: 'salary';
        responsibilities: 'responsibilities';
        requirements: 'requirements';
        conditions: 'conditions';
    };

    export type JobHuntingScalarFieldEnum = (typeof JobHuntingScalarFieldEnum)[keyof typeof JobHuntingScalarFieldEnum];

    export const CompanyScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        companyTitle: 'companyTitle';
        description: 'description';
        companyLogo: 'companyLogo';
    };

    export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum];

    export const CVScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        updatedAt: 'updatedAt';
        studentId: 'studentId';
        description: 'description';
        cityId: 'cityId';
        degree: 'degree';
        universityTitle: 'universityTitle';
        universityMajor: 'universityMajor';
        graduationYear: 'graduationYear';
        companyName: 'companyName';
        position: 'position';
        responsibilities: 'responsibilities';
        startDate: 'startDate';
        endDate: 'endDate';
    };

    export type CVScalarFieldEnum = (typeof CVScalarFieldEnum)[keyof typeof CVScalarFieldEnum];

    export const SkillScalarFieldEnum: {
        id: 'id';
        name: 'name';
    };

    export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum];

    export const ToolScalarFieldEnum: {
        id: 'id';
        name: 'name';
    };

    export type ToolScalarFieldEnum = (typeof ToolScalarFieldEnum)[keyof typeof ToolScalarFieldEnum];

    export const CvSkillScalarFieldEnum: {
        cvId: 'cvId';
        skillId: 'skillId';
    };

    export type CvSkillScalarFieldEnum = (typeof CvSkillScalarFieldEnum)[keyof typeof CvSkillScalarFieldEnum];

    export const CvToolScalarFieldEnum: {
        cvId: 'cvId';
        toolId: 'toolId';
    };

    export type CvToolScalarFieldEnum = (typeof CvToolScalarFieldEnum)[keyof typeof CvToolScalarFieldEnum];

    export const CertificateScalarFieldEnum: {
        id: 'id';
        name: 'name';
    };

    export type CertificateScalarFieldEnum =
        (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum];

    export const UniversityScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        title: 'title';
        description: 'description';
        registrationDate: 'registrationDate';
        type: 'type';
        status: 'status';
        contract: 'contract';
        contacts: 'contacts';
        website: 'website';
        email: 'email';
        address: 'address';
        cityId: 'cityId';
        logo: 'logo';
        license: 'license';
        certificateRequirementId: 'certificateRequirementId';
    };

    export type UniversityScalarFieldEnum = (typeof UniversityScalarFieldEnum)[keyof typeof UniversityScalarFieldEnum];

    export const ProgramScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        title: 'title';
        studyLanguage: 'studyLanguage';
        contract: 'contract';
        degree: 'degree';
        certificateRequirementId: 'certificateRequirementId';
        studyType: 'studyType';
        universityId: 'universityId';
        facultyId: 'facultyId';
    };

    export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum];

    export const FacultyScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        facultyTitle: 'facultyTitle';
        description: 'description';
        universityId: 'universityId';
    };

    export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum];

    export const CertificateRequirementsScalarFieldEnum: {
        id: 'id';
        createdAt: 'createdAt';
        createdBy: 'createdBy';
        updatedAt: 'updatedAt';
        updatedBy: 'updatedBy';
        certificateRequirementsTitle: 'certificateRequirementsTitle';
        description: 'description';
    };

    export type CertificateRequirementsScalarFieldEnum =
        (typeof CertificateRequirementsScalarFieldEnum)[keyof typeof CertificateRequirementsScalarFieldEnum];

    export const SortOrder: {
        asc: 'asc';
        desc: 'desc';
    };

    export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

    export const QueryMode: {
        default: 'default';
        insensitive: 'insensitive';
    };

    export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

    export const NullsOrder: {
        first: 'first';
        last: 'last';
    };

    export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

    /**
     * Field references
     */

    /**
     * Reference to a field of type 'String'
     */
    export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

    /**
     * Reference to a field of type 'String[]'
     */
    export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

    /**
     * Reference to a field of type 'DateTime'
     */
    export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

    /**
     * Reference to a field of type 'DateTime[]'
     */
    export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>;

    /**
     * Reference to a field of type 'Boolean'
     */
    export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

    /**
     * Reference to a field of type 'WorkExperience'
     */
    export type EnumWorkExperienceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkExperience'>;

    /**
     * Reference to a field of type 'WorkExperience[]'
     */
    export type ListEnumWorkExperienceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkExperience[]'>;

    /**
     * Reference to a field of type 'WorkScheduleHours'
     */
    export type EnumWorkScheduleHoursFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkScheduleHours'>;

    /**
     * Reference to a field of type 'WorkScheduleHours[]'
     */
    export type ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> = FieldRefInputType<
        $PrismaModel,
        'WorkScheduleHours[]'
    >;

    /**
     * Reference to a field of type 'EmploymentType'
     */
    export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>;

    /**
     * Reference to a field of type 'EmploymentType[]'
     */
    export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>;

    /**
     * Reference to a field of type 'WorkMode'
     */
    export type EnumWorkModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkMode'>;

    /**
     * Reference to a field of type 'WorkMode[]'
     */
    export type ListEnumWorkModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkMode[]'>;

    /**
     * Reference to a field of type 'Int'
     */
    export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

    /**
     * Reference to a field of type 'Int[]'
     */
    export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

    /**
     * Reference to a field of type 'Degree'
     */
    export type EnumDegreeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Degree'>;

    /**
     * Reference to a field of type 'Degree[]'
     */
    export type ListEnumDegreeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Degree[]'>;

    /**
     * Reference to a field of type 'UniType'
     */
    export type EnumUniTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UniType'>;

    /**
     * Reference to a field of type 'UniType[]'
     */
    export type ListEnumUniTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UniType[]'>;

    /**
     * Reference to a field of type 'StudyLanguage'
     */
    export type EnumStudyLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyLanguage'>;

    /**
     * Reference to a field of type 'StudyLanguage[]'
     */
    export type ListEnumStudyLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyLanguage[]'>;

    /**
     * Reference to a field of type 'StudyType'
     */
    export type EnumStudyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyType'>;

    /**
     * Reference to a field of type 'StudyType[]'
     */
    export type ListEnumStudyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyType[]'>;

    /**
     * Reference to a field of type 'Float'
     */
    export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

    /**
     * Reference to a field of type 'Float[]'
     */
    export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

    /**
     * Deep Input Types
     */

    export type IeltsExamWhereInput = {
        AND?: IeltsExamWhereInput | IeltsExamWhereInput[];
        OR?: IeltsExamWhereInput[];
        NOT?: IeltsExamWhereInput | IeltsExamWhereInput[];
        id?: StringFilter<'IeltsExam'> | string;
        createdAt?: DateTimeFilter<'IeltsExam'> | Date | string;
        createdBy?: StringFilter<'IeltsExam'> | string;
        updatedAt?: DateTimeFilter<'IeltsExam'> | Date | string;
        updatedBy?: StringNullableFilter<'IeltsExam'> | string | null;
        dateExam?: DateTimeFilter<'IeltsExam'> | Date | string;
        cityId?: StringFilter<'IeltsExam'> | string;
        isActive?: BoolNullableFilter<'IeltsExam'> | boolean | null;
        commentUser?: StringNullableFilter<'IeltsExam'> | string | null;
        commentAdmin?: StringNullableFilter<'IeltsExam'> | string | null;
        city?: XOR<CityScalarRelationFilter, CityWhereInput>;
        students?: IeltsRegistrationStudentListRelationFilter;
    };

    export type IeltsExamOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        dateExam?: SortOrder;
        cityId?: SortOrder;
        isActive?: SortOrderInput | SortOrder;
        commentUser?: SortOrderInput | SortOrder;
        commentAdmin?: SortOrderInput | SortOrder;
        city?: CityOrderByWithRelationInput;
        students?: IeltsRegistrationStudentOrderByRelationAggregateInput;
    };

    export type IeltsExamWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: IeltsExamWhereInput | IeltsExamWhereInput[];
            OR?: IeltsExamWhereInput[];
            NOT?: IeltsExamWhereInput | IeltsExamWhereInput[];
            createdAt?: DateTimeFilter<'IeltsExam'> | Date | string;
            createdBy?: StringFilter<'IeltsExam'> | string;
            updatedAt?: DateTimeFilter<'IeltsExam'> | Date | string;
            updatedBy?: StringNullableFilter<'IeltsExam'> | string | null;
            dateExam?: DateTimeFilter<'IeltsExam'> | Date | string;
            cityId?: StringFilter<'IeltsExam'> | string;
            isActive?: BoolNullableFilter<'IeltsExam'> | boolean | null;
            commentUser?: StringNullableFilter<'IeltsExam'> | string | null;
            commentAdmin?: StringNullableFilter<'IeltsExam'> | string | null;
            city?: XOR<CityScalarRelationFilter, CityWhereInput>;
            students?: IeltsRegistrationStudentListRelationFilter;
        },
        'id'
    >;

    export type IeltsExamOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        dateExam?: SortOrder;
        cityId?: SortOrder;
        isActive?: SortOrderInput | SortOrder;
        commentUser?: SortOrderInput | SortOrder;
        commentAdmin?: SortOrderInput | SortOrder;
        _count?: IeltsExamCountOrderByAggregateInput;
        _max?: IeltsExamMaxOrderByAggregateInput;
        _min?: IeltsExamMinOrderByAggregateInput;
    };

    export type IeltsExamScalarWhereWithAggregatesInput = {
        AND?: IeltsExamScalarWhereWithAggregatesInput | IeltsExamScalarWhereWithAggregatesInput[];
        OR?: IeltsExamScalarWhereWithAggregatesInput[];
        NOT?: IeltsExamScalarWhereWithAggregatesInput | IeltsExamScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'IeltsExam'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'IeltsExam'> | Date | string;
        createdBy?: StringWithAggregatesFilter<'IeltsExam'> | string;
        updatedAt?: DateTimeWithAggregatesFilter<'IeltsExam'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'IeltsExam'> | string | null;
        dateExam?: DateTimeWithAggregatesFilter<'IeltsExam'> | Date | string;
        cityId?: StringWithAggregatesFilter<'IeltsExam'> | string;
        isActive?: BoolNullableWithAggregatesFilter<'IeltsExam'> | boolean | null;
        commentUser?: StringNullableWithAggregatesFilter<'IeltsExam'> | string | null;
        commentAdmin?: StringNullableWithAggregatesFilter<'IeltsExam'> | string | null;
    };

    export type IeltsRegistrationStudentWhereInput = {
        AND?: IeltsRegistrationStudentWhereInput | IeltsRegistrationStudentWhereInput[];
        OR?: IeltsRegistrationStudentWhereInput[];
        NOT?: IeltsRegistrationStudentWhereInput | IeltsRegistrationStudentWhereInput[];
        id?: StringFilter<'IeltsRegistrationStudent'> | string;
        examId?: StringFilter<'IeltsRegistrationStudent'> | string;
        studentId?: StringFilter<'IeltsRegistrationStudent'> | string;
        registeredAt?: DateTimeFilter<'IeltsRegistrationStudent'> | Date | string;
        exam?: XOR<IeltsExamScalarRelationFilter, IeltsExamWhereInput>;
    };

    export type IeltsRegistrationStudentOrderByWithRelationInput = {
        id?: SortOrder;
        examId?: SortOrder;
        studentId?: SortOrder;
        registeredAt?: SortOrder;
        exam?: IeltsExamOrderByWithRelationInput;
    };

    export type IeltsRegistrationStudentWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            examId?: string;
            studentId_examId?: IeltsRegistrationStudentStudentIdExamIdCompoundUniqueInput;
            AND?: IeltsRegistrationStudentWhereInput | IeltsRegistrationStudentWhereInput[];
            OR?: IeltsRegistrationStudentWhereInput[];
            NOT?: IeltsRegistrationStudentWhereInput | IeltsRegistrationStudentWhereInput[];
            studentId?: StringFilter<'IeltsRegistrationStudent'> | string;
            registeredAt?: DateTimeFilter<'IeltsRegistrationStudent'> | Date | string;
            exam?: XOR<IeltsExamScalarRelationFilter, IeltsExamWhereInput>;
        },
        'id' | 'examId' | 'studentId_examId'
    >;

    export type IeltsRegistrationStudentOrderByWithAggregationInput = {
        id?: SortOrder;
        examId?: SortOrder;
        studentId?: SortOrder;
        registeredAt?: SortOrder;
        _count?: IeltsRegistrationStudentCountOrderByAggregateInput;
        _max?: IeltsRegistrationStudentMaxOrderByAggregateInput;
        _min?: IeltsRegistrationStudentMinOrderByAggregateInput;
    };

    export type IeltsRegistrationStudentScalarWhereWithAggregatesInput = {
        AND?:
            | IeltsRegistrationStudentScalarWhereWithAggregatesInput
            | IeltsRegistrationStudentScalarWhereWithAggregatesInput[];
        OR?: IeltsRegistrationStudentScalarWhereWithAggregatesInput[];
        NOT?:
            | IeltsRegistrationStudentScalarWhereWithAggregatesInput
            | IeltsRegistrationStudentScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'IeltsRegistrationStudent'> | string;
        examId?: StringWithAggregatesFilter<'IeltsRegistrationStudent'> | string;
        studentId?: StringWithAggregatesFilter<'IeltsRegistrationStudent'> | string;
        registeredAt?: DateTimeWithAggregatesFilter<'IeltsRegistrationStudent'> | Date | string;
    };

    export type CityWhereInput = {
        AND?: CityWhereInput | CityWhereInput[];
        OR?: CityWhereInput[];
        NOT?: CityWhereInput | CityWhereInput[];
        id?: StringFilter<'City'> | string;
        name?: StringFilter<'City'> | string;
        ieltsExams?: IeltsExamListRelationFilter;
        jobHuntings?: JobHuntingListRelationFilter;
        cvs?: CVListRelationFilter;
        universities?: UniversityListRelationFilter;
    };

    export type CityOrderByWithRelationInput = {
        id?: SortOrder;
        name?: SortOrder;
        ieltsExams?: IeltsExamOrderByRelationAggregateInput;
        jobHuntings?: JobHuntingOrderByRelationAggregateInput;
        cvs?: CVOrderByRelationAggregateInput;
        universities?: UniversityOrderByRelationAggregateInput;
    };

    export type CityWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            name?: string;
            AND?: CityWhereInput | CityWhereInput[];
            OR?: CityWhereInput[];
            NOT?: CityWhereInput | CityWhereInput[];
            ieltsExams?: IeltsExamListRelationFilter;
            jobHuntings?: JobHuntingListRelationFilter;
            cvs?: CVListRelationFilter;
            universities?: UniversityListRelationFilter;
        },
        'id' | 'name'
    >;

    export type CityOrderByWithAggregationInput = {
        id?: SortOrder;
        name?: SortOrder;
        _count?: CityCountOrderByAggregateInput;
        _max?: CityMaxOrderByAggregateInput;
        _min?: CityMinOrderByAggregateInput;
    };

    export type CityScalarWhereWithAggregatesInput = {
        AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[];
        OR?: CityScalarWhereWithAggregatesInput[];
        NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'City'> | string;
        name?: StringWithAggregatesFilter<'City'> | string;
    };

    export type MockRegistrationWhereInput = {
        AND?: MockRegistrationWhereInput | MockRegistrationWhereInput[];
        OR?: MockRegistrationWhereInput[];
        NOT?: MockRegistrationWhereInput | MockRegistrationWhereInput[];
        id?: StringFilter<'MockRegistration'> | string;
        createdAt?: DateTimeFilter<'MockRegistration'> | Date | string;
        createdBy?: StringFilter<'MockRegistration'> | string;
        updatedAt?: DateTimeFilter<'MockRegistration'> | Date | string;
        updatedBy?: StringNullableFilter<'MockRegistration'> | string | null;
        commentUser?: StringNullableFilter<'MockRegistration'> | string | null;
        commentAdmin?: StringNullableFilter<'MockRegistration'> | string | null;
        title?: StringNullableFilter<'MockRegistration'> | string | null;
        date?: DateTimeFilter<'MockRegistration'> | Date | string;
        branchId?: StringFilter<'MockRegistration'> | string;
        isActive?: BoolFilter<'MockRegistration'> | boolean;
        students?: MockRegistrationStudentListRelationFilter;
    };

    export type MockRegistrationOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        commentUser?: SortOrderInput | SortOrder;
        commentAdmin?: SortOrderInput | SortOrder;
        title?: SortOrderInput | SortOrder;
        date?: SortOrder;
        branchId?: SortOrder;
        isActive?: SortOrder;
        students?: MockRegistrationStudentOrderByRelationAggregateInput;
    };

    export type MockRegistrationWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: MockRegistrationWhereInput | MockRegistrationWhereInput[];
            OR?: MockRegistrationWhereInput[];
            NOT?: MockRegistrationWhereInput | MockRegistrationWhereInput[];
            createdAt?: DateTimeFilter<'MockRegistration'> | Date | string;
            createdBy?: StringFilter<'MockRegistration'> | string;
            updatedAt?: DateTimeFilter<'MockRegistration'> | Date | string;
            updatedBy?: StringNullableFilter<'MockRegistration'> | string | null;
            commentUser?: StringNullableFilter<'MockRegistration'> | string | null;
            commentAdmin?: StringNullableFilter<'MockRegistration'> | string | null;
            title?: StringNullableFilter<'MockRegistration'> | string | null;
            date?: DateTimeFilter<'MockRegistration'> | Date | string;
            branchId?: StringFilter<'MockRegistration'> | string;
            isActive?: BoolFilter<'MockRegistration'> | boolean;
            students?: MockRegistrationStudentListRelationFilter;
        },
        'id'
    >;

    export type MockRegistrationOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        commentUser?: SortOrderInput | SortOrder;
        commentAdmin?: SortOrderInput | SortOrder;
        title?: SortOrderInput | SortOrder;
        date?: SortOrder;
        branchId?: SortOrder;
        isActive?: SortOrder;
        _count?: MockRegistrationCountOrderByAggregateInput;
        _max?: MockRegistrationMaxOrderByAggregateInput;
        _min?: MockRegistrationMinOrderByAggregateInput;
    };

    export type MockRegistrationScalarWhereWithAggregatesInput = {
        AND?: MockRegistrationScalarWhereWithAggregatesInput | MockRegistrationScalarWhereWithAggregatesInput[];
        OR?: MockRegistrationScalarWhereWithAggregatesInput[];
        NOT?: MockRegistrationScalarWhereWithAggregatesInput | MockRegistrationScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'MockRegistration'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'MockRegistration'> | Date | string;
        createdBy?: StringWithAggregatesFilter<'MockRegistration'> | string;
        updatedAt?: DateTimeWithAggregatesFilter<'MockRegistration'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'MockRegistration'> | string | null;
        commentUser?: StringNullableWithAggregatesFilter<'MockRegistration'> | string | null;
        commentAdmin?: StringNullableWithAggregatesFilter<'MockRegistration'> | string | null;
        title?: StringNullableWithAggregatesFilter<'MockRegistration'> | string | null;
        date?: DateTimeWithAggregatesFilter<'MockRegistration'> | Date | string;
        branchId?: StringWithAggregatesFilter<'MockRegistration'> | string;
        isActive?: BoolWithAggregatesFilter<'MockRegistration'> | boolean;
    };

    export type MockRegistrationStudentWhereInput = {
        AND?: MockRegistrationStudentWhereInput | MockRegistrationStudentWhereInput[];
        OR?: MockRegistrationStudentWhereInput[];
        NOT?: MockRegistrationStudentWhereInput | MockRegistrationStudentWhereInput[];
        id?: StringFilter<'MockRegistrationStudent'> | string;
        studentId?: StringFilter<'MockRegistrationStudent'> | string;
        mockRegistrationId?: StringFilter<'MockRegistrationStudent'> | string;
        registeredAt?: DateTimeFilter<'MockRegistrationStudent'> | Date | string;
        mockRegistration?: XOR<MockRegistrationScalarRelationFilter, MockRegistrationWhereInput>;
    };

    export type MockRegistrationStudentOrderByWithRelationInput = {
        id?: SortOrder;
        studentId?: SortOrder;
        mockRegistrationId?: SortOrder;
        registeredAt?: SortOrder;
        mockRegistration?: MockRegistrationOrderByWithRelationInput;
    };

    export type MockRegistrationStudentWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            mockRegistrationId?: string;
            studentId_mockRegistrationId?: MockRegistrationStudentStudentIdMockRegistrationIdCompoundUniqueInput;
            AND?: MockRegistrationStudentWhereInput | MockRegistrationStudentWhereInput[];
            OR?: MockRegistrationStudentWhereInput[];
            NOT?: MockRegistrationStudentWhereInput | MockRegistrationStudentWhereInput[];
            studentId?: StringFilter<'MockRegistrationStudent'> | string;
            registeredAt?: DateTimeFilter<'MockRegistrationStudent'> | Date | string;
            mockRegistration?: XOR<MockRegistrationScalarRelationFilter, MockRegistrationWhereInput>;
        },
        'id' | 'mockRegistrationId' | 'studentId_mockRegistrationId'
    >;

    export type MockRegistrationStudentOrderByWithAggregationInput = {
        id?: SortOrder;
        studentId?: SortOrder;
        mockRegistrationId?: SortOrder;
        registeredAt?: SortOrder;
        _count?: MockRegistrationStudentCountOrderByAggregateInput;
        _max?: MockRegistrationStudentMaxOrderByAggregateInput;
        _min?: MockRegistrationStudentMinOrderByAggregateInput;
    };

    export type MockRegistrationStudentScalarWhereWithAggregatesInput = {
        AND?:
            | MockRegistrationStudentScalarWhereWithAggregatesInput
            | MockRegistrationStudentScalarWhereWithAggregatesInput[];
        OR?: MockRegistrationStudentScalarWhereWithAggregatesInput[];
        NOT?:
            | MockRegistrationStudentScalarWhereWithAggregatesInput
            | MockRegistrationStudentScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'MockRegistrationStudent'> | string;
        studentId?: StringWithAggregatesFilter<'MockRegistrationStudent'> | string;
        mockRegistrationId?: StringWithAggregatesFilter<'MockRegistrationStudent'> | string;
        registeredAt?: DateTimeWithAggregatesFilter<'MockRegistrationStudent'> | Date | string;
    };

    export type JobHuntingWhereInput = {
        AND?: JobHuntingWhereInput | JobHuntingWhereInput[];
        OR?: JobHuntingWhereInput[];
        NOT?: JobHuntingWhereInput | JobHuntingWhereInput[];
        id?: StringFilter<'JobHunting'> | string;
        createdAt?: DateTimeFilter<'JobHunting'> | Date | string;
        createdBy?: StringFilter<'JobHunting'> | string;
        updatedAt?: DateTimeFilter<'JobHunting'> | Date | string;
        updatedBy?: StringNullableFilter<'JobHunting'> | string | null;
        title?: StringFilter<'JobHunting'> | string;
        description?: StringNullableFilter<'JobHunting'> | string | null;
        workExperience?: EnumWorkExperienceFilter<'JobHunting'> | $Enums.WorkExperience;
        companyId?: StringNullableFilter<'JobHunting'> | string | null;
        cityId?: StringNullableFilter<'JobHunting'> | string | null;
        certificateRequirements?: StringNullableFilter<'JobHunting'> | string | null;
        workScheduleHours?: EnumWorkScheduleHoursNullableFilter<'JobHunting'> | $Enums.WorkScheduleHours | null;
        employmentType?: EnumEmploymentTypeNullableFilter<'JobHunting'> | $Enums.EmploymentType | null;
        workMode?: EnumWorkModeNullableFilter<'JobHunting'> | $Enums.WorkMode | null;
        salary?: IntNullableFilter<'JobHunting'> | number | null;
        responsibilities?: StringNullableFilter<'JobHunting'> | string | null;
        requirements?: StringNullableFilter<'JobHunting'> | string | null;
        conditions?: StringNullableFilter<'JobHunting'> | string | null;
        company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
        city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null;
    };

    export type JobHuntingOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        description?: SortOrderInput | SortOrder;
        workExperience?: SortOrder;
        companyId?: SortOrderInput | SortOrder;
        cityId?: SortOrderInput | SortOrder;
        certificateRequirements?: SortOrderInput | SortOrder;
        workScheduleHours?: SortOrderInput | SortOrder;
        employmentType?: SortOrderInput | SortOrder;
        workMode?: SortOrderInput | SortOrder;
        salary?: SortOrderInput | SortOrder;
        responsibilities?: SortOrderInput | SortOrder;
        requirements?: SortOrderInput | SortOrder;
        conditions?: SortOrderInput | SortOrder;
        company?: CompanyOrderByWithRelationInput;
        city?: CityOrderByWithRelationInput;
    };

    export type JobHuntingWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: JobHuntingWhereInput | JobHuntingWhereInput[];
            OR?: JobHuntingWhereInput[];
            NOT?: JobHuntingWhereInput | JobHuntingWhereInput[];
            createdAt?: DateTimeFilter<'JobHunting'> | Date | string;
            createdBy?: StringFilter<'JobHunting'> | string;
            updatedAt?: DateTimeFilter<'JobHunting'> | Date | string;
            updatedBy?: StringNullableFilter<'JobHunting'> | string | null;
            title?: StringFilter<'JobHunting'> | string;
            description?: StringNullableFilter<'JobHunting'> | string | null;
            workExperience?: EnumWorkExperienceFilter<'JobHunting'> | $Enums.WorkExperience;
            companyId?: StringNullableFilter<'JobHunting'> | string | null;
            cityId?: StringNullableFilter<'JobHunting'> | string | null;
            certificateRequirements?: StringNullableFilter<'JobHunting'> | string | null;
            workScheduleHours?: EnumWorkScheduleHoursNullableFilter<'JobHunting'> | $Enums.WorkScheduleHours | null;
            employmentType?: EnumEmploymentTypeNullableFilter<'JobHunting'> | $Enums.EmploymentType | null;
            workMode?: EnumWorkModeNullableFilter<'JobHunting'> | $Enums.WorkMode | null;
            salary?: IntNullableFilter<'JobHunting'> | number | null;
            responsibilities?: StringNullableFilter<'JobHunting'> | string | null;
            requirements?: StringNullableFilter<'JobHunting'> | string | null;
            conditions?: StringNullableFilter<'JobHunting'> | string | null;
            company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null;
            city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null;
        },
        'id'
    >;

    export type JobHuntingOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        description?: SortOrderInput | SortOrder;
        workExperience?: SortOrder;
        companyId?: SortOrderInput | SortOrder;
        cityId?: SortOrderInput | SortOrder;
        certificateRequirements?: SortOrderInput | SortOrder;
        workScheduleHours?: SortOrderInput | SortOrder;
        employmentType?: SortOrderInput | SortOrder;
        workMode?: SortOrderInput | SortOrder;
        salary?: SortOrderInput | SortOrder;
        responsibilities?: SortOrderInput | SortOrder;
        requirements?: SortOrderInput | SortOrder;
        conditions?: SortOrderInput | SortOrder;
        _count?: JobHuntingCountOrderByAggregateInput;
        _avg?: JobHuntingAvgOrderByAggregateInput;
        _max?: JobHuntingMaxOrderByAggregateInput;
        _min?: JobHuntingMinOrderByAggregateInput;
        _sum?: JobHuntingSumOrderByAggregateInput;
    };

    export type JobHuntingScalarWhereWithAggregatesInput = {
        AND?: JobHuntingScalarWhereWithAggregatesInput | JobHuntingScalarWhereWithAggregatesInput[];
        OR?: JobHuntingScalarWhereWithAggregatesInput[];
        NOT?: JobHuntingScalarWhereWithAggregatesInput | JobHuntingScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'JobHunting'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'JobHunting'> | Date | string;
        createdBy?: StringWithAggregatesFilter<'JobHunting'> | string;
        updatedAt?: DateTimeWithAggregatesFilter<'JobHunting'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        title?: StringWithAggregatesFilter<'JobHunting'> | string;
        description?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        workExperience?: EnumWorkExperienceWithAggregatesFilter<'JobHunting'> | $Enums.WorkExperience;
        companyId?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        cityId?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        certificateRequirements?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        workScheduleHours?:
            | EnumWorkScheduleHoursNullableWithAggregatesFilter<'JobHunting'>
            | $Enums.WorkScheduleHours
            | null;
        employmentType?: EnumEmploymentTypeNullableWithAggregatesFilter<'JobHunting'> | $Enums.EmploymentType | null;
        workMode?: EnumWorkModeNullableWithAggregatesFilter<'JobHunting'> | $Enums.WorkMode | null;
        salary?: IntNullableWithAggregatesFilter<'JobHunting'> | number | null;
        responsibilities?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        requirements?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
        conditions?: StringNullableWithAggregatesFilter<'JobHunting'> | string | null;
    };

    export type CompanyWhereInput = {
        AND?: CompanyWhereInput | CompanyWhereInput[];
        OR?: CompanyWhereInput[];
        NOT?: CompanyWhereInput | CompanyWhereInput[];
        id?: StringFilter<'Company'> | string;
        createdAt?: DateTimeFilter<'Company'> | Date | string;
        createdBy?: StringFilter<'Company'> | string;
        updatedAt?: DateTimeFilter<'Company'> | Date | string;
        updatedBy?: StringNullableFilter<'Company'> | string | null;
        companyTitle?: StringFilter<'Company'> | string;
        description?: StringNullableFilter<'Company'> | string | null;
        companyLogo?: StringNullableFilter<'Company'> | string | null;
        jobHuntings?: JobHuntingListRelationFilter;
    };

    export type CompanyOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        companyTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        companyLogo?: SortOrderInput | SortOrder;
        jobHuntings?: JobHuntingOrderByRelationAggregateInput;
    };

    export type CompanyWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: CompanyWhereInput | CompanyWhereInput[];
            OR?: CompanyWhereInput[];
            NOT?: CompanyWhereInput | CompanyWhereInput[];
            createdAt?: DateTimeFilter<'Company'> | Date | string;
            createdBy?: StringFilter<'Company'> | string;
            updatedAt?: DateTimeFilter<'Company'> | Date | string;
            updatedBy?: StringNullableFilter<'Company'> | string | null;
            companyTitle?: StringFilter<'Company'> | string;
            description?: StringNullableFilter<'Company'> | string | null;
            companyLogo?: StringNullableFilter<'Company'> | string | null;
            jobHuntings?: JobHuntingListRelationFilter;
        },
        'id'
    >;

    export type CompanyOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        companyTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        companyLogo?: SortOrderInput | SortOrder;
        _count?: CompanyCountOrderByAggregateInput;
        _max?: CompanyMaxOrderByAggregateInput;
        _min?: CompanyMinOrderByAggregateInput;
    };

    export type CompanyScalarWhereWithAggregatesInput = {
        AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[];
        OR?: CompanyScalarWhereWithAggregatesInput[];
        NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Company'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'Company'> | Date | string;
        createdBy?: StringWithAggregatesFilter<'Company'> | string;
        updatedAt?: DateTimeWithAggregatesFilter<'Company'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'Company'> | string | null;
        companyTitle?: StringWithAggregatesFilter<'Company'> | string;
        description?: StringNullableWithAggregatesFilter<'Company'> | string | null;
        companyLogo?: StringNullableWithAggregatesFilter<'Company'> | string | null;
    };

    export type CVWhereInput = {
        AND?: CVWhereInput | CVWhereInput[];
        OR?: CVWhereInput[];
        NOT?: CVWhereInput | CVWhereInput[];
        id?: StringFilter<'CV'> | string;
        createdAt?: DateTimeFilter<'CV'> | Date | string;
        updatedAt?: DateTimeFilter<'CV'> | Date | string;
        studentId?: StringFilter<'CV'> | string;
        description?: StringNullableFilter<'CV'> | string | null;
        cityId?: StringFilter<'CV'> | string;
        degree?: EnumDegreeNullableFilter<'CV'> | $Enums.Degree | null;
        universityTitle?: StringNullableFilter<'CV'> | string | null;
        universityMajor?: StringNullableFilter<'CV'> | string | null;
        graduationYear?: IntNullableFilter<'CV'> | number | null;
        companyName?: StringNullableFilter<'CV'> | string | null;
        position?: StringNullableFilter<'CV'> | string | null;
        responsibilities?: StringNullableFilter<'CV'> | string | null;
        startDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
        endDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
        city?: XOR<CityScalarRelationFilter, CityWhereInput>;
        skills?: CvSkillListRelationFilter;
        tools?: CvToolListRelationFilter;
    };

    export type CVOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        updatedAt?: SortOrder;
        studentId?: SortOrder;
        description?: SortOrderInput | SortOrder;
        cityId?: SortOrder;
        degree?: SortOrderInput | SortOrder;
        universityTitle?: SortOrderInput | SortOrder;
        universityMajor?: SortOrderInput | SortOrder;
        graduationYear?: SortOrderInput | SortOrder;
        companyName?: SortOrderInput | SortOrder;
        position?: SortOrderInput | SortOrder;
        responsibilities?: SortOrderInput | SortOrder;
        startDate?: SortOrderInput | SortOrder;
        endDate?: SortOrderInput | SortOrder;
        city?: CityOrderByWithRelationInput;
        skills?: CvSkillOrderByRelationAggregateInput;
        tools?: CvToolOrderByRelationAggregateInput;
    };

    export type CVWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: CVWhereInput | CVWhereInput[];
            OR?: CVWhereInput[];
            NOT?: CVWhereInput | CVWhereInput[];
            createdAt?: DateTimeFilter<'CV'> | Date | string;
            updatedAt?: DateTimeFilter<'CV'> | Date | string;
            studentId?: StringFilter<'CV'> | string;
            description?: StringNullableFilter<'CV'> | string | null;
            cityId?: StringFilter<'CV'> | string;
            degree?: EnumDegreeNullableFilter<'CV'> | $Enums.Degree | null;
            universityTitle?: StringNullableFilter<'CV'> | string | null;
            universityMajor?: StringNullableFilter<'CV'> | string | null;
            graduationYear?: IntNullableFilter<'CV'> | number | null;
            companyName?: StringNullableFilter<'CV'> | string | null;
            position?: StringNullableFilter<'CV'> | string | null;
            responsibilities?: StringNullableFilter<'CV'> | string | null;
            startDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
            endDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
            city?: XOR<CityScalarRelationFilter, CityWhereInput>;
            skills?: CvSkillListRelationFilter;
            tools?: CvToolListRelationFilter;
        },
        'id'
    >;

    export type CVOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        updatedAt?: SortOrder;
        studentId?: SortOrder;
        description?: SortOrderInput | SortOrder;
        cityId?: SortOrder;
        degree?: SortOrderInput | SortOrder;
        universityTitle?: SortOrderInput | SortOrder;
        universityMajor?: SortOrderInput | SortOrder;
        graduationYear?: SortOrderInput | SortOrder;
        companyName?: SortOrderInput | SortOrder;
        position?: SortOrderInput | SortOrder;
        responsibilities?: SortOrderInput | SortOrder;
        startDate?: SortOrderInput | SortOrder;
        endDate?: SortOrderInput | SortOrder;
        _count?: CVCountOrderByAggregateInput;
        _avg?: CVAvgOrderByAggregateInput;
        _max?: CVMaxOrderByAggregateInput;
        _min?: CVMinOrderByAggregateInput;
        _sum?: CVSumOrderByAggregateInput;
    };

    export type CVScalarWhereWithAggregatesInput = {
        AND?: CVScalarWhereWithAggregatesInput | CVScalarWhereWithAggregatesInput[];
        OR?: CVScalarWhereWithAggregatesInput[];
        NOT?: CVScalarWhereWithAggregatesInput | CVScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'CV'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'CV'> | Date | string;
        updatedAt?: DateTimeWithAggregatesFilter<'CV'> | Date | string;
        studentId?: StringWithAggregatesFilter<'CV'> | string;
        description?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        cityId?: StringWithAggregatesFilter<'CV'> | string;
        degree?: EnumDegreeNullableWithAggregatesFilter<'CV'> | $Enums.Degree | null;
        universityTitle?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        universityMajor?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        graduationYear?: IntNullableWithAggregatesFilter<'CV'> | number | null;
        companyName?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        position?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        responsibilities?: StringNullableWithAggregatesFilter<'CV'> | string | null;
        startDate?: DateTimeNullableWithAggregatesFilter<'CV'> | Date | string | null;
        endDate?: DateTimeNullableWithAggregatesFilter<'CV'> | Date | string | null;
    };

    export type SkillWhereInput = {
        AND?: SkillWhereInput | SkillWhereInput[];
        OR?: SkillWhereInput[];
        NOT?: SkillWhereInput | SkillWhereInput[];
        id?: StringFilter<'Skill'> | string;
        name?: StringFilter<'Skill'> | string;
        cvs?: CvSkillListRelationFilter;
    };

    export type SkillOrderByWithRelationInput = {
        id?: SortOrder;
        name?: SortOrder;
        cvs?: CvSkillOrderByRelationAggregateInput;
    };

    export type SkillWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            name?: string;
            AND?: SkillWhereInput | SkillWhereInput[];
            OR?: SkillWhereInput[];
            NOT?: SkillWhereInput | SkillWhereInput[];
            cvs?: CvSkillListRelationFilter;
        },
        'id' | 'name'
    >;

    export type SkillOrderByWithAggregationInput = {
        id?: SortOrder;
        name?: SortOrder;
        _count?: SkillCountOrderByAggregateInput;
        _max?: SkillMaxOrderByAggregateInput;
        _min?: SkillMinOrderByAggregateInput;
    };

    export type SkillScalarWhereWithAggregatesInput = {
        AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[];
        OR?: SkillScalarWhereWithAggregatesInput[];
        NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Skill'> | string;
        name?: StringWithAggregatesFilter<'Skill'> | string;
    };

    export type ToolWhereInput = {
        AND?: ToolWhereInput | ToolWhereInput[];
        OR?: ToolWhereInput[];
        NOT?: ToolWhereInput | ToolWhereInput[];
        id?: StringFilter<'Tool'> | string;
        name?: StringFilter<'Tool'> | string;
        cvs?: CvToolListRelationFilter;
    };

    export type ToolOrderByWithRelationInput = {
        id?: SortOrder;
        name?: SortOrder;
        cvs?: CvToolOrderByRelationAggregateInput;
    };

    export type ToolWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            name?: string;
            AND?: ToolWhereInput | ToolWhereInput[];
            OR?: ToolWhereInput[];
            NOT?: ToolWhereInput | ToolWhereInput[];
            cvs?: CvToolListRelationFilter;
        },
        'id' | 'name'
    >;

    export type ToolOrderByWithAggregationInput = {
        id?: SortOrder;
        name?: SortOrder;
        _count?: ToolCountOrderByAggregateInput;
        _max?: ToolMaxOrderByAggregateInput;
        _min?: ToolMinOrderByAggregateInput;
    };

    export type ToolScalarWhereWithAggregatesInput = {
        AND?: ToolScalarWhereWithAggregatesInput | ToolScalarWhereWithAggregatesInput[];
        OR?: ToolScalarWhereWithAggregatesInput[];
        NOT?: ToolScalarWhereWithAggregatesInput | ToolScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Tool'> | string;
        name?: StringWithAggregatesFilter<'Tool'> | string;
    };

    export type CvSkillWhereInput = {
        AND?: CvSkillWhereInput | CvSkillWhereInput[];
        OR?: CvSkillWhereInput[];
        NOT?: CvSkillWhereInput | CvSkillWhereInput[];
        cvId?: StringFilter<'CvSkill'> | string;
        skillId?: StringFilter<'CvSkill'> | string;
        cv?: XOR<CVScalarRelationFilter, CVWhereInput>;
        skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>;
    };

    export type CvSkillOrderByWithRelationInput = {
        cvId?: SortOrder;
        skillId?: SortOrder;
        cv?: CVOrderByWithRelationInput;
        skill?: SkillOrderByWithRelationInput;
    };

    export type CvSkillWhereUniqueInput = Prisma.AtLeast<
        {
            cvId_skillId?: CvSkillCvIdSkillIdCompoundUniqueInput;
            AND?: CvSkillWhereInput | CvSkillWhereInput[];
            OR?: CvSkillWhereInput[];
            NOT?: CvSkillWhereInput | CvSkillWhereInput[];
            cvId?: StringFilter<'CvSkill'> | string;
            skillId?: StringFilter<'CvSkill'> | string;
            cv?: XOR<CVScalarRelationFilter, CVWhereInput>;
            skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>;
        },
        'cvId_skillId'
    >;

    export type CvSkillOrderByWithAggregationInput = {
        cvId?: SortOrder;
        skillId?: SortOrder;
        _count?: CvSkillCountOrderByAggregateInput;
        _max?: CvSkillMaxOrderByAggregateInput;
        _min?: CvSkillMinOrderByAggregateInput;
    };

    export type CvSkillScalarWhereWithAggregatesInput = {
        AND?: CvSkillScalarWhereWithAggregatesInput | CvSkillScalarWhereWithAggregatesInput[];
        OR?: CvSkillScalarWhereWithAggregatesInput[];
        NOT?: CvSkillScalarWhereWithAggregatesInput | CvSkillScalarWhereWithAggregatesInput[];
        cvId?: StringWithAggregatesFilter<'CvSkill'> | string;
        skillId?: StringWithAggregatesFilter<'CvSkill'> | string;
    };

    export type CvToolWhereInput = {
        AND?: CvToolWhereInput | CvToolWhereInput[];
        OR?: CvToolWhereInput[];
        NOT?: CvToolWhereInput | CvToolWhereInput[];
        cvId?: StringFilter<'CvTool'> | string;
        toolId?: StringFilter<'CvTool'> | string;
        cv?: XOR<CVScalarRelationFilter, CVWhereInput>;
        tool?: XOR<ToolScalarRelationFilter, ToolWhereInput>;
    };

    export type CvToolOrderByWithRelationInput = {
        cvId?: SortOrder;
        toolId?: SortOrder;
        cv?: CVOrderByWithRelationInput;
        tool?: ToolOrderByWithRelationInput;
    };

    export type CvToolWhereUniqueInput = Prisma.AtLeast<
        {
            cvId_toolId?: CvToolCvIdToolIdCompoundUniqueInput;
            AND?: CvToolWhereInput | CvToolWhereInput[];
            OR?: CvToolWhereInput[];
            NOT?: CvToolWhereInput | CvToolWhereInput[];
            cvId?: StringFilter<'CvTool'> | string;
            toolId?: StringFilter<'CvTool'> | string;
            cv?: XOR<CVScalarRelationFilter, CVWhereInput>;
            tool?: XOR<ToolScalarRelationFilter, ToolWhereInput>;
        },
        'cvId_toolId'
    >;

    export type CvToolOrderByWithAggregationInput = {
        cvId?: SortOrder;
        toolId?: SortOrder;
        _count?: CvToolCountOrderByAggregateInput;
        _max?: CvToolMaxOrderByAggregateInput;
        _min?: CvToolMinOrderByAggregateInput;
    };

    export type CvToolScalarWhereWithAggregatesInput = {
        AND?: CvToolScalarWhereWithAggregatesInput | CvToolScalarWhereWithAggregatesInput[];
        OR?: CvToolScalarWhereWithAggregatesInput[];
        NOT?: CvToolScalarWhereWithAggregatesInput | CvToolScalarWhereWithAggregatesInput[];
        cvId?: StringWithAggregatesFilter<'CvTool'> | string;
        toolId?: StringWithAggregatesFilter<'CvTool'> | string;
    };

    export type CertificateWhereInput = {
        AND?: CertificateWhereInput | CertificateWhereInput[];
        OR?: CertificateWhereInput[];
        NOT?: CertificateWhereInput | CertificateWhereInput[];
        id?: StringFilter<'Certificate'> | string;
        name?: StringFilter<'Certificate'> | string;
    };

    export type CertificateOrderByWithRelationInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CertificateWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            name?: string;
            AND?: CertificateWhereInput | CertificateWhereInput[];
            OR?: CertificateWhereInput[];
            NOT?: CertificateWhereInput | CertificateWhereInput[];
        },
        'id' | 'name'
    >;

    export type CertificateOrderByWithAggregationInput = {
        id?: SortOrder;
        name?: SortOrder;
        _count?: CertificateCountOrderByAggregateInput;
        _max?: CertificateMaxOrderByAggregateInput;
        _min?: CertificateMinOrderByAggregateInput;
    };

    export type CertificateScalarWhereWithAggregatesInput = {
        AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[];
        OR?: CertificateScalarWhereWithAggregatesInput[];
        NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Certificate'> | string;
        name?: StringWithAggregatesFilter<'Certificate'> | string;
    };

    export type UniversityWhereInput = {
        AND?: UniversityWhereInput | UniversityWhereInput[];
        OR?: UniversityWhereInput[];
        NOT?: UniversityWhereInput | UniversityWhereInput[];
        id?: StringFilter<'University'> | string;
        createdAt?: DateTimeFilter<'University'> | Date | string;
        createdBy?: StringNullableFilter<'University'> | string | null;
        updatedAt?: DateTimeFilter<'University'> | Date | string;
        updatedBy?: StringNullableFilter<'University'> | string | null;
        title?: StringFilter<'University'> | string;
        description?: StringNullableFilter<'University'> | string | null;
        registrationDate?: DateTimeFilter<'University'> | Date | string;
        type?: EnumUniTypeNullableFilter<'University'> | $Enums.UniType | null;
        status?: BoolNullableFilter<'University'> | boolean | null;
        contract?: StringFilter<'University'> | string;
        contacts?: IntNullableFilter<'University'> | number | null;
        website?: StringNullableFilter<'University'> | string | null;
        email?: StringNullableFilter<'University'> | string | null;
        address?: StringNullableFilter<'University'> | string | null;
        cityId?: StringNullableFilter<'University'> | string | null;
        logo?: StringNullableFilter<'University'> | string | null;
        license?: StringNullableFilter<'University'> | string | null;
        certificateRequirementId?: StringNullableFilter<'University'> | string | null;
        city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null;
        certificateRequirement?: XOR<
            CertificateRequirementsNullableScalarRelationFilter,
            CertificateRequirementsWhereInput
        > | null;
        programs?: ProgramListRelationFilter;
        faculties?: FacultyListRelationFilter;
    };

    export type UniversityOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        description?: SortOrderInput | SortOrder;
        registrationDate?: SortOrder;
        type?: SortOrderInput | SortOrder;
        status?: SortOrderInput | SortOrder;
        contract?: SortOrder;
        contacts?: SortOrderInput | SortOrder;
        website?: SortOrderInput | SortOrder;
        email?: SortOrderInput | SortOrder;
        address?: SortOrderInput | SortOrder;
        cityId?: SortOrderInput | SortOrder;
        logo?: SortOrderInput | SortOrder;
        license?: SortOrderInput | SortOrder;
        certificateRequirementId?: SortOrderInput | SortOrder;
        city?: CityOrderByWithRelationInput;
        certificateRequirement?: CertificateRequirementsOrderByWithRelationInput;
        programs?: ProgramOrderByRelationAggregateInput;
        faculties?: FacultyOrderByRelationAggregateInput;
    };

    export type UniversityWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: UniversityWhereInput | UniversityWhereInput[];
            OR?: UniversityWhereInput[];
            NOT?: UniversityWhereInput | UniversityWhereInput[];
            createdAt?: DateTimeFilter<'University'> | Date | string;
            createdBy?: StringNullableFilter<'University'> | string | null;
            updatedAt?: DateTimeFilter<'University'> | Date | string;
            updatedBy?: StringNullableFilter<'University'> | string | null;
            title?: StringFilter<'University'> | string;
            description?: StringNullableFilter<'University'> | string | null;
            registrationDate?: DateTimeFilter<'University'> | Date | string;
            type?: EnumUniTypeNullableFilter<'University'> | $Enums.UniType | null;
            status?: BoolNullableFilter<'University'> | boolean | null;
            contract?: StringFilter<'University'> | string;
            contacts?: IntNullableFilter<'University'> | number | null;
            website?: StringNullableFilter<'University'> | string | null;
            email?: StringNullableFilter<'University'> | string | null;
            address?: StringNullableFilter<'University'> | string | null;
            cityId?: StringNullableFilter<'University'> | string | null;
            logo?: StringNullableFilter<'University'> | string | null;
            license?: StringNullableFilter<'University'> | string | null;
            certificateRequirementId?: StringNullableFilter<'University'> | string | null;
            city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null;
            certificateRequirement?: XOR<
                CertificateRequirementsNullableScalarRelationFilter,
                CertificateRequirementsWhereInput
            > | null;
            programs?: ProgramListRelationFilter;
            faculties?: FacultyListRelationFilter;
        },
        'id'
    >;

    export type UniversityOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        description?: SortOrderInput | SortOrder;
        registrationDate?: SortOrder;
        type?: SortOrderInput | SortOrder;
        status?: SortOrderInput | SortOrder;
        contract?: SortOrder;
        contacts?: SortOrderInput | SortOrder;
        website?: SortOrderInput | SortOrder;
        email?: SortOrderInput | SortOrder;
        address?: SortOrderInput | SortOrder;
        cityId?: SortOrderInput | SortOrder;
        logo?: SortOrderInput | SortOrder;
        license?: SortOrderInput | SortOrder;
        certificateRequirementId?: SortOrderInput | SortOrder;
        _count?: UniversityCountOrderByAggregateInput;
        _avg?: UniversityAvgOrderByAggregateInput;
        _max?: UniversityMaxOrderByAggregateInput;
        _min?: UniversityMinOrderByAggregateInput;
        _sum?: UniversitySumOrderByAggregateInput;
    };

    export type UniversityScalarWhereWithAggregatesInput = {
        AND?: UniversityScalarWhereWithAggregatesInput | UniversityScalarWhereWithAggregatesInput[];
        OR?: UniversityScalarWhereWithAggregatesInput[];
        NOT?: UniversityScalarWhereWithAggregatesInput | UniversityScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'University'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'University'> | Date | string;
        createdBy?: StringNullableWithAggregatesFilter<'University'> | string | null;
        updatedAt?: DateTimeWithAggregatesFilter<'University'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'University'> | string | null;
        title?: StringWithAggregatesFilter<'University'> | string;
        description?: StringNullableWithAggregatesFilter<'University'> | string | null;
        registrationDate?: DateTimeWithAggregatesFilter<'University'> | Date | string;
        type?: EnumUniTypeNullableWithAggregatesFilter<'University'> | $Enums.UniType | null;
        status?: BoolNullableWithAggregatesFilter<'University'> | boolean | null;
        contract?: StringWithAggregatesFilter<'University'> | string;
        contacts?: IntNullableWithAggregatesFilter<'University'> | number | null;
        website?: StringNullableWithAggregatesFilter<'University'> | string | null;
        email?: StringNullableWithAggregatesFilter<'University'> | string | null;
        address?: StringNullableWithAggregatesFilter<'University'> | string | null;
        cityId?: StringNullableWithAggregatesFilter<'University'> | string | null;
        logo?: StringNullableWithAggregatesFilter<'University'> | string | null;
        license?: StringNullableWithAggregatesFilter<'University'> | string | null;
        certificateRequirementId?: StringNullableWithAggregatesFilter<'University'> | string | null;
    };

    export type ProgramWhereInput = {
        AND?: ProgramWhereInput | ProgramWhereInput[];
        OR?: ProgramWhereInput[];
        NOT?: ProgramWhereInput | ProgramWhereInput[];
        id?: StringFilter<'Program'> | string;
        createdAt?: DateTimeFilter<'Program'> | Date | string;
        createdBy?: StringNullableFilter<'Program'> | string | null;
        updatedAt?: DateTimeFilter<'Program'> | Date | string;
        updatedBy?: StringNullableFilter<'Program'> | string | null;
        title?: StringFilter<'Program'> | string;
        studyLanguage?: EnumStudyLanguageFilter<'Program'> | $Enums.StudyLanguage;
        contract?: IntFilter<'Program'> | number;
        degree?: EnumDegreeFilter<'Program'> | $Enums.Degree;
        certificateRequirementId?: StringNullableFilter<'Program'> | string | null;
        studyType?: EnumStudyTypeNullableFilter<'Program'> | $Enums.StudyType | null;
        universityId?: StringFilter<'Program'> | string;
        facultyId?: StringNullableFilter<'Program'> | string | null;
        university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>;
        faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null;
        certificateRequirement?: XOR<
            CertificateRequirementsNullableScalarRelationFilter,
            CertificateRequirementsWhereInput
        > | null;
    };

    export type ProgramOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        studyLanguage?: SortOrder;
        contract?: SortOrder;
        degree?: SortOrder;
        certificateRequirementId?: SortOrderInput | SortOrder;
        studyType?: SortOrderInput | SortOrder;
        universityId?: SortOrder;
        facultyId?: SortOrderInput | SortOrder;
        university?: UniversityOrderByWithRelationInput;
        faculty?: FacultyOrderByWithRelationInput;
        certificateRequirement?: CertificateRequirementsOrderByWithRelationInput;
    };

    export type ProgramWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: ProgramWhereInput | ProgramWhereInput[];
            OR?: ProgramWhereInput[];
            NOT?: ProgramWhereInput | ProgramWhereInput[];
            createdAt?: DateTimeFilter<'Program'> | Date | string;
            createdBy?: StringNullableFilter<'Program'> | string | null;
            updatedAt?: DateTimeFilter<'Program'> | Date | string;
            updatedBy?: StringNullableFilter<'Program'> | string | null;
            title?: StringFilter<'Program'> | string;
            studyLanguage?: EnumStudyLanguageFilter<'Program'> | $Enums.StudyLanguage;
            contract?: IntFilter<'Program'> | number;
            degree?: EnumDegreeFilter<'Program'> | $Enums.Degree;
            certificateRequirementId?: StringNullableFilter<'Program'> | string | null;
            studyType?: EnumStudyTypeNullableFilter<'Program'> | $Enums.StudyType | null;
            universityId?: StringFilter<'Program'> | string;
            facultyId?: StringNullableFilter<'Program'> | string | null;
            university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>;
            faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null;
            certificateRequirement?: XOR<
                CertificateRequirementsNullableScalarRelationFilter,
                CertificateRequirementsWhereInput
            > | null;
        },
        'id'
    >;

    export type ProgramOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        title?: SortOrder;
        studyLanguage?: SortOrder;
        contract?: SortOrder;
        degree?: SortOrder;
        certificateRequirementId?: SortOrderInput | SortOrder;
        studyType?: SortOrderInput | SortOrder;
        universityId?: SortOrder;
        facultyId?: SortOrderInput | SortOrder;
        _count?: ProgramCountOrderByAggregateInput;
        _avg?: ProgramAvgOrderByAggregateInput;
        _max?: ProgramMaxOrderByAggregateInput;
        _min?: ProgramMinOrderByAggregateInput;
        _sum?: ProgramSumOrderByAggregateInput;
    };

    export type ProgramScalarWhereWithAggregatesInput = {
        AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[];
        OR?: ProgramScalarWhereWithAggregatesInput[];
        NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Program'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'Program'> | Date | string;
        createdBy?: StringNullableWithAggregatesFilter<'Program'> | string | null;
        updatedAt?: DateTimeWithAggregatesFilter<'Program'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'Program'> | string | null;
        title?: StringWithAggregatesFilter<'Program'> | string;
        studyLanguage?: EnumStudyLanguageWithAggregatesFilter<'Program'> | $Enums.StudyLanguage;
        contract?: IntWithAggregatesFilter<'Program'> | number;
        degree?: EnumDegreeWithAggregatesFilter<'Program'> | $Enums.Degree;
        certificateRequirementId?: StringNullableWithAggregatesFilter<'Program'> | string | null;
        studyType?: EnumStudyTypeNullableWithAggregatesFilter<'Program'> | $Enums.StudyType | null;
        universityId?: StringWithAggregatesFilter<'Program'> | string;
        facultyId?: StringNullableWithAggregatesFilter<'Program'> | string | null;
    };

    export type FacultyWhereInput = {
        AND?: FacultyWhereInput | FacultyWhereInput[];
        OR?: FacultyWhereInput[];
        NOT?: FacultyWhereInput | FacultyWhereInput[];
        id?: StringFilter<'Faculty'> | string;
        createdAt?: DateTimeFilter<'Faculty'> | Date | string;
        createdBy?: StringNullableFilter<'Faculty'> | string | null;
        updatedAt?: DateTimeFilter<'Faculty'> | Date | string;
        updatedBy?: StringNullableFilter<'Faculty'> | string | null;
        facultyTitle?: StringFilter<'Faculty'> | string;
        description?: StringNullableFilter<'Faculty'> | string | null;
        universityId?: StringFilter<'Faculty'> | string;
        university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>;
        programs?: ProgramListRelationFilter;
    };

    export type FacultyOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        facultyTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        universityId?: SortOrder;
        university?: UniversityOrderByWithRelationInput;
        programs?: ProgramOrderByRelationAggregateInput;
    };

    export type FacultyWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: FacultyWhereInput | FacultyWhereInput[];
            OR?: FacultyWhereInput[];
            NOT?: FacultyWhereInput | FacultyWhereInput[];
            createdAt?: DateTimeFilter<'Faculty'> | Date | string;
            createdBy?: StringNullableFilter<'Faculty'> | string | null;
            updatedAt?: DateTimeFilter<'Faculty'> | Date | string;
            updatedBy?: StringNullableFilter<'Faculty'> | string | null;
            facultyTitle?: StringFilter<'Faculty'> | string;
            description?: StringNullableFilter<'Faculty'> | string | null;
            universityId?: StringFilter<'Faculty'> | string;
            university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>;
            programs?: ProgramListRelationFilter;
        },
        'id'
    >;

    export type FacultyOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        facultyTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        universityId?: SortOrder;
        _count?: FacultyCountOrderByAggregateInput;
        _max?: FacultyMaxOrderByAggregateInput;
        _min?: FacultyMinOrderByAggregateInput;
    };

    export type FacultyScalarWhereWithAggregatesInput = {
        AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[];
        OR?: FacultyScalarWhereWithAggregatesInput[];
        NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'Faculty'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'Faculty'> | Date | string;
        createdBy?: StringNullableWithAggregatesFilter<'Faculty'> | string | null;
        updatedAt?: DateTimeWithAggregatesFilter<'Faculty'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'Faculty'> | string | null;
        facultyTitle?: StringWithAggregatesFilter<'Faculty'> | string;
        description?: StringNullableWithAggregatesFilter<'Faculty'> | string | null;
        universityId?: StringWithAggregatesFilter<'Faculty'> | string;
    };

    export type CertificateRequirementsWhereInput = {
        AND?: CertificateRequirementsWhereInput | CertificateRequirementsWhereInput[];
        OR?: CertificateRequirementsWhereInput[];
        NOT?: CertificateRequirementsWhereInput | CertificateRequirementsWhereInput[];
        id?: StringFilter<'CertificateRequirements'> | string;
        createdAt?: DateTimeFilter<'CertificateRequirements'> | Date | string;
        createdBy?: StringNullableFilter<'CertificateRequirements'> | string | null;
        updatedAt?: DateTimeFilter<'CertificateRequirements'> | Date | string;
        updatedBy?: StringNullableFilter<'CertificateRequirements'> | string | null;
        certificateRequirementsTitle?: StringFilter<'CertificateRequirements'> | string;
        description?: StringNullableFilter<'CertificateRequirements'> | string | null;
        universities?: UniversityListRelationFilter;
        programs?: ProgramListRelationFilter;
    };

    export type CertificateRequirementsOrderByWithRelationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        certificateRequirementsTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        universities?: UniversityOrderByRelationAggregateInput;
        programs?: ProgramOrderByRelationAggregateInput;
    };

    export type CertificateRequirementsWhereUniqueInput = Prisma.AtLeast<
        {
            id?: string;
            AND?: CertificateRequirementsWhereInput | CertificateRequirementsWhereInput[];
            OR?: CertificateRequirementsWhereInput[];
            NOT?: CertificateRequirementsWhereInput | CertificateRequirementsWhereInput[];
            createdAt?: DateTimeFilter<'CertificateRequirements'> | Date | string;
            createdBy?: StringNullableFilter<'CertificateRequirements'> | string | null;
            updatedAt?: DateTimeFilter<'CertificateRequirements'> | Date | string;
            updatedBy?: StringNullableFilter<'CertificateRequirements'> | string | null;
            certificateRequirementsTitle?: StringFilter<'CertificateRequirements'> | string;
            description?: StringNullableFilter<'CertificateRequirements'> | string | null;
            universities?: UniversityListRelationFilter;
            programs?: ProgramListRelationFilter;
        },
        'id'
    >;

    export type CertificateRequirementsOrderByWithAggregationInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrderInput | SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrderInput | SortOrder;
        certificateRequirementsTitle?: SortOrder;
        description?: SortOrderInput | SortOrder;
        _count?: CertificateRequirementsCountOrderByAggregateInput;
        _max?: CertificateRequirementsMaxOrderByAggregateInput;
        _min?: CertificateRequirementsMinOrderByAggregateInput;
    };

    export type CertificateRequirementsScalarWhereWithAggregatesInput = {
        AND?:
            | CertificateRequirementsScalarWhereWithAggregatesInput
            | CertificateRequirementsScalarWhereWithAggregatesInput[];
        OR?: CertificateRequirementsScalarWhereWithAggregatesInput[];
        NOT?:
            | CertificateRequirementsScalarWhereWithAggregatesInput
            | CertificateRequirementsScalarWhereWithAggregatesInput[];
        id?: StringWithAggregatesFilter<'CertificateRequirements'> | string;
        createdAt?: DateTimeWithAggregatesFilter<'CertificateRequirements'> | Date | string;
        createdBy?: StringNullableWithAggregatesFilter<'CertificateRequirements'> | string | null;
        updatedAt?: DateTimeWithAggregatesFilter<'CertificateRequirements'> | Date | string;
        updatedBy?: StringNullableWithAggregatesFilter<'CertificateRequirements'> | string | null;
        certificateRequirementsTitle?: StringWithAggregatesFilter<'CertificateRequirements'> | string;
        description?: StringNullableWithAggregatesFilter<'CertificateRequirements'> | string | null;
    };

    export type IeltsExamCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        city: CityCreateNestedOneWithoutIeltsExamsInput;
        students?: IeltsRegistrationStudentCreateNestedManyWithoutExamInput;
    };

    export type IeltsExamUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        cityId: string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        students?: IeltsRegistrationStudentUncheckedCreateNestedManyWithoutExamInput;
    };

    export type IeltsExamUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneRequiredWithoutIeltsExamsNestedInput;
        students?: IeltsRegistrationStudentUpdateManyWithoutExamNestedInput;
    };

    export type IeltsExamUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        cityId?: StringFieldUpdateOperationsInput | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        students?: IeltsRegistrationStudentUncheckedUpdateManyWithoutExamNestedInput;
    };

    export type IeltsExamCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        cityId: string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
    };

    export type IeltsExamUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type IeltsExamUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        cityId?: StringFieldUpdateOperationsInput | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type IeltsRegistrationStudentCreateInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
        exam: IeltsExamCreateNestedOneWithoutStudentsInput;
    };

    export type IeltsRegistrationStudentUncheckedCreateInput = {
        id?: string;
        examId: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type IeltsRegistrationStudentUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        exam?: IeltsExamUpdateOneRequiredWithoutStudentsNestedInput;
    };

    export type IeltsRegistrationStudentUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        examId?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type IeltsRegistrationStudentCreateManyInput = {
        id?: string;
        examId: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type IeltsRegistrationStudentUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type IeltsRegistrationStudentUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        examId?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type CityCreateInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingCreateNestedManyWithoutCityInput;
        cvs?: CVCreateNestedManyWithoutCityInput;
        universities?: UniversityCreateNestedManyWithoutCityInput;
    };

    export type CityUncheckedCreateInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamUncheckedCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingUncheckedCreateNestedManyWithoutCityInput;
        cvs?: CVUncheckedCreateNestedManyWithoutCityInput;
        universities?: UniversityUncheckedCreateNestedManyWithoutCityInput;
    };

    export type CityUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUpdateManyWithoutCityNestedInput;
        cvs?: CVUpdateManyWithoutCityNestedInput;
        universities?: UniversityUpdateManyWithoutCityNestedInput;
    };

    export type CityUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUncheckedUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUncheckedUpdateManyWithoutCityNestedInput;
        cvs?: CVUncheckedUpdateManyWithoutCityNestedInput;
        universities?: UniversityUncheckedUpdateManyWithoutCityNestedInput;
    };

    export type CityCreateManyInput = {
        id?: string;
        name: string;
    };

    export type CityUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CityUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type MockRegistrationCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        title?: string | null;
        date: Date | string;
        branchId: string;
        isActive?: boolean;
        students?: MockRegistrationStudentCreateNestedManyWithoutMockRegistrationInput;
    };

    export type MockRegistrationUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        title?: string | null;
        date: Date | string;
        branchId: string;
        isActive?: boolean;
        students?: MockRegistrationStudentUncheckedCreateNestedManyWithoutMockRegistrationInput;
    };

    export type MockRegistrationUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
        students?: MockRegistrationStudentUpdateManyWithoutMockRegistrationNestedInput;
    };

    export type MockRegistrationUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
        students?: MockRegistrationStudentUncheckedUpdateManyWithoutMockRegistrationNestedInput;
    };

    export type MockRegistrationCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        title?: string | null;
        date: Date | string;
        branchId: string;
        isActive?: boolean;
    };

    export type MockRegistrationUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
    };

    export type MockRegistrationUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
    };

    export type MockRegistrationStudentCreateInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
        mockRegistration: MockRegistrationCreateNestedOneWithoutStudentsInput;
    };

    export type MockRegistrationStudentUncheckedCreateInput = {
        id?: string;
        studentId: string;
        mockRegistrationId: string;
        registeredAt?: Date | string;
    };

    export type MockRegistrationStudentUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        mockRegistration?: MockRegistrationUpdateOneRequiredWithoutStudentsNestedInput;
    };

    export type MockRegistrationStudentUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        mockRegistrationId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type MockRegistrationStudentCreateManyInput = {
        id?: string;
        studentId: string;
        mockRegistrationId: string;
        registeredAt?: Date | string;
    };

    export type MockRegistrationStudentUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type MockRegistrationStudentUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        mockRegistrationId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type JobHuntingCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
        company?: CompanyCreateNestedOneWithoutJobHuntingsInput;
        city?: CityCreateNestedOneWithoutJobHuntingsInput;
    };

    export type JobHuntingUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        companyId?: string | null;
        cityId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type JobHuntingUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
        company?: CompanyUpdateOneWithoutJobHuntingsNestedInput;
        city?: CityUpdateOneWithoutJobHuntingsNestedInput;
    };

    export type JobHuntingUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        companyId?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type JobHuntingCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        companyId?: string | null;
        cityId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type JobHuntingUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type JobHuntingUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        companyId?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CompanyCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        companyTitle: string;
        description?: string | null;
        companyLogo?: string | null;
        jobHuntings?: JobHuntingCreateNestedManyWithoutCompanyInput;
    };

    export type CompanyUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        companyTitle: string;
        description?: string | null;
        companyLogo?: string | null;
        jobHuntings?: JobHuntingUncheckedCreateNestedManyWithoutCompanyInput;
    };

    export type CompanyUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
        jobHuntings?: JobHuntingUpdateManyWithoutCompanyNestedInput;
    };

    export type CompanyUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
        jobHuntings?: JobHuntingUncheckedUpdateManyWithoutCompanyNestedInput;
    };

    export type CompanyCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        companyTitle: string;
        description?: string | null;
        companyLogo?: string | null;
    };

    export type CompanyUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CompanyUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CVCreateInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        city: CityCreateNestedOneWithoutCvsInput;
        skills?: CvSkillCreateNestedManyWithoutCvInput;
        tools?: CvToolCreateNestedManyWithoutCvInput;
    };

    export type CVUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        cityId: string;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        skills?: CvSkillUncheckedCreateNestedManyWithoutCvInput;
        tools?: CvToolUncheckedCreateNestedManyWithoutCvInput;
    };

    export type CVUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        city?: CityUpdateOneRequiredWithoutCvsNestedInput;
        skills?: CvSkillUpdateManyWithoutCvNestedInput;
        tools?: CvToolUpdateManyWithoutCvNestedInput;
    };

    export type CVUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: StringFieldUpdateOperationsInput | string;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        skills?: CvSkillUncheckedUpdateManyWithoutCvNestedInput;
        tools?: CvToolUncheckedUpdateManyWithoutCvNestedInput;
    };

    export type CVCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        cityId: string;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
    };

    export type CVUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    };

    export type CVUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: StringFieldUpdateOperationsInput | string;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    };

    export type SkillCreateInput = {
        id?: string;
        name: string;
        cvs?: CvSkillCreateNestedManyWithoutSkillInput;
    };

    export type SkillUncheckedCreateInput = {
        id?: string;
        name: string;
        cvs?: CvSkillUncheckedCreateNestedManyWithoutSkillInput;
    };

    export type SkillUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        cvs?: CvSkillUpdateManyWithoutSkillNestedInput;
    };

    export type SkillUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        cvs?: CvSkillUncheckedUpdateManyWithoutSkillNestedInput;
    };

    export type SkillCreateManyInput = {
        id?: string;
        name: string;
    };

    export type SkillUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type SkillUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type ToolCreateInput = {
        id?: string;
        name: string;
        cvs?: CvToolCreateNestedManyWithoutToolInput;
    };

    export type ToolUncheckedCreateInput = {
        id?: string;
        name: string;
        cvs?: CvToolUncheckedCreateNestedManyWithoutToolInput;
    };

    export type ToolUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        cvs?: CvToolUpdateManyWithoutToolNestedInput;
    };

    export type ToolUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        cvs?: CvToolUncheckedUpdateManyWithoutToolNestedInput;
    };

    export type ToolCreateManyInput = {
        id?: string;
        name: string;
    };

    export type ToolUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type ToolUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CvSkillCreateInput = {
        cv: CVCreateNestedOneWithoutSkillsInput;
        skill: SkillCreateNestedOneWithoutCvsInput;
    };

    export type CvSkillUncheckedCreateInput = {
        cvId: string;
        skillId: string;
    };

    export type CvSkillUpdateInput = {
        cv?: CVUpdateOneRequiredWithoutSkillsNestedInput;
        skill?: SkillUpdateOneRequiredWithoutCvsNestedInput;
    };

    export type CvSkillUncheckedUpdateInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
        skillId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvSkillCreateManyInput = {
        cvId: string;
        skillId: string;
    };

    export type CvSkillUpdateManyMutationInput = {};

    export type CvSkillUncheckedUpdateManyInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
        skillId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolCreateInput = {
        cv: CVCreateNestedOneWithoutToolsInput;
        tool: ToolCreateNestedOneWithoutCvsInput;
    };

    export type CvToolUncheckedCreateInput = {
        cvId: string;
        toolId: string;
    };

    export type CvToolUpdateInput = {
        cv?: CVUpdateOneRequiredWithoutToolsNestedInput;
        tool?: ToolUpdateOneRequiredWithoutCvsNestedInput;
    };

    export type CvToolUncheckedUpdateInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
        toolId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolCreateManyInput = {
        cvId: string;
        toolId: string;
    };

    export type CvToolUpdateManyMutationInput = {};

    export type CvToolUncheckedUpdateManyInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
        toolId?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateCreateInput = {
        id?: string;
        name: string;
    };

    export type CertificateUncheckedCreateInput = {
        id?: string;
        name: string;
    };

    export type CertificateUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateCreateManyInput = {
        id?: string;
        name: string;
    };

    export type CertificateUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type UniversityCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        city?: CityCreateNestedOneWithoutUniversitiesInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutUniversitiesInput;
        programs?: ProgramCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneWithoutUniversitiesNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutUniversitiesNestedInput;
        programs?: ProgramUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUncheckedUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
    };

    export type UniversityUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type UniversityUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        university: UniversityCreateNestedOneWithoutProgramsInput;
        faculty?: FacultyCreateNestedOneWithoutProgramsInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutProgramsInput;
    };

    export type ProgramUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        universityId: string;
        facultyId?: string | null;
    };

    export type ProgramUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        university?: UniversityUpdateOneRequiredWithoutProgramsNestedInput;
        faculty?: FacultyUpdateOneWithoutProgramsNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutProgramsNestedInput;
    };

    export type ProgramUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        universityId: string;
        facultyId?: string | null;
    };

    export type ProgramUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
    };

    export type ProgramUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type FacultyCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        university: UniversityCreateNestedOneWithoutFacultiesInput;
        programs?: ProgramCreateNestedManyWithoutFacultyInput;
    };

    export type FacultyUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        universityId: string;
        programs?: ProgramUncheckedCreateNestedManyWithoutFacultyInput;
    };

    export type FacultyUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        university?: UniversityUpdateOneRequiredWithoutFacultiesNestedInput;
        programs?: ProgramUpdateManyWithoutFacultyNestedInput;
    };

    export type FacultyUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universityId?: StringFieldUpdateOperationsInput | string;
        programs?: ProgramUncheckedUpdateManyWithoutFacultyNestedInput;
    };

    export type FacultyCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        universityId: string;
    };

    export type FacultyUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type FacultyUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universityId?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateRequirementsCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        universities?: UniversityCreateNestedManyWithoutCertificateRequirementInput;
        programs?: ProgramCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsUncheckedCreateInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        universities?: UniversityUncheckedCreateNestedManyWithoutCertificateRequirementInput;
        programs?: ProgramUncheckedCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universities?: UniversityUpdateManyWithoutCertificateRequirementNestedInput;
        programs?: ProgramUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type CertificateRequirementsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universities?: UniversityUncheckedUpdateManyWithoutCertificateRequirementNestedInput;
        programs?: ProgramUncheckedUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type CertificateRequirementsCreateManyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
    };

    export type CertificateRequirementsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CertificateRequirementsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type StringFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel>;
        in?: string[] | ListStringFieldRefInput<$PrismaModel>;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        mode?: QueryMode;
        not?: NestedStringFilter<$PrismaModel> | string;
    };

    export type DateTimeFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
    };

    export type StringNullableFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel> | null;
        in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        mode?: QueryMode;
        not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    };

    export type BoolNullableFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
        not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
    };

    export type CityScalarRelationFilter = {
        is?: CityWhereInput;
        isNot?: CityWhereInput;
    };

    export type IeltsRegistrationStudentListRelationFilter = {
        every?: IeltsRegistrationStudentWhereInput;
        some?: IeltsRegistrationStudentWhereInput;
        none?: IeltsRegistrationStudentWhereInput;
    };

    export type SortOrderInput = {
        sort: SortOrder;
        nulls?: NullsOrder;
    };

    export type IeltsRegistrationStudentOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type IeltsExamCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        dateExam?: SortOrder;
        cityId?: SortOrder;
        isActive?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
    };

    export type IeltsExamMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        dateExam?: SortOrder;
        cityId?: SortOrder;
        isActive?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
    };

    export type IeltsExamMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        dateExam?: SortOrder;
        cityId?: SortOrder;
        isActive?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
    };

    export type StringWithAggregatesFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel>;
        in?: string[] | ListStringFieldRefInput<$PrismaModel>;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        mode?: QueryMode;
        not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedStringFilter<$PrismaModel>;
        _max?: NestedStringFilter<$PrismaModel>;
    };

    export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedDateTimeFilter<$PrismaModel>;
        _max?: NestedDateTimeFilter<$PrismaModel>;
    };

    export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel> | null;
        in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        mode?: QueryMode;
        not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedStringNullableFilter<$PrismaModel>;
        _max?: NestedStringNullableFilter<$PrismaModel>;
    };

    export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
        not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedBoolNullableFilter<$PrismaModel>;
        _max?: NestedBoolNullableFilter<$PrismaModel>;
    };

    export type IeltsExamScalarRelationFilter = {
        is?: IeltsExamWhereInput;
        isNot?: IeltsExamWhereInput;
    };

    export type IeltsRegistrationStudentStudentIdExamIdCompoundUniqueInput = {
        studentId: string;
        examId: string;
    };

    export type IeltsRegistrationStudentCountOrderByAggregateInput = {
        id?: SortOrder;
        examId?: SortOrder;
        studentId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type IeltsRegistrationStudentMaxOrderByAggregateInput = {
        id?: SortOrder;
        examId?: SortOrder;
        studentId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type IeltsRegistrationStudentMinOrderByAggregateInput = {
        id?: SortOrder;
        examId?: SortOrder;
        studentId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type IeltsExamListRelationFilter = {
        every?: IeltsExamWhereInput;
        some?: IeltsExamWhereInput;
        none?: IeltsExamWhereInput;
    };

    export type JobHuntingListRelationFilter = {
        every?: JobHuntingWhereInput;
        some?: JobHuntingWhereInput;
        none?: JobHuntingWhereInput;
    };

    export type CVListRelationFilter = {
        every?: CVWhereInput;
        some?: CVWhereInput;
        none?: CVWhereInput;
    };

    export type UniversityListRelationFilter = {
        every?: UniversityWhereInput;
        some?: UniversityWhereInput;
        none?: UniversityWhereInput;
    };

    export type IeltsExamOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type JobHuntingOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type CVOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type UniversityOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type CityCountOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CityMaxOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CityMinOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type BoolFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
        not?: NestedBoolFilter<$PrismaModel> | boolean;
    };

    export type MockRegistrationStudentListRelationFilter = {
        every?: MockRegistrationStudentWhereInput;
        some?: MockRegistrationStudentWhereInput;
        none?: MockRegistrationStudentWhereInput;
    };

    export type MockRegistrationStudentOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type MockRegistrationCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
        title?: SortOrder;
        date?: SortOrder;
        branchId?: SortOrder;
        isActive?: SortOrder;
    };

    export type MockRegistrationMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
        title?: SortOrder;
        date?: SortOrder;
        branchId?: SortOrder;
        isActive?: SortOrder;
    };

    export type MockRegistrationMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        commentUser?: SortOrder;
        commentAdmin?: SortOrder;
        title?: SortOrder;
        date?: SortOrder;
        branchId?: SortOrder;
        isActive?: SortOrder;
    };

    export type BoolWithAggregatesFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
        not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedBoolFilter<$PrismaModel>;
        _max?: NestedBoolFilter<$PrismaModel>;
    };

    export type MockRegistrationScalarRelationFilter = {
        is?: MockRegistrationWhereInput;
        isNot?: MockRegistrationWhereInput;
    };

    export type MockRegistrationStudentStudentIdMockRegistrationIdCompoundUniqueInput = {
        studentId: string;
        mockRegistrationId: string;
    };

    export type MockRegistrationStudentCountOrderByAggregateInput = {
        id?: SortOrder;
        studentId?: SortOrder;
        mockRegistrationId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type MockRegistrationStudentMaxOrderByAggregateInput = {
        id?: SortOrder;
        studentId?: SortOrder;
        mockRegistrationId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type MockRegistrationStudentMinOrderByAggregateInput = {
        id?: SortOrder;
        studentId?: SortOrder;
        mockRegistrationId?: SortOrder;
        registeredAt?: SortOrder;
    };

    export type EnumWorkExperienceFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkExperience | EnumWorkExperienceFieldRefInput<$PrismaModel>;
        in?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        notIn?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        not?: NestedEnumWorkExperienceFilter<$PrismaModel> | $Enums.WorkExperience;
    };

    export type EnumWorkScheduleHoursNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkScheduleHours | EnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel> | $Enums.WorkScheduleHours | null;
    };

    export type EnumEmploymentTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel> | $Enums.EmploymentType | null;
    };

    export type EnumWorkModeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkMode | EnumWorkModeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkModeNullableFilter<$PrismaModel> | $Enums.WorkMode | null;
    };

    export type IntNullableFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel> | null;
        in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    };

    export type CompanyNullableScalarRelationFilter = {
        is?: CompanyWhereInput | null;
        isNot?: CompanyWhereInput | null;
    };

    export type CityNullableScalarRelationFilter = {
        is?: CityWhereInput | null;
        isNot?: CityWhereInput | null;
    };

    export type JobHuntingCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        workExperience?: SortOrder;
        companyId?: SortOrder;
        cityId?: SortOrder;
        certificateRequirements?: SortOrder;
        workScheduleHours?: SortOrder;
        employmentType?: SortOrder;
        workMode?: SortOrder;
        salary?: SortOrder;
        responsibilities?: SortOrder;
        requirements?: SortOrder;
        conditions?: SortOrder;
    };

    export type JobHuntingAvgOrderByAggregateInput = {
        salary?: SortOrder;
    };

    export type JobHuntingMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        workExperience?: SortOrder;
        companyId?: SortOrder;
        cityId?: SortOrder;
        certificateRequirements?: SortOrder;
        workScheduleHours?: SortOrder;
        employmentType?: SortOrder;
        workMode?: SortOrder;
        salary?: SortOrder;
        responsibilities?: SortOrder;
        requirements?: SortOrder;
        conditions?: SortOrder;
    };

    export type JobHuntingMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        workExperience?: SortOrder;
        companyId?: SortOrder;
        cityId?: SortOrder;
        certificateRequirements?: SortOrder;
        workScheduleHours?: SortOrder;
        employmentType?: SortOrder;
        workMode?: SortOrder;
        salary?: SortOrder;
        responsibilities?: SortOrder;
        requirements?: SortOrder;
        conditions?: SortOrder;
    };

    export type JobHuntingSumOrderByAggregateInput = {
        salary?: SortOrder;
    };

    export type EnumWorkExperienceWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkExperience | EnumWorkExperienceFieldRefInput<$PrismaModel>;
        in?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        notIn?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        not?: NestedEnumWorkExperienceWithAggregatesFilter<$PrismaModel> | $Enums.WorkExperience;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumWorkExperienceFilter<$PrismaModel>;
        _max?: NestedEnumWorkExperienceFilter<$PrismaModel>;
    };

    export type EnumWorkScheduleHoursNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkScheduleHours | EnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkScheduleHoursNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkScheduleHours | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel>;
        _max?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel>;
    };

    export type EnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>;
    };

    export type EnumWorkModeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkMode | EnumWorkModeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkMode | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumWorkModeNullableFilter<$PrismaModel>;
        _max?: NestedEnumWorkModeNullableFilter<$PrismaModel>;
    };

    export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel> | null;
        in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _avg?: NestedFloatNullableFilter<$PrismaModel>;
        _sum?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedIntNullableFilter<$PrismaModel>;
        _max?: NestedIntNullableFilter<$PrismaModel>;
    };

    export type CompanyCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        companyTitle?: SortOrder;
        description?: SortOrder;
        companyLogo?: SortOrder;
    };

    export type CompanyMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        companyTitle?: SortOrder;
        description?: SortOrder;
        companyLogo?: SortOrder;
    };

    export type CompanyMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        companyTitle?: SortOrder;
        description?: SortOrder;
        companyLogo?: SortOrder;
    };

    export type EnumDegreeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumDegreeNullableFilter<$PrismaModel> | $Enums.Degree | null;
    };

    export type DateTimeNullableFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    };

    export type CvSkillListRelationFilter = {
        every?: CvSkillWhereInput;
        some?: CvSkillWhereInput;
        none?: CvSkillWhereInput;
    };

    export type CvToolListRelationFilter = {
        every?: CvToolWhereInput;
        some?: CvToolWhereInput;
        none?: CvToolWhereInput;
    };

    export type CvSkillOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type CvToolOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type CVCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        updatedAt?: SortOrder;
        studentId?: SortOrder;
        description?: SortOrder;
        cityId?: SortOrder;
        degree?: SortOrder;
        universityTitle?: SortOrder;
        universityMajor?: SortOrder;
        graduationYear?: SortOrder;
        companyName?: SortOrder;
        position?: SortOrder;
        responsibilities?: SortOrder;
        startDate?: SortOrder;
        endDate?: SortOrder;
    };

    export type CVAvgOrderByAggregateInput = {
        graduationYear?: SortOrder;
    };

    export type CVMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        updatedAt?: SortOrder;
        studentId?: SortOrder;
        description?: SortOrder;
        cityId?: SortOrder;
        degree?: SortOrder;
        universityTitle?: SortOrder;
        universityMajor?: SortOrder;
        graduationYear?: SortOrder;
        companyName?: SortOrder;
        position?: SortOrder;
        responsibilities?: SortOrder;
        startDate?: SortOrder;
        endDate?: SortOrder;
    };

    export type CVMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        updatedAt?: SortOrder;
        studentId?: SortOrder;
        description?: SortOrder;
        cityId?: SortOrder;
        degree?: SortOrder;
        universityTitle?: SortOrder;
        universityMajor?: SortOrder;
        graduationYear?: SortOrder;
        companyName?: SortOrder;
        position?: SortOrder;
        responsibilities?: SortOrder;
        startDate?: SortOrder;
        endDate?: SortOrder;
    };

    export type CVSumOrderByAggregateInput = {
        graduationYear?: SortOrder;
    };

    export type EnumDegreeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumDegreeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Degree | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumDegreeNullableFilter<$PrismaModel>;
        _max?: NestedEnumDegreeNullableFilter<$PrismaModel>;
    };

    export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedDateTimeNullableFilter<$PrismaModel>;
        _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

    export type SkillCountOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type SkillMaxOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type SkillMinOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type ToolCountOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type ToolMaxOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type ToolMinOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CVScalarRelationFilter = {
        is?: CVWhereInput;
        isNot?: CVWhereInput;
    };

    export type SkillScalarRelationFilter = {
        is?: SkillWhereInput;
        isNot?: SkillWhereInput;
    };

    export type CvSkillCvIdSkillIdCompoundUniqueInput = {
        cvId: string;
        skillId: string;
    };

    export type CvSkillCountOrderByAggregateInput = {
        cvId?: SortOrder;
        skillId?: SortOrder;
    };

    export type CvSkillMaxOrderByAggregateInput = {
        cvId?: SortOrder;
        skillId?: SortOrder;
    };

    export type CvSkillMinOrderByAggregateInput = {
        cvId?: SortOrder;
        skillId?: SortOrder;
    };

    export type ToolScalarRelationFilter = {
        is?: ToolWhereInput;
        isNot?: ToolWhereInput;
    };

    export type CvToolCvIdToolIdCompoundUniqueInput = {
        cvId: string;
        toolId: string;
    };

    export type CvToolCountOrderByAggregateInput = {
        cvId?: SortOrder;
        toolId?: SortOrder;
    };

    export type CvToolMaxOrderByAggregateInput = {
        cvId?: SortOrder;
        toolId?: SortOrder;
    };

    export type CvToolMinOrderByAggregateInput = {
        cvId?: SortOrder;
        toolId?: SortOrder;
    };

    export type CertificateCountOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CertificateMaxOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type CertificateMinOrderByAggregateInput = {
        id?: SortOrder;
        name?: SortOrder;
    };

    export type EnumUniTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.UniType | EnumUniTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumUniTypeNullableFilter<$PrismaModel> | $Enums.UniType | null;
    };

    export type CertificateRequirementsNullableScalarRelationFilter = {
        is?: CertificateRequirementsWhereInput | null;
        isNot?: CertificateRequirementsWhereInput | null;
    };

    export type ProgramListRelationFilter = {
        every?: ProgramWhereInput;
        some?: ProgramWhereInput;
        none?: ProgramWhereInput;
    };

    export type FacultyListRelationFilter = {
        every?: FacultyWhereInput;
        some?: FacultyWhereInput;
        none?: FacultyWhereInput;
    };

    export type ProgramOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type FacultyOrderByRelationAggregateInput = {
        _count?: SortOrder;
    };

    export type UniversityCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        registrationDate?: SortOrder;
        type?: SortOrder;
        status?: SortOrder;
        contract?: SortOrder;
        contacts?: SortOrder;
        website?: SortOrder;
        email?: SortOrder;
        address?: SortOrder;
        cityId?: SortOrder;
        logo?: SortOrder;
        license?: SortOrder;
        certificateRequirementId?: SortOrder;
    };

    export type UniversityAvgOrderByAggregateInput = {
        contacts?: SortOrder;
    };

    export type UniversityMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        registrationDate?: SortOrder;
        type?: SortOrder;
        status?: SortOrder;
        contract?: SortOrder;
        contacts?: SortOrder;
        website?: SortOrder;
        email?: SortOrder;
        address?: SortOrder;
        cityId?: SortOrder;
        logo?: SortOrder;
        license?: SortOrder;
        certificateRequirementId?: SortOrder;
    };

    export type UniversityMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        description?: SortOrder;
        registrationDate?: SortOrder;
        type?: SortOrder;
        status?: SortOrder;
        contract?: SortOrder;
        contacts?: SortOrder;
        website?: SortOrder;
        email?: SortOrder;
        address?: SortOrder;
        cityId?: SortOrder;
        logo?: SortOrder;
        license?: SortOrder;
        certificateRequirementId?: SortOrder;
    };

    export type UniversitySumOrderByAggregateInput = {
        contacts?: SortOrder;
    };

    export type EnumUniTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.UniType | EnumUniTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumUniTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UniType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumUniTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumUniTypeNullableFilter<$PrismaModel>;
    };

    export type EnumStudyLanguageFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyLanguage | EnumStudyLanguageFieldRefInput<$PrismaModel>;
        in?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        notIn?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        not?: NestedEnumStudyLanguageFilter<$PrismaModel> | $Enums.StudyLanguage;
    };

    export type IntFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel>;
        in?: number[] | ListIntFieldRefInput<$PrismaModel>;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntFilter<$PrismaModel> | number;
    };

    export type EnumDegreeFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel>;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        not?: NestedEnumDegreeFilter<$PrismaModel> | $Enums.Degree;
    };

    export type EnumStudyTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyType | EnumStudyTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumStudyTypeNullableFilter<$PrismaModel> | $Enums.StudyType | null;
    };

    export type UniversityScalarRelationFilter = {
        is?: UniversityWhereInput;
        isNot?: UniversityWhereInput;
    };

    export type FacultyNullableScalarRelationFilter = {
        is?: FacultyWhereInput | null;
        isNot?: FacultyWhereInput | null;
    };

    export type ProgramCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        studyLanguage?: SortOrder;
        contract?: SortOrder;
        degree?: SortOrder;
        certificateRequirementId?: SortOrder;
        studyType?: SortOrder;
        universityId?: SortOrder;
        facultyId?: SortOrder;
    };

    export type ProgramAvgOrderByAggregateInput = {
        contract?: SortOrder;
    };

    export type ProgramMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        studyLanguage?: SortOrder;
        contract?: SortOrder;
        degree?: SortOrder;
        certificateRequirementId?: SortOrder;
        studyType?: SortOrder;
        universityId?: SortOrder;
        facultyId?: SortOrder;
    };

    export type ProgramMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        title?: SortOrder;
        studyLanguage?: SortOrder;
        contract?: SortOrder;
        degree?: SortOrder;
        certificateRequirementId?: SortOrder;
        studyType?: SortOrder;
        universityId?: SortOrder;
        facultyId?: SortOrder;
    };

    export type ProgramSumOrderByAggregateInput = {
        contract?: SortOrder;
    };

    export type EnumStudyLanguageWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyLanguage | EnumStudyLanguageFieldRefInput<$PrismaModel>;
        in?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        notIn?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        not?: NestedEnumStudyLanguageWithAggregatesFilter<$PrismaModel> | $Enums.StudyLanguage;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumStudyLanguageFilter<$PrismaModel>;
        _max?: NestedEnumStudyLanguageFilter<$PrismaModel>;
    };

    export type IntWithAggregatesFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel>;
        in?: number[] | ListIntFieldRefInput<$PrismaModel>;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
        _count?: NestedIntFilter<$PrismaModel>;
        _avg?: NestedFloatFilter<$PrismaModel>;
        _sum?: NestedIntFilter<$PrismaModel>;
        _min?: NestedIntFilter<$PrismaModel>;
        _max?: NestedIntFilter<$PrismaModel>;
    };

    export type EnumDegreeWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel>;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        not?: NestedEnumDegreeWithAggregatesFilter<$PrismaModel> | $Enums.Degree;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumDegreeFilter<$PrismaModel>;
        _max?: NestedEnumDegreeFilter<$PrismaModel>;
    };

    export type EnumStudyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyType | EnumStudyTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumStudyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudyType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumStudyTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumStudyTypeNullableFilter<$PrismaModel>;
    };

    export type FacultyCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        facultyTitle?: SortOrder;
        description?: SortOrder;
        universityId?: SortOrder;
    };

    export type FacultyMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        facultyTitle?: SortOrder;
        description?: SortOrder;
        universityId?: SortOrder;
    };

    export type FacultyMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        facultyTitle?: SortOrder;
        description?: SortOrder;
        universityId?: SortOrder;
    };

    export type CertificateRequirementsCountOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        certificateRequirementsTitle?: SortOrder;
        description?: SortOrder;
    };

    export type CertificateRequirementsMaxOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        certificateRequirementsTitle?: SortOrder;
        description?: SortOrder;
    };

    export type CertificateRequirementsMinOrderByAggregateInput = {
        id?: SortOrder;
        createdAt?: SortOrder;
        createdBy?: SortOrder;
        updatedAt?: SortOrder;
        updatedBy?: SortOrder;
        certificateRequirementsTitle?: SortOrder;
        description?: SortOrder;
    };

    export type CityCreateNestedOneWithoutIeltsExamsInput = {
        create?: XOR<CityCreateWithoutIeltsExamsInput, CityUncheckedCreateWithoutIeltsExamsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutIeltsExamsInput;
        connect?: CityWhereUniqueInput;
    };

    export type IeltsRegistrationStudentCreateNestedManyWithoutExamInput = {
        create?:
            | XOR<
                  IeltsRegistrationStudentCreateWithoutExamInput,
                  IeltsRegistrationStudentUncheckedCreateWithoutExamInput
              >
            | IeltsRegistrationStudentCreateWithoutExamInput[]
            | IeltsRegistrationStudentUncheckedCreateWithoutExamInput[];
        connectOrCreate?:
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput[];
        createMany?: IeltsRegistrationStudentCreateManyExamInputEnvelope;
        connect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
    };

    export type IeltsRegistrationStudentUncheckedCreateNestedManyWithoutExamInput = {
        create?:
            | XOR<
                  IeltsRegistrationStudentCreateWithoutExamInput,
                  IeltsRegistrationStudentUncheckedCreateWithoutExamInput
              >
            | IeltsRegistrationStudentCreateWithoutExamInput[]
            | IeltsRegistrationStudentUncheckedCreateWithoutExamInput[];
        connectOrCreate?:
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput[];
        createMany?: IeltsRegistrationStudentCreateManyExamInputEnvelope;
        connect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
    };

    export type StringFieldUpdateOperationsInput = {
        set?: string;
    };

    export type DateTimeFieldUpdateOperationsInput = {
        set?: Date | string;
    };

    export type NullableStringFieldUpdateOperationsInput = {
        set?: string | null;
    };

    export type NullableBoolFieldUpdateOperationsInput = {
        set?: boolean | null;
    };

    export type CityUpdateOneRequiredWithoutIeltsExamsNestedInput = {
        create?: XOR<CityCreateWithoutIeltsExamsInput, CityUncheckedCreateWithoutIeltsExamsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutIeltsExamsInput;
        upsert?: CityUpsertWithoutIeltsExamsInput;
        connect?: CityWhereUniqueInput;
        update?: XOR<
            XOR<CityUpdateToOneWithWhereWithoutIeltsExamsInput, CityUpdateWithoutIeltsExamsInput>,
            CityUncheckedUpdateWithoutIeltsExamsInput
        >;
    };

    export type IeltsRegistrationStudentUpdateManyWithoutExamNestedInput = {
        create?:
            | XOR<
                  IeltsRegistrationStudentCreateWithoutExamInput,
                  IeltsRegistrationStudentUncheckedCreateWithoutExamInput
              >
            | IeltsRegistrationStudentCreateWithoutExamInput[]
            | IeltsRegistrationStudentUncheckedCreateWithoutExamInput[];
        connectOrCreate?:
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput[];
        upsert?:
            | IeltsRegistrationStudentUpsertWithWhereUniqueWithoutExamInput
            | IeltsRegistrationStudentUpsertWithWhereUniqueWithoutExamInput[];
        createMany?: IeltsRegistrationStudentCreateManyExamInputEnvelope;
        set?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        disconnect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        delete?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        connect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        update?:
            | IeltsRegistrationStudentUpdateWithWhereUniqueWithoutExamInput
            | IeltsRegistrationStudentUpdateWithWhereUniqueWithoutExamInput[];
        updateMany?:
            | IeltsRegistrationStudentUpdateManyWithWhereWithoutExamInput
            | IeltsRegistrationStudentUpdateManyWithWhereWithoutExamInput[];
        deleteMany?: IeltsRegistrationStudentScalarWhereInput | IeltsRegistrationStudentScalarWhereInput[];
    };

    export type IeltsRegistrationStudentUncheckedUpdateManyWithoutExamNestedInput = {
        create?:
            | XOR<
                  IeltsRegistrationStudentCreateWithoutExamInput,
                  IeltsRegistrationStudentUncheckedCreateWithoutExamInput
              >
            | IeltsRegistrationStudentCreateWithoutExamInput[]
            | IeltsRegistrationStudentUncheckedCreateWithoutExamInput[];
        connectOrCreate?:
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput
            | IeltsRegistrationStudentCreateOrConnectWithoutExamInput[];
        upsert?:
            | IeltsRegistrationStudentUpsertWithWhereUniqueWithoutExamInput
            | IeltsRegistrationStudentUpsertWithWhereUniqueWithoutExamInput[];
        createMany?: IeltsRegistrationStudentCreateManyExamInputEnvelope;
        set?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        disconnect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        delete?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        connect?: IeltsRegistrationStudentWhereUniqueInput | IeltsRegistrationStudentWhereUniqueInput[];
        update?:
            | IeltsRegistrationStudentUpdateWithWhereUniqueWithoutExamInput
            | IeltsRegistrationStudentUpdateWithWhereUniqueWithoutExamInput[];
        updateMany?:
            | IeltsRegistrationStudentUpdateManyWithWhereWithoutExamInput
            | IeltsRegistrationStudentUpdateManyWithWhereWithoutExamInput[];
        deleteMany?: IeltsRegistrationStudentScalarWhereInput | IeltsRegistrationStudentScalarWhereInput[];
    };

    export type IeltsExamCreateNestedOneWithoutStudentsInput = {
        create?: XOR<IeltsExamCreateWithoutStudentsInput, IeltsExamUncheckedCreateWithoutStudentsInput>;
        connectOrCreate?: IeltsExamCreateOrConnectWithoutStudentsInput;
        connect?: IeltsExamWhereUniqueInput;
    };

    export type IeltsExamUpdateOneRequiredWithoutStudentsNestedInput = {
        create?: XOR<IeltsExamCreateWithoutStudentsInput, IeltsExamUncheckedCreateWithoutStudentsInput>;
        connectOrCreate?: IeltsExamCreateOrConnectWithoutStudentsInput;
        upsert?: IeltsExamUpsertWithoutStudentsInput;
        connect?: IeltsExamWhereUniqueInput;
        update?: XOR<
            XOR<IeltsExamUpdateToOneWithWhereWithoutStudentsInput, IeltsExamUpdateWithoutStudentsInput>,
            IeltsExamUncheckedUpdateWithoutStudentsInput
        >;
    };

    export type IeltsExamCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>
            | IeltsExamCreateWithoutCityInput[]
            | IeltsExamUncheckedCreateWithoutCityInput[];
        connectOrCreate?: IeltsExamCreateOrConnectWithoutCityInput | IeltsExamCreateOrConnectWithoutCityInput[];
        createMany?: IeltsExamCreateManyCityInputEnvelope;
        connect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
    };

    export type JobHuntingCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>
            | JobHuntingCreateWithoutCityInput[]
            | JobHuntingUncheckedCreateWithoutCityInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCityInput | JobHuntingCreateOrConnectWithoutCityInput[];
        createMany?: JobHuntingCreateManyCityInputEnvelope;
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
    };

    export type CVCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>
            | CVCreateWithoutCityInput[]
            | CVUncheckedCreateWithoutCityInput[];
        connectOrCreate?: CVCreateOrConnectWithoutCityInput | CVCreateOrConnectWithoutCityInput[];
        createMany?: CVCreateManyCityInputEnvelope;
        connect?: CVWhereUniqueInput | CVWhereUniqueInput[];
    };

    export type UniversityCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>
            | UniversityCreateWithoutCityInput[]
            | UniversityUncheckedCreateWithoutCityInput[];
        connectOrCreate?: UniversityCreateOrConnectWithoutCityInput | UniversityCreateOrConnectWithoutCityInput[];
        createMany?: UniversityCreateManyCityInputEnvelope;
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
    };

    export type IeltsExamUncheckedCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>
            | IeltsExamCreateWithoutCityInput[]
            | IeltsExamUncheckedCreateWithoutCityInput[];
        connectOrCreate?: IeltsExamCreateOrConnectWithoutCityInput | IeltsExamCreateOrConnectWithoutCityInput[];
        createMany?: IeltsExamCreateManyCityInputEnvelope;
        connect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
    };

    export type JobHuntingUncheckedCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>
            | JobHuntingCreateWithoutCityInput[]
            | JobHuntingUncheckedCreateWithoutCityInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCityInput | JobHuntingCreateOrConnectWithoutCityInput[];
        createMany?: JobHuntingCreateManyCityInputEnvelope;
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
    };

    export type CVUncheckedCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>
            | CVCreateWithoutCityInput[]
            | CVUncheckedCreateWithoutCityInput[];
        connectOrCreate?: CVCreateOrConnectWithoutCityInput | CVCreateOrConnectWithoutCityInput[];
        createMany?: CVCreateManyCityInputEnvelope;
        connect?: CVWhereUniqueInput | CVWhereUniqueInput[];
    };

    export type UniversityUncheckedCreateNestedManyWithoutCityInput = {
        create?:
            | XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>
            | UniversityCreateWithoutCityInput[]
            | UniversityUncheckedCreateWithoutCityInput[];
        connectOrCreate?: UniversityCreateOrConnectWithoutCityInput | UniversityCreateOrConnectWithoutCityInput[];
        createMany?: UniversityCreateManyCityInputEnvelope;
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
    };

    export type IeltsExamUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>
            | IeltsExamCreateWithoutCityInput[]
            | IeltsExamUncheckedCreateWithoutCityInput[];
        connectOrCreate?: IeltsExamCreateOrConnectWithoutCityInput | IeltsExamCreateOrConnectWithoutCityInput[];
        upsert?: IeltsExamUpsertWithWhereUniqueWithoutCityInput | IeltsExamUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: IeltsExamCreateManyCityInputEnvelope;
        set?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        disconnect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        delete?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        connect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        update?: IeltsExamUpdateWithWhereUniqueWithoutCityInput | IeltsExamUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: IeltsExamUpdateManyWithWhereWithoutCityInput | IeltsExamUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: IeltsExamScalarWhereInput | IeltsExamScalarWhereInput[];
    };

    export type JobHuntingUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>
            | JobHuntingCreateWithoutCityInput[]
            | JobHuntingUncheckedCreateWithoutCityInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCityInput | JobHuntingCreateOrConnectWithoutCityInput[];
        upsert?: JobHuntingUpsertWithWhereUniqueWithoutCityInput | JobHuntingUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: JobHuntingCreateManyCityInputEnvelope;
        set?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        disconnect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        delete?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        update?: JobHuntingUpdateWithWhereUniqueWithoutCityInput | JobHuntingUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: JobHuntingUpdateManyWithWhereWithoutCityInput | JobHuntingUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
    };

    export type CVUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>
            | CVCreateWithoutCityInput[]
            | CVUncheckedCreateWithoutCityInput[];
        connectOrCreate?: CVCreateOrConnectWithoutCityInput | CVCreateOrConnectWithoutCityInput[];
        upsert?: CVUpsertWithWhereUniqueWithoutCityInput | CVUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: CVCreateManyCityInputEnvelope;
        set?: CVWhereUniqueInput | CVWhereUniqueInput[];
        disconnect?: CVWhereUniqueInput | CVWhereUniqueInput[];
        delete?: CVWhereUniqueInput | CVWhereUniqueInput[];
        connect?: CVWhereUniqueInput | CVWhereUniqueInput[];
        update?: CVUpdateWithWhereUniqueWithoutCityInput | CVUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: CVUpdateManyWithWhereWithoutCityInput | CVUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: CVScalarWhereInput | CVScalarWhereInput[];
    };

    export type UniversityUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>
            | UniversityCreateWithoutCityInput[]
            | UniversityUncheckedCreateWithoutCityInput[];
        connectOrCreate?: UniversityCreateOrConnectWithoutCityInput | UniversityCreateOrConnectWithoutCityInput[];
        upsert?: UniversityUpsertWithWhereUniqueWithoutCityInput | UniversityUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: UniversityCreateManyCityInputEnvelope;
        set?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        disconnect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        delete?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        update?: UniversityUpdateWithWhereUniqueWithoutCityInput | UniversityUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: UniversityUpdateManyWithWhereWithoutCityInput | UniversityUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
    };

    export type IeltsExamUncheckedUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>
            | IeltsExamCreateWithoutCityInput[]
            | IeltsExamUncheckedCreateWithoutCityInput[];
        connectOrCreate?: IeltsExamCreateOrConnectWithoutCityInput | IeltsExamCreateOrConnectWithoutCityInput[];
        upsert?: IeltsExamUpsertWithWhereUniqueWithoutCityInput | IeltsExamUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: IeltsExamCreateManyCityInputEnvelope;
        set?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        disconnect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        delete?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        connect?: IeltsExamWhereUniqueInput | IeltsExamWhereUniqueInput[];
        update?: IeltsExamUpdateWithWhereUniqueWithoutCityInput | IeltsExamUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: IeltsExamUpdateManyWithWhereWithoutCityInput | IeltsExamUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: IeltsExamScalarWhereInput | IeltsExamScalarWhereInput[];
    };

    export type JobHuntingUncheckedUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>
            | JobHuntingCreateWithoutCityInput[]
            | JobHuntingUncheckedCreateWithoutCityInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCityInput | JobHuntingCreateOrConnectWithoutCityInput[];
        upsert?: JobHuntingUpsertWithWhereUniqueWithoutCityInput | JobHuntingUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: JobHuntingCreateManyCityInputEnvelope;
        set?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        disconnect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        delete?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        update?: JobHuntingUpdateWithWhereUniqueWithoutCityInput | JobHuntingUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: JobHuntingUpdateManyWithWhereWithoutCityInput | JobHuntingUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
    };

    export type CVUncheckedUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>
            | CVCreateWithoutCityInput[]
            | CVUncheckedCreateWithoutCityInput[];
        connectOrCreate?: CVCreateOrConnectWithoutCityInput | CVCreateOrConnectWithoutCityInput[];
        upsert?: CVUpsertWithWhereUniqueWithoutCityInput | CVUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: CVCreateManyCityInputEnvelope;
        set?: CVWhereUniqueInput | CVWhereUniqueInput[];
        disconnect?: CVWhereUniqueInput | CVWhereUniqueInput[];
        delete?: CVWhereUniqueInput | CVWhereUniqueInput[];
        connect?: CVWhereUniqueInput | CVWhereUniqueInput[];
        update?: CVUpdateWithWhereUniqueWithoutCityInput | CVUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: CVUpdateManyWithWhereWithoutCityInput | CVUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: CVScalarWhereInput | CVScalarWhereInput[];
    };

    export type UniversityUncheckedUpdateManyWithoutCityNestedInput = {
        create?:
            | XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>
            | UniversityCreateWithoutCityInput[]
            | UniversityUncheckedCreateWithoutCityInput[];
        connectOrCreate?: UniversityCreateOrConnectWithoutCityInput | UniversityCreateOrConnectWithoutCityInput[];
        upsert?: UniversityUpsertWithWhereUniqueWithoutCityInput | UniversityUpsertWithWhereUniqueWithoutCityInput[];
        createMany?: UniversityCreateManyCityInputEnvelope;
        set?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        disconnect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        delete?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        update?: UniversityUpdateWithWhereUniqueWithoutCityInput | UniversityUpdateWithWhereUniqueWithoutCityInput[];
        updateMany?: UniversityUpdateManyWithWhereWithoutCityInput | UniversityUpdateManyWithWhereWithoutCityInput[];
        deleteMany?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
    };

    export type MockRegistrationStudentCreateNestedManyWithoutMockRegistrationInput = {
        create?:
            | XOR<
                  MockRegistrationStudentCreateWithoutMockRegistrationInput,
                  MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
              >
            | MockRegistrationStudentCreateWithoutMockRegistrationInput[]
            | MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput[];
        connectOrCreate?:
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput[];
        createMany?: MockRegistrationStudentCreateManyMockRegistrationInputEnvelope;
        connect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
    };

    export type MockRegistrationStudentUncheckedCreateNestedManyWithoutMockRegistrationInput = {
        create?:
            | XOR<
                  MockRegistrationStudentCreateWithoutMockRegistrationInput,
                  MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
              >
            | MockRegistrationStudentCreateWithoutMockRegistrationInput[]
            | MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput[];
        connectOrCreate?:
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput[];
        createMany?: MockRegistrationStudentCreateManyMockRegistrationInputEnvelope;
        connect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
    };

    export type BoolFieldUpdateOperationsInput = {
        set?: boolean;
    };

    export type MockRegistrationStudentUpdateManyWithoutMockRegistrationNestedInput = {
        create?:
            | XOR<
                  MockRegistrationStudentCreateWithoutMockRegistrationInput,
                  MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
              >
            | MockRegistrationStudentCreateWithoutMockRegistrationInput[]
            | MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput[];
        connectOrCreate?:
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput[];
        upsert?:
            | MockRegistrationStudentUpsertWithWhereUniqueWithoutMockRegistrationInput
            | MockRegistrationStudentUpsertWithWhereUniqueWithoutMockRegistrationInput[];
        createMany?: MockRegistrationStudentCreateManyMockRegistrationInputEnvelope;
        set?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        disconnect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        delete?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        connect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        update?:
            | MockRegistrationStudentUpdateWithWhereUniqueWithoutMockRegistrationInput
            | MockRegistrationStudentUpdateWithWhereUniqueWithoutMockRegistrationInput[];
        updateMany?:
            | MockRegistrationStudentUpdateManyWithWhereWithoutMockRegistrationInput
            | MockRegistrationStudentUpdateManyWithWhereWithoutMockRegistrationInput[];
        deleteMany?: MockRegistrationStudentScalarWhereInput | MockRegistrationStudentScalarWhereInput[];
    };

    export type MockRegistrationStudentUncheckedUpdateManyWithoutMockRegistrationNestedInput = {
        create?:
            | XOR<
                  MockRegistrationStudentCreateWithoutMockRegistrationInput,
                  MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
              >
            | MockRegistrationStudentCreateWithoutMockRegistrationInput[]
            | MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput[];
        connectOrCreate?:
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput
            | MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput[];
        upsert?:
            | MockRegistrationStudentUpsertWithWhereUniqueWithoutMockRegistrationInput
            | MockRegistrationStudentUpsertWithWhereUniqueWithoutMockRegistrationInput[];
        createMany?: MockRegistrationStudentCreateManyMockRegistrationInputEnvelope;
        set?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        disconnect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        delete?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        connect?: MockRegistrationStudentWhereUniqueInput | MockRegistrationStudentWhereUniqueInput[];
        update?:
            | MockRegistrationStudentUpdateWithWhereUniqueWithoutMockRegistrationInput
            | MockRegistrationStudentUpdateWithWhereUniqueWithoutMockRegistrationInput[];
        updateMany?:
            | MockRegistrationStudentUpdateManyWithWhereWithoutMockRegistrationInput
            | MockRegistrationStudentUpdateManyWithWhereWithoutMockRegistrationInput[];
        deleteMany?: MockRegistrationStudentScalarWhereInput | MockRegistrationStudentScalarWhereInput[];
    };

    export type MockRegistrationCreateNestedOneWithoutStudentsInput = {
        create?: XOR<MockRegistrationCreateWithoutStudentsInput, MockRegistrationUncheckedCreateWithoutStudentsInput>;
        connectOrCreate?: MockRegistrationCreateOrConnectWithoutStudentsInput;
        connect?: MockRegistrationWhereUniqueInput;
    };

    export type MockRegistrationUpdateOneRequiredWithoutStudentsNestedInput = {
        create?: XOR<MockRegistrationCreateWithoutStudentsInput, MockRegistrationUncheckedCreateWithoutStudentsInput>;
        connectOrCreate?: MockRegistrationCreateOrConnectWithoutStudentsInput;
        upsert?: MockRegistrationUpsertWithoutStudentsInput;
        connect?: MockRegistrationWhereUniqueInput;
        update?: XOR<
            XOR<MockRegistrationUpdateToOneWithWhereWithoutStudentsInput, MockRegistrationUpdateWithoutStudentsInput>,
            MockRegistrationUncheckedUpdateWithoutStudentsInput
        >;
    };

    export type CompanyCreateNestedOneWithoutJobHuntingsInput = {
        create?: XOR<CompanyCreateWithoutJobHuntingsInput, CompanyUncheckedCreateWithoutJobHuntingsInput>;
        connectOrCreate?: CompanyCreateOrConnectWithoutJobHuntingsInput;
        connect?: CompanyWhereUniqueInput;
    };

    export type CityCreateNestedOneWithoutJobHuntingsInput = {
        create?: XOR<CityCreateWithoutJobHuntingsInput, CityUncheckedCreateWithoutJobHuntingsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutJobHuntingsInput;
        connect?: CityWhereUniqueInput;
    };

    export type EnumWorkExperienceFieldUpdateOperationsInput = {
        set?: $Enums.WorkExperience;
    };

    export type NullableEnumWorkScheduleHoursFieldUpdateOperationsInput = {
        set?: $Enums.WorkScheduleHours | null;
    };

    export type NullableEnumEmploymentTypeFieldUpdateOperationsInput = {
        set?: $Enums.EmploymentType | null;
    };

    export type NullableEnumWorkModeFieldUpdateOperationsInput = {
        set?: $Enums.WorkMode | null;
    };

    export type NullableIntFieldUpdateOperationsInput = {
        set?: number | null;
        increment?: number;
        decrement?: number;
        multiply?: number;
        divide?: number;
    };

    export type CompanyUpdateOneWithoutJobHuntingsNestedInput = {
        create?: XOR<CompanyCreateWithoutJobHuntingsInput, CompanyUncheckedCreateWithoutJobHuntingsInput>;
        connectOrCreate?: CompanyCreateOrConnectWithoutJobHuntingsInput;
        upsert?: CompanyUpsertWithoutJobHuntingsInput;
        disconnect?: CompanyWhereInput | boolean;
        delete?: CompanyWhereInput | boolean;
        connect?: CompanyWhereUniqueInput;
        update?: XOR<
            XOR<CompanyUpdateToOneWithWhereWithoutJobHuntingsInput, CompanyUpdateWithoutJobHuntingsInput>,
            CompanyUncheckedUpdateWithoutJobHuntingsInput
        >;
    };

    export type CityUpdateOneWithoutJobHuntingsNestedInput = {
        create?: XOR<CityCreateWithoutJobHuntingsInput, CityUncheckedCreateWithoutJobHuntingsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutJobHuntingsInput;
        upsert?: CityUpsertWithoutJobHuntingsInput;
        disconnect?: CityWhereInput | boolean;
        delete?: CityWhereInput | boolean;
        connect?: CityWhereUniqueInput;
        update?: XOR<
            XOR<CityUpdateToOneWithWhereWithoutJobHuntingsInput, CityUpdateWithoutJobHuntingsInput>,
            CityUncheckedUpdateWithoutJobHuntingsInput
        >;
    };

    export type JobHuntingCreateNestedManyWithoutCompanyInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>
            | JobHuntingCreateWithoutCompanyInput[]
            | JobHuntingUncheckedCreateWithoutCompanyInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCompanyInput | JobHuntingCreateOrConnectWithoutCompanyInput[];
        createMany?: JobHuntingCreateManyCompanyInputEnvelope;
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
    };

    export type JobHuntingUncheckedCreateNestedManyWithoutCompanyInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>
            | JobHuntingCreateWithoutCompanyInput[]
            | JobHuntingUncheckedCreateWithoutCompanyInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCompanyInput | JobHuntingCreateOrConnectWithoutCompanyInput[];
        createMany?: JobHuntingCreateManyCompanyInputEnvelope;
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
    };

    export type JobHuntingUpdateManyWithoutCompanyNestedInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>
            | JobHuntingCreateWithoutCompanyInput[]
            | JobHuntingUncheckedCreateWithoutCompanyInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCompanyInput | JobHuntingCreateOrConnectWithoutCompanyInput[];
        upsert?:
            | JobHuntingUpsertWithWhereUniqueWithoutCompanyInput
            | JobHuntingUpsertWithWhereUniqueWithoutCompanyInput[];
        createMany?: JobHuntingCreateManyCompanyInputEnvelope;
        set?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        disconnect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        delete?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        update?:
            | JobHuntingUpdateWithWhereUniqueWithoutCompanyInput
            | JobHuntingUpdateWithWhereUniqueWithoutCompanyInput[];
        updateMany?:
            | JobHuntingUpdateManyWithWhereWithoutCompanyInput
            | JobHuntingUpdateManyWithWhereWithoutCompanyInput[];
        deleteMany?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
    };

    export type JobHuntingUncheckedUpdateManyWithoutCompanyNestedInput = {
        create?:
            | XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>
            | JobHuntingCreateWithoutCompanyInput[]
            | JobHuntingUncheckedCreateWithoutCompanyInput[];
        connectOrCreate?: JobHuntingCreateOrConnectWithoutCompanyInput | JobHuntingCreateOrConnectWithoutCompanyInput[];
        upsert?:
            | JobHuntingUpsertWithWhereUniqueWithoutCompanyInput
            | JobHuntingUpsertWithWhereUniqueWithoutCompanyInput[];
        createMany?: JobHuntingCreateManyCompanyInputEnvelope;
        set?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        disconnect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        delete?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        connect?: JobHuntingWhereUniqueInput | JobHuntingWhereUniqueInput[];
        update?:
            | JobHuntingUpdateWithWhereUniqueWithoutCompanyInput
            | JobHuntingUpdateWithWhereUniqueWithoutCompanyInput[];
        updateMany?:
            | JobHuntingUpdateManyWithWhereWithoutCompanyInput
            | JobHuntingUpdateManyWithWhereWithoutCompanyInput[];
        deleteMany?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
    };

    export type CityCreateNestedOneWithoutCvsInput = {
        create?: XOR<CityCreateWithoutCvsInput, CityUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutCvsInput;
        connect?: CityWhereUniqueInput;
    };

    export type CvSkillCreateNestedManyWithoutCvInput = {
        create?:
            | XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>
            | CvSkillCreateWithoutCvInput[]
            | CvSkillUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutCvInput | CvSkillCreateOrConnectWithoutCvInput[];
        createMany?: CvSkillCreateManyCvInputEnvelope;
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
    };

    export type CvToolCreateNestedManyWithoutCvInput = {
        create?:
            | XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>
            | CvToolCreateWithoutCvInput[]
            | CvToolUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutCvInput | CvToolCreateOrConnectWithoutCvInput[];
        createMany?: CvToolCreateManyCvInputEnvelope;
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
    };

    export type CvSkillUncheckedCreateNestedManyWithoutCvInput = {
        create?:
            | XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>
            | CvSkillCreateWithoutCvInput[]
            | CvSkillUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutCvInput | CvSkillCreateOrConnectWithoutCvInput[];
        createMany?: CvSkillCreateManyCvInputEnvelope;
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
    };

    export type CvToolUncheckedCreateNestedManyWithoutCvInput = {
        create?:
            | XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>
            | CvToolCreateWithoutCvInput[]
            | CvToolUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutCvInput | CvToolCreateOrConnectWithoutCvInput[];
        createMany?: CvToolCreateManyCvInputEnvelope;
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
    };

    export type NullableEnumDegreeFieldUpdateOperationsInput = {
        set?: $Enums.Degree | null;
    };

    export type NullableDateTimeFieldUpdateOperationsInput = {
        set?: Date | string | null;
    };

    export type CityUpdateOneRequiredWithoutCvsNestedInput = {
        create?: XOR<CityCreateWithoutCvsInput, CityUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: CityCreateOrConnectWithoutCvsInput;
        upsert?: CityUpsertWithoutCvsInput;
        connect?: CityWhereUniqueInput;
        update?: XOR<
            XOR<CityUpdateToOneWithWhereWithoutCvsInput, CityUpdateWithoutCvsInput>,
            CityUncheckedUpdateWithoutCvsInput
        >;
    };

    export type CvSkillUpdateManyWithoutCvNestedInput = {
        create?:
            | XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>
            | CvSkillCreateWithoutCvInput[]
            | CvSkillUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutCvInput | CvSkillCreateOrConnectWithoutCvInput[];
        upsert?: CvSkillUpsertWithWhereUniqueWithoutCvInput | CvSkillUpsertWithWhereUniqueWithoutCvInput[];
        createMany?: CvSkillCreateManyCvInputEnvelope;
        set?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        disconnect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        delete?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        update?: CvSkillUpdateWithWhereUniqueWithoutCvInput | CvSkillUpdateWithWhereUniqueWithoutCvInput[];
        updateMany?: CvSkillUpdateManyWithWhereWithoutCvInput | CvSkillUpdateManyWithWhereWithoutCvInput[];
        deleteMany?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
    };

    export type CvToolUpdateManyWithoutCvNestedInput = {
        create?:
            | XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>
            | CvToolCreateWithoutCvInput[]
            | CvToolUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutCvInput | CvToolCreateOrConnectWithoutCvInput[];
        upsert?: CvToolUpsertWithWhereUniqueWithoutCvInput | CvToolUpsertWithWhereUniqueWithoutCvInput[];
        createMany?: CvToolCreateManyCvInputEnvelope;
        set?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        disconnect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        delete?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        update?: CvToolUpdateWithWhereUniqueWithoutCvInput | CvToolUpdateWithWhereUniqueWithoutCvInput[];
        updateMany?: CvToolUpdateManyWithWhereWithoutCvInput | CvToolUpdateManyWithWhereWithoutCvInput[];
        deleteMany?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
    };

    export type CvSkillUncheckedUpdateManyWithoutCvNestedInput = {
        create?:
            | XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>
            | CvSkillCreateWithoutCvInput[]
            | CvSkillUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutCvInput | CvSkillCreateOrConnectWithoutCvInput[];
        upsert?: CvSkillUpsertWithWhereUniqueWithoutCvInput | CvSkillUpsertWithWhereUniqueWithoutCvInput[];
        createMany?: CvSkillCreateManyCvInputEnvelope;
        set?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        disconnect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        delete?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        update?: CvSkillUpdateWithWhereUniqueWithoutCvInput | CvSkillUpdateWithWhereUniqueWithoutCvInput[];
        updateMany?: CvSkillUpdateManyWithWhereWithoutCvInput | CvSkillUpdateManyWithWhereWithoutCvInput[];
        deleteMany?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
    };

    export type CvToolUncheckedUpdateManyWithoutCvNestedInput = {
        create?:
            | XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>
            | CvToolCreateWithoutCvInput[]
            | CvToolUncheckedCreateWithoutCvInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutCvInput | CvToolCreateOrConnectWithoutCvInput[];
        upsert?: CvToolUpsertWithWhereUniqueWithoutCvInput | CvToolUpsertWithWhereUniqueWithoutCvInput[];
        createMany?: CvToolCreateManyCvInputEnvelope;
        set?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        disconnect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        delete?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        update?: CvToolUpdateWithWhereUniqueWithoutCvInput | CvToolUpdateWithWhereUniqueWithoutCvInput[];
        updateMany?: CvToolUpdateManyWithWhereWithoutCvInput | CvToolUpdateManyWithWhereWithoutCvInput[];
        deleteMany?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
    };

    export type CvSkillCreateNestedManyWithoutSkillInput = {
        create?:
            | XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>
            | CvSkillCreateWithoutSkillInput[]
            | CvSkillUncheckedCreateWithoutSkillInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutSkillInput | CvSkillCreateOrConnectWithoutSkillInput[];
        createMany?: CvSkillCreateManySkillInputEnvelope;
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
    };

    export type CvSkillUncheckedCreateNestedManyWithoutSkillInput = {
        create?:
            | XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>
            | CvSkillCreateWithoutSkillInput[]
            | CvSkillUncheckedCreateWithoutSkillInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutSkillInput | CvSkillCreateOrConnectWithoutSkillInput[];
        createMany?: CvSkillCreateManySkillInputEnvelope;
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
    };

    export type CvSkillUpdateManyWithoutSkillNestedInput = {
        create?:
            | XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>
            | CvSkillCreateWithoutSkillInput[]
            | CvSkillUncheckedCreateWithoutSkillInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutSkillInput | CvSkillCreateOrConnectWithoutSkillInput[];
        upsert?: CvSkillUpsertWithWhereUniqueWithoutSkillInput | CvSkillUpsertWithWhereUniqueWithoutSkillInput[];
        createMany?: CvSkillCreateManySkillInputEnvelope;
        set?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        disconnect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        delete?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        update?: CvSkillUpdateWithWhereUniqueWithoutSkillInput | CvSkillUpdateWithWhereUniqueWithoutSkillInput[];
        updateMany?: CvSkillUpdateManyWithWhereWithoutSkillInput | CvSkillUpdateManyWithWhereWithoutSkillInput[];
        deleteMany?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
    };

    export type CvSkillUncheckedUpdateManyWithoutSkillNestedInput = {
        create?:
            | XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>
            | CvSkillCreateWithoutSkillInput[]
            | CvSkillUncheckedCreateWithoutSkillInput[];
        connectOrCreate?: CvSkillCreateOrConnectWithoutSkillInput | CvSkillCreateOrConnectWithoutSkillInput[];
        upsert?: CvSkillUpsertWithWhereUniqueWithoutSkillInput | CvSkillUpsertWithWhereUniqueWithoutSkillInput[];
        createMany?: CvSkillCreateManySkillInputEnvelope;
        set?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        disconnect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        delete?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        connect?: CvSkillWhereUniqueInput | CvSkillWhereUniqueInput[];
        update?: CvSkillUpdateWithWhereUniqueWithoutSkillInput | CvSkillUpdateWithWhereUniqueWithoutSkillInput[];
        updateMany?: CvSkillUpdateManyWithWhereWithoutSkillInput | CvSkillUpdateManyWithWhereWithoutSkillInput[];
        deleteMany?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
    };

    export type CvToolCreateNestedManyWithoutToolInput = {
        create?:
            | XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>
            | CvToolCreateWithoutToolInput[]
            | CvToolUncheckedCreateWithoutToolInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutToolInput | CvToolCreateOrConnectWithoutToolInput[];
        createMany?: CvToolCreateManyToolInputEnvelope;
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
    };

    export type CvToolUncheckedCreateNestedManyWithoutToolInput = {
        create?:
            | XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>
            | CvToolCreateWithoutToolInput[]
            | CvToolUncheckedCreateWithoutToolInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutToolInput | CvToolCreateOrConnectWithoutToolInput[];
        createMany?: CvToolCreateManyToolInputEnvelope;
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
    };

    export type CvToolUpdateManyWithoutToolNestedInput = {
        create?:
            | XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>
            | CvToolCreateWithoutToolInput[]
            | CvToolUncheckedCreateWithoutToolInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutToolInput | CvToolCreateOrConnectWithoutToolInput[];
        upsert?: CvToolUpsertWithWhereUniqueWithoutToolInput | CvToolUpsertWithWhereUniqueWithoutToolInput[];
        createMany?: CvToolCreateManyToolInputEnvelope;
        set?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        disconnect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        delete?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        update?: CvToolUpdateWithWhereUniqueWithoutToolInput | CvToolUpdateWithWhereUniqueWithoutToolInput[];
        updateMany?: CvToolUpdateManyWithWhereWithoutToolInput | CvToolUpdateManyWithWhereWithoutToolInput[];
        deleteMany?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
    };

    export type CvToolUncheckedUpdateManyWithoutToolNestedInput = {
        create?:
            | XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>
            | CvToolCreateWithoutToolInput[]
            | CvToolUncheckedCreateWithoutToolInput[];
        connectOrCreate?: CvToolCreateOrConnectWithoutToolInput | CvToolCreateOrConnectWithoutToolInput[];
        upsert?: CvToolUpsertWithWhereUniqueWithoutToolInput | CvToolUpsertWithWhereUniqueWithoutToolInput[];
        createMany?: CvToolCreateManyToolInputEnvelope;
        set?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        disconnect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        delete?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        connect?: CvToolWhereUniqueInput | CvToolWhereUniqueInput[];
        update?: CvToolUpdateWithWhereUniqueWithoutToolInput | CvToolUpdateWithWhereUniqueWithoutToolInput[];
        updateMany?: CvToolUpdateManyWithWhereWithoutToolInput | CvToolUpdateManyWithWhereWithoutToolInput[];
        deleteMany?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
    };

    export type CVCreateNestedOneWithoutSkillsInput = {
        create?: XOR<CVCreateWithoutSkillsInput, CVUncheckedCreateWithoutSkillsInput>;
        connectOrCreate?: CVCreateOrConnectWithoutSkillsInput;
        connect?: CVWhereUniqueInput;
    };

    export type SkillCreateNestedOneWithoutCvsInput = {
        create?: XOR<SkillCreateWithoutCvsInput, SkillUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: SkillCreateOrConnectWithoutCvsInput;
        connect?: SkillWhereUniqueInput;
    };

    export type CVUpdateOneRequiredWithoutSkillsNestedInput = {
        create?: XOR<CVCreateWithoutSkillsInput, CVUncheckedCreateWithoutSkillsInput>;
        connectOrCreate?: CVCreateOrConnectWithoutSkillsInput;
        upsert?: CVUpsertWithoutSkillsInput;
        connect?: CVWhereUniqueInput;
        update?: XOR<
            XOR<CVUpdateToOneWithWhereWithoutSkillsInput, CVUpdateWithoutSkillsInput>,
            CVUncheckedUpdateWithoutSkillsInput
        >;
    };

    export type SkillUpdateOneRequiredWithoutCvsNestedInput = {
        create?: XOR<SkillCreateWithoutCvsInput, SkillUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: SkillCreateOrConnectWithoutCvsInput;
        upsert?: SkillUpsertWithoutCvsInput;
        connect?: SkillWhereUniqueInput;
        update?: XOR<
            XOR<SkillUpdateToOneWithWhereWithoutCvsInput, SkillUpdateWithoutCvsInput>,
            SkillUncheckedUpdateWithoutCvsInput
        >;
    };

    export type CVCreateNestedOneWithoutToolsInput = {
        create?: XOR<CVCreateWithoutToolsInput, CVUncheckedCreateWithoutToolsInput>;
        connectOrCreate?: CVCreateOrConnectWithoutToolsInput;
        connect?: CVWhereUniqueInput;
    };

    export type ToolCreateNestedOneWithoutCvsInput = {
        create?: XOR<ToolCreateWithoutCvsInput, ToolUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: ToolCreateOrConnectWithoutCvsInput;
        connect?: ToolWhereUniqueInput;
    };

    export type CVUpdateOneRequiredWithoutToolsNestedInput = {
        create?: XOR<CVCreateWithoutToolsInput, CVUncheckedCreateWithoutToolsInput>;
        connectOrCreate?: CVCreateOrConnectWithoutToolsInput;
        upsert?: CVUpsertWithoutToolsInput;
        connect?: CVWhereUniqueInput;
        update?: XOR<
            XOR<CVUpdateToOneWithWhereWithoutToolsInput, CVUpdateWithoutToolsInput>,
            CVUncheckedUpdateWithoutToolsInput
        >;
    };

    export type ToolUpdateOneRequiredWithoutCvsNestedInput = {
        create?: XOR<ToolCreateWithoutCvsInput, ToolUncheckedCreateWithoutCvsInput>;
        connectOrCreate?: ToolCreateOrConnectWithoutCvsInput;
        upsert?: ToolUpsertWithoutCvsInput;
        connect?: ToolWhereUniqueInput;
        update?: XOR<
            XOR<ToolUpdateToOneWithWhereWithoutCvsInput, ToolUpdateWithoutCvsInput>,
            ToolUncheckedUpdateWithoutCvsInput
        >;
    };

    export type CityCreateNestedOneWithoutUniversitiesInput = {
        create?: XOR<CityCreateWithoutUniversitiesInput, CityUncheckedCreateWithoutUniversitiesInput>;
        connectOrCreate?: CityCreateOrConnectWithoutUniversitiesInput;
        connect?: CityWhereUniqueInput;
    };

    export type CertificateRequirementsCreateNestedOneWithoutUniversitiesInput = {
        create?: XOR<
            CertificateRequirementsCreateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedCreateWithoutUniversitiesInput
        >;
        connectOrCreate?: CertificateRequirementsCreateOrConnectWithoutUniversitiesInput;
        connect?: CertificateRequirementsWhereUniqueInput;
    };

    export type ProgramCreateNestedManyWithoutUniversityInput = {
        create?:
            | XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>
            | ProgramCreateWithoutUniversityInput[]
            | ProgramUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutUniversityInput | ProgramCreateOrConnectWithoutUniversityInput[];
        createMany?: ProgramCreateManyUniversityInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type FacultyCreateNestedManyWithoutUniversityInput = {
        create?:
            | XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
            | FacultyCreateWithoutUniversityInput[]
            | FacultyUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: FacultyCreateOrConnectWithoutUniversityInput | FacultyCreateOrConnectWithoutUniversityInput[];
        createMany?: FacultyCreateManyUniversityInputEnvelope;
        connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    };

    export type ProgramUncheckedCreateNestedManyWithoutUniversityInput = {
        create?:
            | XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>
            | ProgramCreateWithoutUniversityInput[]
            | ProgramUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutUniversityInput | ProgramCreateOrConnectWithoutUniversityInput[];
        createMany?: ProgramCreateManyUniversityInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type FacultyUncheckedCreateNestedManyWithoutUniversityInput = {
        create?:
            | XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
            | FacultyCreateWithoutUniversityInput[]
            | FacultyUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: FacultyCreateOrConnectWithoutUniversityInput | FacultyCreateOrConnectWithoutUniversityInput[];
        createMany?: FacultyCreateManyUniversityInputEnvelope;
        connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
    };

    export type NullableEnumUniTypeFieldUpdateOperationsInput = {
        set?: $Enums.UniType | null;
    };

    export type CityUpdateOneWithoutUniversitiesNestedInput = {
        create?: XOR<CityCreateWithoutUniversitiesInput, CityUncheckedCreateWithoutUniversitiesInput>;
        connectOrCreate?: CityCreateOrConnectWithoutUniversitiesInput;
        upsert?: CityUpsertWithoutUniversitiesInput;
        disconnect?: CityWhereInput | boolean;
        delete?: CityWhereInput | boolean;
        connect?: CityWhereUniqueInput;
        update?: XOR<
            XOR<CityUpdateToOneWithWhereWithoutUniversitiesInput, CityUpdateWithoutUniversitiesInput>,
            CityUncheckedUpdateWithoutUniversitiesInput
        >;
    };

    export type CertificateRequirementsUpdateOneWithoutUniversitiesNestedInput = {
        create?: XOR<
            CertificateRequirementsCreateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedCreateWithoutUniversitiesInput
        >;
        connectOrCreate?: CertificateRequirementsCreateOrConnectWithoutUniversitiesInput;
        upsert?: CertificateRequirementsUpsertWithoutUniversitiesInput;
        disconnect?: CertificateRequirementsWhereInput | boolean;
        delete?: CertificateRequirementsWhereInput | boolean;
        connect?: CertificateRequirementsWhereUniqueInput;
        update?: XOR<
            XOR<
                CertificateRequirementsUpdateToOneWithWhereWithoutUniversitiesInput,
                CertificateRequirementsUpdateWithoutUniversitiesInput
            >,
            CertificateRequirementsUncheckedUpdateWithoutUniversitiesInput
        >;
    };

    export type ProgramUpdateManyWithoutUniversityNestedInput = {
        create?:
            | XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>
            | ProgramCreateWithoutUniversityInput[]
            | ProgramUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutUniversityInput | ProgramCreateOrConnectWithoutUniversityInput[];
        upsert?:
            | ProgramUpsertWithWhereUniqueWithoutUniversityInput
            | ProgramUpsertWithWhereUniqueWithoutUniversityInput[];
        createMany?: ProgramCreateManyUniversityInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?:
            | ProgramUpdateWithWhereUniqueWithoutUniversityInput
            | ProgramUpdateWithWhereUniqueWithoutUniversityInput[];
        updateMany?:
            | ProgramUpdateManyWithWhereWithoutUniversityInput
            | ProgramUpdateManyWithWhereWithoutUniversityInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type FacultyUpdateManyWithoutUniversityNestedInput = {
        create?:
            | XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
            | FacultyCreateWithoutUniversityInput[]
            | FacultyUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: FacultyCreateOrConnectWithoutUniversityInput | FacultyCreateOrConnectWithoutUniversityInput[];
        upsert?:
            | FacultyUpsertWithWhereUniqueWithoutUniversityInput
            | FacultyUpsertWithWhereUniqueWithoutUniversityInput[];
        createMany?: FacultyCreateManyUniversityInputEnvelope;
        set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        update?:
            | FacultyUpdateWithWhereUniqueWithoutUniversityInput
            | FacultyUpdateWithWhereUniqueWithoutUniversityInput[];
        updateMany?:
            | FacultyUpdateManyWithWhereWithoutUniversityInput
            | FacultyUpdateManyWithWhereWithoutUniversityInput[];
        deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
    };

    export type ProgramUncheckedUpdateManyWithoutUniversityNestedInput = {
        create?:
            | XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>
            | ProgramCreateWithoutUniversityInput[]
            | ProgramUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutUniversityInput | ProgramCreateOrConnectWithoutUniversityInput[];
        upsert?:
            | ProgramUpsertWithWhereUniqueWithoutUniversityInput
            | ProgramUpsertWithWhereUniqueWithoutUniversityInput[];
        createMany?: ProgramCreateManyUniversityInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?:
            | ProgramUpdateWithWhereUniqueWithoutUniversityInput
            | ProgramUpdateWithWhereUniqueWithoutUniversityInput[];
        updateMany?:
            | ProgramUpdateManyWithWhereWithoutUniversityInput
            | ProgramUpdateManyWithWhereWithoutUniversityInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type FacultyUncheckedUpdateManyWithoutUniversityNestedInput = {
        create?:
            | XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
            | FacultyCreateWithoutUniversityInput[]
            | FacultyUncheckedCreateWithoutUniversityInput[];
        connectOrCreate?: FacultyCreateOrConnectWithoutUniversityInput | FacultyCreateOrConnectWithoutUniversityInput[];
        upsert?:
            | FacultyUpsertWithWhereUniqueWithoutUniversityInput
            | FacultyUpsertWithWhereUniqueWithoutUniversityInput[];
        createMany?: FacultyCreateManyUniversityInputEnvelope;
        set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[];
        update?:
            | FacultyUpdateWithWhereUniqueWithoutUniversityInput
            | FacultyUpdateWithWhereUniqueWithoutUniversityInput[];
        updateMany?:
            | FacultyUpdateManyWithWhereWithoutUniversityInput
            | FacultyUpdateManyWithWhereWithoutUniversityInput[];
        deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
    };

    export type UniversityCreateNestedOneWithoutProgramsInput = {
        create?: XOR<UniversityCreateWithoutProgramsInput, UniversityUncheckedCreateWithoutProgramsInput>;
        connectOrCreate?: UniversityCreateOrConnectWithoutProgramsInput;
        connect?: UniversityWhereUniqueInput;
    };

    export type FacultyCreateNestedOneWithoutProgramsInput = {
        create?: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>;
        connectOrCreate?: FacultyCreateOrConnectWithoutProgramsInput;
        connect?: FacultyWhereUniqueInput;
    };

    export type CertificateRequirementsCreateNestedOneWithoutProgramsInput = {
        create?: XOR<
            CertificateRequirementsCreateWithoutProgramsInput,
            CertificateRequirementsUncheckedCreateWithoutProgramsInput
        >;
        connectOrCreate?: CertificateRequirementsCreateOrConnectWithoutProgramsInput;
        connect?: CertificateRequirementsWhereUniqueInput;
    };

    export type EnumStudyLanguageFieldUpdateOperationsInput = {
        set?: $Enums.StudyLanguage;
    };

    export type IntFieldUpdateOperationsInput = {
        set?: number;
        increment?: number;
        decrement?: number;
        multiply?: number;
        divide?: number;
    };

    export type EnumDegreeFieldUpdateOperationsInput = {
        set?: $Enums.Degree;
    };

    export type NullableEnumStudyTypeFieldUpdateOperationsInput = {
        set?: $Enums.StudyType | null;
    };

    export type UniversityUpdateOneRequiredWithoutProgramsNestedInput = {
        create?: XOR<UniversityCreateWithoutProgramsInput, UniversityUncheckedCreateWithoutProgramsInput>;
        connectOrCreate?: UniversityCreateOrConnectWithoutProgramsInput;
        upsert?: UniversityUpsertWithoutProgramsInput;
        connect?: UniversityWhereUniqueInput;
        update?: XOR<
            XOR<UniversityUpdateToOneWithWhereWithoutProgramsInput, UniversityUpdateWithoutProgramsInput>,
            UniversityUncheckedUpdateWithoutProgramsInput
        >;
    };

    export type FacultyUpdateOneWithoutProgramsNestedInput = {
        create?: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>;
        connectOrCreate?: FacultyCreateOrConnectWithoutProgramsInput;
        upsert?: FacultyUpsertWithoutProgramsInput;
        disconnect?: FacultyWhereInput | boolean;
        delete?: FacultyWhereInput | boolean;
        connect?: FacultyWhereUniqueInput;
        update?: XOR<
            XOR<FacultyUpdateToOneWithWhereWithoutProgramsInput, FacultyUpdateWithoutProgramsInput>,
            FacultyUncheckedUpdateWithoutProgramsInput
        >;
    };

    export type CertificateRequirementsUpdateOneWithoutProgramsNestedInput = {
        create?: XOR<
            CertificateRequirementsCreateWithoutProgramsInput,
            CertificateRequirementsUncheckedCreateWithoutProgramsInput
        >;
        connectOrCreate?: CertificateRequirementsCreateOrConnectWithoutProgramsInput;
        upsert?: CertificateRequirementsUpsertWithoutProgramsInput;
        disconnect?: CertificateRequirementsWhereInput | boolean;
        delete?: CertificateRequirementsWhereInput | boolean;
        connect?: CertificateRequirementsWhereUniqueInput;
        update?: XOR<
            XOR<
                CertificateRequirementsUpdateToOneWithWhereWithoutProgramsInput,
                CertificateRequirementsUpdateWithoutProgramsInput
            >,
            CertificateRequirementsUncheckedUpdateWithoutProgramsInput
        >;
    };

    export type UniversityCreateNestedOneWithoutFacultiesInput = {
        create?: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>;
        connectOrCreate?: UniversityCreateOrConnectWithoutFacultiesInput;
        connect?: UniversityWhereUniqueInput;
    };

    export type ProgramCreateNestedManyWithoutFacultyInput = {
        create?:
            | XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
            | ProgramCreateWithoutFacultyInput[]
            | ProgramUncheckedCreateWithoutFacultyInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[];
        createMany?: ProgramCreateManyFacultyInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type ProgramUncheckedCreateNestedManyWithoutFacultyInput = {
        create?:
            | XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
            | ProgramCreateWithoutFacultyInput[]
            | ProgramUncheckedCreateWithoutFacultyInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[];
        createMany?: ProgramCreateManyFacultyInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type UniversityUpdateOneRequiredWithoutFacultiesNestedInput = {
        create?: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>;
        connectOrCreate?: UniversityCreateOrConnectWithoutFacultiesInput;
        upsert?: UniversityUpsertWithoutFacultiesInput;
        connect?: UniversityWhereUniqueInput;
        update?: XOR<
            XOR<UniversityUpdateToOneWithWhereWithoutFacultiesInput, UniversityUpdateWithoutFacultiesInput>,
            UniversityUncheckedUpdateWithoutFacultiesInput
        >;
    };

    export type ProgramUpdateManyWithoutFacultyNestedInput = {
        create?:
            | XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
            | ProgramCreateWithoutFacultyInput[]
            | ProgramUncheckedCreateWithoutFacultyInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[];
        upsert?: ProgramUpsertWithWhereUniqueWithoutFacultyInput | ProgramUpsertWithWhereUniqueWithoutFacultyInput[];
        createMany?: ProgramCreateManyFacultyInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?: ProgramUpdateWithWhereUniqueWithoutFacultyInput | ProgramUpdateWithWhereUniqueWithoutFacultyInput[];
        updateMany?: ProgramUpdateManyWithWhereWithoutFacultyInput | ProgramUpdateManyWithWhereWithoutFacultyInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type ProgramUncheckedUpdateManyWithoutFacultyNestedInput = {
        create?:
            | XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>
            | ProgramCreateWithoutFacultyInput[]
            | ProgramUncheckedCreateWithoutFacultyInput[];
        connectOrCreate?: ProgramCreateOrConnectWithoutFacultyInput | ProgramCreateOrConnectWithoutFacultyInput[];
        upsert?: ProgramUpsertWithWhereUniqueWithoutFacultyInput | ProgramUpsertWithWhereUniqueWithoutFacultyInput[];
        createMany?: ProgramCreateManyFacultyInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?: ProgramUpdateWithWhereUniqueWithoutFacultyInput | ProgramUpdateWithWhereUniqueWithoutFacultyInput[];
        updateMany?: ProgramUpdateManyWithWhereWithoutFacultyInput | ProgramUpdateManyWithWhereWithoutFacultyInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type UniversityCreateNestedManyWithoutCertificateRequirementInput = {
        create?:
            | XOR<
                  UniversityCreateWithoutCertificateRequirementInput,
                  UniversityUncheckedCreateWithoutCertificateRequirementInput
              >
            | UniversityCreateWithoutCertificateRequirementInput[]
            | UniversityUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | UniversityCreateOrConnectWithoutCertificateRequirementInput
            | UniversityCreateOrConnectWithoutCertificateRequirementInput[];
        createMany?: UniversityCreateManyCertificateRequirementInputEnvelope;
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
    };

    export type ProgramCreateNestedManyWithoutCertificateRequirementInput = {
        create?:
            | XOR<
                  ProgramCreateWithoutCertificateRequirementInput,
                  ProgramUncheckedCreateWithoutCertificateRequirementInput
              >
            | ProgramCreateWithoutCertificateRequirementInput[]
            | ProgramUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | ProgramCreateOrConnectWithoutCertificateRequirementInput
            | ProgramCreateOrConnectWithoutCertificateRequirementInput[];
        createMany?: ProgramCreateManyCertificateRequirementInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type UniversityUncheckedCreateNestedManyWithoutCertificateRequirementInput = {
        create?:
            | XOR<
                  UniversityCreateWithoutCertificateRequirementInput,
                  UniversityUncheckedCreateWithoutCertificateRequirementInput
              >
            | UniversityCreateWithoutCertificateRequirementInput[]
            | UniversityUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | UniversityCreateOrConnectWithoutCertificateRequirementInput
            | UniversityCreateOrConnectWithoutCertificateRequirementInput[];
        createMany?: UniversityCreateManyCertificateRequirementInputEnvelope;
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
    };

    export type ProgramUncheckedCreateNestedManyWithoutCertificateRequirementInput = {
        create?:
            | XOR<
                  ProgramCreateWithoutCertificateRequirementInput,
                  ProgramUncheckedCreateWithoutCertificateRequirementInput
              >
            | ProgramCreateWithoutCertificateRequirementInput[]
            | ProgramUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | ProgramCreateOrConnectWithoutCertificateRequirementInput
            | ProgramCreateOrConnectWithoutCertificateRequirementInput[];
        createMany?: ProgramCreateManyCertificateRequirementInputEnvelope;
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
    };

    export type UniversityUpdateManyWithoutCertificateRequirementNestedInput = {
        create?:
            | XOR<
                  UniversityCreateWithoutCertificateRequirementInput,
                  UniversityUncheckedCreateWithoutCertificateRequirementInput
              >
            | UniversityCreateWithoutCertificateRequirementInput[]
            | UniversityUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | UniversityCreateOrConnectWithoutCertificateRequirementInput
            | UniversityCreateOrConnectWithoutCertificateRequirementInput[];
        upsert?:
            | UniversityUpsertWithWhereUniqueWithoutCertificateRequirementInput
            | UniversityUpsertWithWhereUniqueWithoutCertificateRequirementInput[];
        createMany?: UniversityCreateManyCertificateRequirementInputEnvelope;
        set?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        disconnect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        delete?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        update?:
            | UniversityUpdateWithWhereUniqueWithoutCertificateRequirementInput
            | UniversityUpdateWithWhereUniqueWithoutCertificateRequirementInput[];
        updateMany?:
            | UniversityUpdateManyWithWhereWithoutCertificateRequirementInput
            | UniversityUpdateManyWithWhereWithoutCertificateRequirementInput[];
        deleteMany?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
    };

    export type ProgramUpdateManyWithoutCertificateRequirementNestedInput = {
        create?:
            | XOR<
                  ProgramCreateWithoutCertificateRequirementInput,
                  ProgramUncheckedCreateWithoutCertificateRequirementInput
              >
            | ProgramCreateWithoutCertificateRequirementInput[]
            | ProgramUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | ProgramCreateOrConnectWithoutCertificateRequirementInput
            | ProgramCreateOrConnectWithoutCertificateRequirementInput[];
        upsert?:
            | ProgramUpsertWithWhereUniqueWithoutCertificateRequirementInput
            | ProgramUpsertWithWhereUniqueWithoutCertificateRequirementInput[];
        createMany?: ProgramCreateManyCertificateRequirementInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?:
            | ProgramUpdateWithWhereUniqueWithoutCertificateRequirementInput
            | ProgramUpdateWithWhereUniqueWithoutCertificateRequirementInput[];
        updateMany?:
            | ProgramUpdateManyWithWhereWithoutCertificateRequirementInput
            | ProgramUpdateManyWithWhereWithoutCertificateRequirementInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type UniversityUncheckedUpdateManyWithoutCertificateRequirementNestedInput = {
        create?:
            | XOR<
                  UniversityCreateWithoutCertificateRequirementInput,
                  UniversityUncheckedCreateWithoutCertificateRequirementInput
              >
            | UniversityCreateWithoutCertificateRequirementInput[]
            | UniversityUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | UniversityCreateOrConnectWithoutCertificateRequirementInput
            | UniversityCreateOrConnectWithoutCertificateRequirementInput[];
        upsert?:
            | UniversityUpsertWithWhereUniqueWithoutCertificateRequirementInput
            | UniversityUpsertWithWhereUniqueWithoutCertificateRequirementInput[];
        createMany?: UniversityCreateManyCertificateRequirementInputEnvelope;
        set?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        disconnect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        delete?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        connect?: UniversityWhereUniqueInput | UniversityWhereUniqueInput[];
        update?:
            | UniversityUpdateWithWhereUniqueWithoutCertificateRequirementInput
            | UniversityUpdateWithWhereUniqueWithoutCertificateRequirementInput[];
        updateMany?:
            | UniversityUpdateManyWithWhereWithoutCertificateRequirementInput
            | UniversityUpdateManyWithWhereWithoutCertificateRequirementInput[];
        deleteMany?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
    };

    export type ProgramUncheckedUpdateManyWithoutCertificateRequirementNestedInput = {
        create?:
            | XOR<
                  ProgramCreateWithoutCertificateRequirementInput,
                  ProgramUncheckedCreateWithoutCertificateRequirementInput
              >
            | ProgramCreateWithoutCertificateRequirementInput[]
            | ProgramUncheckedCreateWithoutCertificateRequirementInput[];
        connectOrCreate?:
            | ProgramCreateOrConnectWithoutCertificateRequirementInput
            | ProgramCreateOrConnectWithoutCertificateRequirementInput[];
        upsert?:
            | ProgramUpsertWithWhereUniqueWithoutCertificateRequirementInput
            | ProgramUpsertWithWhereUniqueWithoutCertificateRequirementInput[];
        createMany?: ProgramCreateManyCertificateRequirementInputEnvelope;
        set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[];
        update?:
            | ProgramUpdateWithWhereUniqueWithoutCertificateRequirementInput
            | ProgramUpdateWithWhereUniqueWithoutCertificateRequirementInput[];
        updateMany?:
            | ProgramUpdateManyWithWhereWithoutCertificateRequirementInput
            | ProgramUpdateManyWithWhereWithoutCertificateRequirementInput[];
        deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
    };

    export type NestedStringFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel>;
        in?: string[] | ListStringFieldRefInput<$PrismaModel>;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        not?: NestedStringFilter<$PrismaModel> | string;
    };

    export type NestedDateTimeFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
    };

    export type NestedStringNullableFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel> | null;
        in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    };

    export type NestedBoolNullableFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
        not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
    };

    export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel>;
        in?: string[] | ListStringFieldRefInput<$PrismaModel>;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedStringFilter<$PrismaModel>;
        _max?: NestedStringFilter<$PrismaModel>;
    };

    export type NestedIntFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel>;
        in?: number[] | ListIntFieldRefInput<$PrismaModel>;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntFilter<$PrismaModel> | number;
    };

    export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedDateTimeFilter<$PrismaModel>;
        _max?: NestedDateTimeFilter<$PrismaModel>;
    };

    export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: string | StringFieldRefInput<$PrismaModel> | null;
        in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
        lt?: string | StringFieldRefInput<$PrismaModel>;
        lte?: string | StringFieldRefInput<$PrismaModel>;
        gt?: string | StringFieldRefInput<$PrismaModel>;
        gte?: string | StringFieldRefInput<$PrismaModel>;
        contains?: string | StringFieldRefInput<$PrismaModel>;
        startsWith?: string | StringFieldRefInput<$PrismaModel>;
        endsWith?: string | StringFieldRefInput<$PrismaModel>;
        not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedStringNullableFilter<$PrismaModel>;
        _max?: NestedStringNullableFilter<$PrismaModel>;
    };

    export type NestedIntNullableFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel> | null;
        in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    };

    export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
        not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedBoolNullableFilter<$PrismaModel>;
        _max?: NestedBoolNullableFilter<$PrismaModel>;
    };

    export type NestedBoolFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
        not?: NestedBoolFilter<$PrismaModel> | boolean;
    };

    export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
        equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
        not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedBoolFilter<$PrismaModel>;
        _max?: NestedBoolFilter<$PrismaModel>;
    };

    export type NestedEnumWorkExperienceFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkExperience | EnumWorkExperienceFieldRefInput<$PrismaModel>;
        in?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        notIn?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        not?: NestedEnumWorkExperienceFilter<$PrismaModel> | $Enums.WorkExperience;
    };

    export type NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkScheduleHours | EnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel> | $Enums.WorkScheduleHours | null;
    };

    export type NestedEnumEmploymentTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel> | $Enums.EmploymentType | null;
    };

    export type NestedEnumWorkModeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkMode | EnumWorkModeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkModeNullableFilter<$PrismaModel> | $Enums.WorkMode | null;
    };

    export type NestedEnumWorkExperienceWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkExperience | EnumWorkExperienceFieldRefInput<$PrismaModel>;
        in?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        notIn?: $Enums.WorkExperience[] | ListEnumWorkExperienceFieldRefInput<$PrismaModel>;
        not?: NestedEnumWorkExperienceWithAggregatesFilter<$PrismaModel> | $Enums.WorkExperience;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumWorkExperienceFilter<$PrismaModel>;
        _max?: NestedEnumWorkExperienceFilter<$PrismaModel>;
    };

    export type NestedEnumWorkScheduleHoursNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkScheduleHours | EnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkScheduleHours[] | ListEnumWorkScheduleHoursFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkScheduleHoursNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkScheduleHours | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel>;
        _max?: NestedEnumWorkScheduleHoursNullableFilter<$PrismaModel>;
    };

    export type NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumEmploymentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumEmploymentTypeNullableFilter<$PrismaModel>;
    };

    export type NestedEnumWorkModeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.WorkMode | EnumWorkModeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.WorkMode[] | ListEnumWorkModeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumWorkModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkMode | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumWorkModeNullableFilter<$PrismaModel>;
        _max?: NestedEnumWorkModeNullableFilter<$PrismaModel>;
    };

    export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel> | null;
        in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _avg?: NestedFloatNullableFilter<$PrismaModel>;
        _sum?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedIntNullableFilter<$PrismaModel>;
        _max?: NestedIntNullableFilter<$PrismaModel>;
    };

    export type NestedFloatNullableFilter<$PrismaModel = never> = {
        equals?: number | FloatFieldRefInput<$PrismaModel> | null;
        in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
        notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
        lt?: number | FloatFieldRefInput<$PrismaModel>;
        lte?: number | FloatFieldRefInput<$PrismaModel>;
        gt?: number | FloatFieldRefInput<$PrismaModel>;
        gte?: number | FloatFieldRefInput<$PrismaModel>;
        not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    };

    export type NestedEnumDegreeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumDegreeNullableFilter<$PrismaModel> | $Enums.Degree | null;
    };

    export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    };

    export type NestedEnumDegreeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumDegreeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Degree | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumDegreeNullableFilter<$PrismaModel>;
        _max?: NestedEnumDegreeNullableFilter<$PrismaModel>;
    };

    export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
        in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
        lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
        not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedDateTimeNullableFilter<$PrismaModel>;
        _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

    export type NestedEnumUniTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.UniType | EnumUniTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumUniTypeNullableFilter<$PrismaModel> | $Enums.UniType | null;
    };

    export type NestedEnumUniTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.UniType | EnumUniTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.UniType[] | ListEnumUniTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumUniTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UniType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumUniTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumUniTypeNullableFilter<$PrismaModel>;
    };

    export type NestedEnumStudyLanguageFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyLanguage | EnumStudyLanguageFieldRefInput<$PrismaModel>;
        in?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        notIn?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        not?: NestedEnumStudyLanguageFilter<$PrismaModel> | $Enums.StudyLanguage;
    };

    export type NestedEnumDegreeFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel>;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        not?: NestedEnumDegreeFilter<$PrismaModel> | $Enums.Degree;
    };

    export type NestedEnumStudyTypeNullableFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyType | EnumStudyTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumStudyTypeNullableFilter<$PrismaModel> | $Enums.StudyType | null;
    };

    export type NestedEnumStudyLanguageWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyLanguage | EnumStudyLanguageFieldRefInput<$PrismaModel>;
        in?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        notIn?: $Enums.StudyLanguage[] | ListEnumStudyLanguageFieldRefInput<$PrismaModel>;
        not?: NestedEnumStudyLanguageWithAggregatesFilter<$PrismaModel> | $Enums.StudyLanguage;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumStudyLanguageFilter<$PrismaModel>;
        _max?: NestedEnumStudyLanguageFilter<$PrismaModel>;
    };

    export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
        equals?: number | IntFieldRefInput<$PrismaModel>;
        in?: number[] | ListIntFieldRefInput<$PrismaModel>;
        notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
        lt?: number | IntFieldRefInput<$PrismaModel>;
        lte?: number | IntFieldRefInput<$PrismaModel>;
        gt?: number | IntFieldRefInput<$PrismaModel>;
        gte?: number | IntFieldRefInput<$PrismaModel>;
        not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
        _count?: NestedIntFilter<$PrismaModel>;
        _avg?: NestedFloatFilter<$PrismaModel>;
        _sum?: NestedIntFilter<$PrismaModel>;
        _min?: NestedIntFilter<$PrismaModel>;
        _max?: NestedIntFilter<$PrismaModel>;
    };

    export type NestedFloatFilter<$PrismaModel = never> = {
        equals?: number | FloatFieldRefInput<$PrismaModel>;
        in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
        notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
        lt?: number | FloatFieldRefInput<$PrismaModel>;
        lte?: number | FloatFieldRefInput<$PrismaModel>;
        gt?: number | FloatFieldRefInput<$PrismaModel>;
        gte?: number | FloatFieldRefInput<$PrismaModel>;
        not?: NestedFloatFilter<$PrismaModel> | number;
    };

    export type NestedEnumDegreeWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.Degree | EnumDegreeFieldRefInput<$PrismaModel>;
        in?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        notIn?: $Enums.Degree[] | ListEnumDegreeFieldRefInput<$PrismaModel>;
        not?: NestedEnumDegreeWithAggregatesFilter<$PrismaModel> | $Enums.Degree;
        _count?: NestedIntFilter<$PrismaModel>;
        _min?: NestedEnumDegreeFilter<$PrismaModel>;
        _max?: NestedEnumDegreeFilter<$PrismaModel>;
    };

    export type NestedEnumStudyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
        equals?: $Enums.StudyType | EnumStudyTypeFieldRefInput<$PrismaModel> | null;
        in?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        notIn?: $Enums.StudyType[] | ListEnumStudyTypeFieldRefInput<$PrismaModel> | null;
        not?: NestedEnumStudyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudyType | null;
        _count?: NestedIntNullableFilter<$PrismaModel>;
        _min?: NestedEnumStudyTypeNullableFilter<$PrismaModel>;
        _max?: NestedEnumStudyTypeNullableFilter<$PrismaModel>;
    };

    export type CityCreateWithoutIeltsExamsInput = {
        id?: string;
        name: string;
        jobHuntings?: JobHuntingCreateNestedManyWithoutCityInput;
        cvs?: CVCreateNestedManyWithoutCityInput;
        universities?: UniversityCreateNestedManyWithoutCityInput;
    };

    export type CityUncheckedCreateWithoutIeltsExamsInput = {
        id?: string;
        name: string;
        jobHuntings?: JobHuntingUncheckedCreateNestedManyWithoutCityInput;
        cvs?: CVUncheckedCreateNestedManyWithoutCityInput;
        universities?: UniversityUncheckedCreateNestedManyWithoutCityInput;
    };

    export type CityCreateOrConnectWithoutIeltsExamsInput = {
        where: CityWhereUniqueInput;
        create: XOR<CityCreateWithoutIeltsExamsInput, CityUncheckedCreateWithoutIeltsExamsInput>;
    };

    export type IeltsRegistrationStudentCreateWithoutExamInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type IeltsRegistrationStudentUncheckedCreateWithoutExamInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type IeltsRegistrationStudentCreateOrConnectWithoutExamInput = {
        where: IeltsRegistrationStudentWhereUniqueInput;
        create: XOR<
            IeltsRegistrationStudentCreateWithoutExamInput,
            IeltsRegistrationStudentUncheckedCreateWithoutExamInput
        >;
    };

    export type IeltsRegistrationStudentCreateManyExamInputEnvelope = {
        data: IeltsRegistrationStudentCreateManyExamInput | IeltsRegistrationStudentCreateManyExamInput[];
        skipDuplicates?: boolean;
    };

    export type CityUpsertWithoutIeltsExamsInput = {
        update: XOR<CityUpdateWithoutIeltsExamsInput, CityUncheckedUpdateWithoutIeltsExamsInput>;
        create: XOR<CityCreateWithoutIeltsExamsInput, CityUncheckedCreateWithoutIeltsExamsInput>;
        where?: CityWhereInput;
    };

    export type CityUpdateToOneWithWhereWithoutIeltsExamsInput = {
        where?: CityWhereInput;
        data: XOR<CityUpdateWithoutIeltsExamsInput, CityUncheckedUpdateWithoutIeltsExamsInput>;
    };

    export type CityUpdateWithoutIeltsExamsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        jobHuntings?: JobHuntingUpdateManyWithoutCityNestedInput;
        cvs?: CVUpdateManyWithoutCityNestedInput;
        universities?: UniversityUpdateManyWithoutCityNestedInput;
    };

    export type CityUncheckedUpdateWithoutIeltsExamsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        jobHuntings?: JobHuntingUncheckedUpdateManyWithoutCityNestedInput;
        cvs?: CVUncheckedUpdateManyWithoutCityNestedInput;
        universities?: UniversityUncheckedUpdateManyWithoutCityNestedInput;
    };

    export type IeltsRegistrationStudentUpsertWithWhereUniqueWithoutExamInput = {
        where: IeltsRegistrationStudentWhereUniqueInput;
        update: XOR<
            IeltsRegistrationStudentUpdateWithoutExamInput,
            IeltsRegistrationStudentUncheckedUpdateWithoutExamInput
        >;
        create: XOR<
            IeltsRegistrationStudentCreateWithoutExamInput,
            IeltsRegistrationStudentUncheckedCreateWithoutExamInput
        >;
    };

    export type IeltsRegistrationStudentUpdateWithWhereUniqueWithoutExamInput = {
        where: IeltsRegistrationStudentWhereUniqueInput;
        data: XOR<
            IeltsRegistrationStudentUpdateWithoutExamInput,
            IeltsRegistrationStudentUncheckedUpdateWithoutExamInput
        >;
    };

    export type IeltsRegistrationStudentUpdateManyWithWhereWithoutExamInput = {
        where: IeltsRegistrationStudentScalarWhereInput;
        data: XOR<
            IeltsRegistrationStudentUpdateManyMutationInput,
            IeltsRegistrationStudentUncheckedUpdateManyWithoutExamInput
        >;
    };

    export type IeltsRegistrationStudentScalarWhereInput = {
        AND?: IeltsRegistrationStudentScalarWhereInput | IeltsRegistrationStudentScalarWhereInput[];
        OR?: IeltsRegistrationStudentScalarWhereInput[];
        NOT?: IeltsRegistrationStudentScalarWhereInput | IeltsRegistrationStudentScalarWhereInput[];
        id?: StringFilter<'IeltsRegistrationStudent'> | string;
        examId?: StringFilter<'IeltsRegistrationStudent'> | string;
        studentId?: StringFilter<'IeltsRegistrationStudent'> | string;
        registeredAt?: DateTimeFilter<'IeltsRegistrationStudent'> | Date | string;
    };

    export type IeltsExamCreateWithoutStudentsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        city: CityCreateNestedOneWithoutIeltsExamsInput;
    };

    export type IeltsExamUncheckedCreateWithoutStudentsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        cityId: string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
    };

    export type IeltsExamCreateOrConnectWithoutStudentsInput = {
        where: IeltsExamWhereUniqueInput;
        create: XOR<IeltsExamCreateWithoutStudentsInput, IeltsExamUncheckedCreateWithoutStudentsInput>;
    };

    export type IeltsExamUpsertWithoutStudentsInput = {
        update: XOR<IeltsExamUpdateWithoutStudentsInput, IeltsExamUncheckedUpdateWithoutStudentsInput>;
        create: XOR<IeltsExamCreateWithoutStudentsInput, IeltsExamUncheckedCreateWithoutStudentsInput>;
        where?: IeltsExamWhereInput;
    };

    export type IeltsExamUpdateToOneWithWhereWithoutStudentsInput = {
        where?: IeltsExamWhereInput;
        data: XOR<IeltsExamUpdateWithoutStudentsInput, IeltsExamUncheckedUpdateWithoutStudentsInput>;
    };

    export type IeltsExamUpdateWithoutStudentsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneRequiredWithoutIeltsExamsNestedInput;
    };

    export type IeltsExamUncheckedUpdateWithoutStudentsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        cityId?: StringFieldUpdateOperationsInput | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type IeltsExamCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        students?: IeltsRegistrationStudentCreateNestedManyWithoutExamInput;
    };

    export type IeltsExamUncheckedCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        students?: IeltsRegistrationStudentUncheckedCreateNestedManyWithoutExamInput;
    };

    export type IeltsExamCreateOrConnectWithoutCityInput = {
        where: IeltsExamWhereUniqueInput;
        create: XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>;
    };

    export type IeltsExamCreateManyCityInputEnvelope = {
        data: IeltsExamCreateManyCityInput | IeltsExamCreateManyCityInput[];
        skipDuplicates?: boolean;
    };

    export type JobHuntingCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
        company?: CompanyCreateNestedOneWithoutJobHuntingsInput;
    };

    export type JobHuntingUncheckedCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        companyId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type JobHuntingCreateOrConnectWithoutCityInput = {
        where: JobHuntingWhereUniqueInput;
        create: XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>;
    };

    export type JobHuntingCreateManyCityInputEnvelope = {
        data: JobHuntingCreateManyCityInput | JobHuntingCreateManyCityInput[];
        skipDuplicates?: boolean;
    };

    export type CVCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        skills?: CvSkillCreateNestedManyWithoutCvInput;
        tools?: CvToolCreateNestedManyWithoutCvInput;
    };

    export type CVUncheckedCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        skills?: CvSkillUncheckedCreateNestedManyWithoutCvInput;
        tools?: CvToolUncheckedCreateNestedManyWithoutCvInput;
    };

    export type CVCreateOrConnectWithoutCityInput = {
        where: CVWhereUniqueInput;
        create: XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>;
    };

    export type CVCreateManyCityInputEnvelope = {
        data: CVCreateManyCityInput | CVCreateManyCityInput[];
        skipDuplicates?: boolean;
    };

    export type UniversityCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutUniversitiesInput;
        programs?: ProgramCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUncheckedCreateWithoutCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityCreateOrConnectWithoutCityInput = {
        where: UniversityWhereUniqueInput;
        create: XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>;
    };

    export type UniversityCreateManyCityInputEnvelope = {
        data: UniversityCreateManyCityInput | UniversityCreateManyCityInput[];
        skipDuplicates?: boolean;
    };

    export type IeltsExamUpsertWithWhereUniqueWithoutCityInput = {
        where: IeltsExamWhereUniqueInput;
        update: XOR<IeltsExamUpdateWithoutCityInput, IeltsExamUncheckedUpdateWithoutCityInput>;
        create: XOR<IeltsExamCreateWithoutCityInput, IeltsExamUncheckedCreateWithoutCityInput>;
    };

    export type IeltsExamUpdateWithWhereUniqueWithoutCityInput = {
        where: IeltsExamWhereUniqueInput;
        data: XOR<IeltsExamUpdateWithoutCityInput, IeltsExamUncheckedUpdateWithoutCityInput>;
    };

    export type IeltsExamUpdateManyWithWhereWithoutCityInput = {
        where: IeltsExamScalarWhereInput;
        data: XOR<IeltsExamUpdateManyMutationInput, IeltsExamUncheckedUpdateManyWithoutCityInput>;
    };

    export type IeltsExamScalarWhereInput = {
        AND?: IeltsExamScalarWhereInput | IeltsExamScalarWhereInput[];
        OR?: IeltsExamScalarWhereInput[];
        NOT?: IeltsExamScalarWhereInput | IeltsExamScalarWhereInput[];
        id?: StringFilter<'IeltsExam'> | string;
        createdAt?: DateTimeFilter<'IeltsExam'> | Date | string;
        createdBy?: StringFilter<'IeltsExam'> | string;
        updatedAt?: DateTimeFilter<'IeltsExam'> | Date | string;
        updatedBy?: StringNullableFilter<'IeltsExam'> | string | null;
        dateExam?: DateTimeFilter<'IeltsExam'> | Date | string;
        cityId?: StringFilter<'IeltsExam'> | string;
        isActive?: BoolNullableFilter<'IeltsExam'> | boolean | null;
        commentUser?: StringNullableFilter<'IeltsExam'> | string | null;
        commentAdmin?: StringNullableFilter<'IeltsExam'> | string | null;
    };

    export type JobHuntingUpsertWithWhereUniqueWithoutCityInput = {
        where: JobHuntingWhereUniqueInput;
        update: XOR<JobHuntingUpdateWithoutCityInput, JobHuntingUncheckedUpdateWithoutCityInput>;
        create: XOR<JobHuntingCreateWithoutCityInput, JobHuntingUncheckedCreateWithoutCityInput>;
    };

    export type JobHuntingUpdateWithWhereUniqueWithoutCityInput = {
        where: JobHuntingWhereUniqueInput;
        data: XOR<JobHuntingUpdateWithoutCityInput, JobHuntingUncheckedUpdateWithoutCityInput>;
    };

    export type JobHuntingUpdateManyWithWhereWithoutCityInput = {
        where: JobHuntingScalarWhereInput;
        data: XOR<JobHuntingUpdateManyMutationInput, JobHuntingUncheckedUpdateManyWithoutCityInput>;
    };

    export type JobHuntingScalarWhereInput = {
        AND?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
        OR?: JobHuntingScalarWhereInput[];
        NOT?: JobHuntingScalarWhereInput | JobHuntingScalarWhereInput[];
        id?: StringFilter<'JobHunting'> | string;
        createdAt?: DateTimeFilter<'JobHunting'> | Date | string;
        createdBy?: StringFilter<'JobHunting'> | string;
        updatedAt?: DateTimeFilter<'JobHunting'> | Date | string;
        updatedBy?: StringNullableFilter<'JobHunting'> | string | null;
        title?: StringFilter<'JobHunting'> | string;
        description?: StringNullableFilter<'JobHunting'> | string | null;
        workExperience?: EnumWorkExperienceFilter<'JobHunting'> | $Enums.WorkExperience;
        companyId?: StringNullableFilter<'JobHunting'> | string | null;
        cityId?: StringNullableFilter<'JobHunting'> | string | null;
        certificateRequirements?: StringNullableFilter<'JobHunting'> | string | null;
        workScheduleHours?: EnumWorkScheduleHoursNullableFilter<'JobHunting'> | $Enums.WorkScheduleHours | null;
        employmentType?: EnumEmploymentTypeNullableFilter<'JobHunting'> | $Enums.EmploymentType | null;
        workMode?: EnumWorkModeNullableFilter<'JobHunting'> | $Enums.WorkMode | null;
        salary?: IntNullableFilter<'JobHunting'> | number | null;
        responsibilities?: StringNullableFilter<'JobHunting'> | string | null;
        requirements?: StringNullableFilter<'JobHunting'> | string | null;
        conditions?: StringNullableFilter<'JobHunting'> | string | null;
    };

    export type CVUpsertWithWhereUniqueWithoutCityInput = {
        where: CVWhereUniqueInput;
        update: XOR<CVUpdateWithoutCityInput, CVUncheckedUpdateWithoutCityInput>;
        create: XOR<CVCreateWithoutCityInput, CVUncheckedCreateWithoutCityInput>;
    };

    export type CVUpdateWithWhereUniqueWithoutCityInput = {
        where: CVWhereUniqueInput;
        data: XOR<CVUpdateWithoutCityInput, CVUncheckedUpdateWithoutCityInput>;
    };

    export type CVUpdateManyWithWhereWithoutCityInput = {
        where: CVScalarWhereInput;
        data: XOR<CVUpdateManyMutationInput, CVUncheckedUpdateManyWithoutCityInput>;
    };

    export type CVScalarWhereInput = {
        AND?: CVScalarWhereInput | CVScalarWhereInput[];
        OR?: CVScalarWhereInput[];
        NOT?: CVScalarWhereInput | CVScalarWhereInput[];
        id?: StringFilter<'CV'> | string;
        createdAt?: DateTimeFilter<'CV'> | Date | string;
        updatedAt?: DateTimeFilter<'CV'> | Date | string;
        studentId?: StringFilter<'CV'> | string;
        description?: StringNullableFilter<'CV'> | string | null;
        cityId?: StringFilter<'CV'> | string;
        degree?: EnumDegreeNullableFilter<'CV'> | $Enums.Degree | null;
        universityTitle?: StringNullableFilter<'CV'> | string | null;
        universityMajor?: StringNullableFilter<'CV'> | string | null;
        graduationYear?: IntNullableFilter<'CV'> | number | null;
        companyName?: StringNullableFilter<'CV'> | string | null;
        position?: StringNullableFilter<'CV'> | string | null;
        responsibilities?: StringNullableFilter<'CV'> | string | null;
        startDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
        endDate?: DateTimeNullableFilter<'CV'> | Date | string | null;
    };

    export type UniversityUpsertWithWhereUniqueWithoutCityInput = {
        where: UniversityWhereUniqueInput;
        update: XOR<UniversityUpdateWithoutCityInput, UniversityUncheckedUpdateWithoutCityInput>;
        create: XOR<UniversityCreateWithoutCityInput, UniversityUncheckedCreateWithoutCityInput>;
    };

    export type UniversityUpdateWithWhereUniqueWithoutCityInput = {
        where: UniversityWhereUniqueInput;
        data: XOR<UniversityUpdateWithoutCityInput, UniversityUncheckedUpdateWithoutCityInput>;
    };

    export type UniversityUpdateManyWithWhereWithoutCityInput = {
        where: UniversityScalarWhereInput;
        data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyWithoutCityInput>;
    };

    export type UniversityScalarWhereInput = {
        AND?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
        OR?: UniversityScalarWhereInput[];
        NOT?: UniversityScalarWhereInput | UniversityScalarWhereInput[];
        id?: StringFilter<'University'> | string;
        createdAt?: DateTimeFilter<'University'> | Date | string;
        createdBy?: StringNullableFilter<'University'> | string | null;
        updatedAt?: DateTimeFilter<'University'> | Date | string;
        updatedBy?: StringNullableFilter<'University'> | string | null;
        title?: StringFilter<'University'> | string;
        description?: StringNullableFilter<'University'> | string | null;
        registrationDate?: DateTimeFilter<'University'> | Date | string;
        type?: EnumUniTypeNullableFilter<'University'> | $Enums.UniType | null;
        status?: BoolNullableFilter<'University'> | boolean | null;
        contract?: StringFilter<'University'> | string;
        contacts?: IntNullableFilter<'University'> | number | null;
        website?: StringNullableFilter<'University'> | string | null;
        email?: StringNullableFilter<'University'> | string | null;
        address?: StringNullableFilter<'University'> | string | null;
        cityId?: StringNullableFilter<'University'> | string | null;
        logo?: StringNullableFilter<'University'> | string | null;
        license?: StringNullableFilter<'University'> | string | null;
        certificateRequirementId?: StringNullableFilter<'University'> | string | null;
    };

    export type MockRegistrationStudentCreateWithoutMockRegistrationInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type MockRegistrationStudentCreateOrConnectWithoutMockRegistrationInput = {
        where: MockRegistrationStudentWhereUniqueInput;
        create: XOR<
            MockRegistrationStudentCreateWithoutMockRegistrationInput,
            MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
        >;
    };

    export type MockRegistrationStudentCreateManyMockRegistrationInputEnvelope = {
        data:
            | MockRegistrationStudentCreateManyMockRegistrationInput
            | MockRegistrationStudentCreateManyMockRegistrationInput[];
        skipDuplicates?: boolean;
    };

    export type MockRegistrationStudentUpsertWithWhereUniqueWithoutMockRegistrationInput = {
        where: MockRegistrationStudentWhereUniqueInput;
        update: XOR<
            MockRegistrationStudentUpdateWithoutMockRegistrationInput,
            MockRegistrationStudentUncheckedUpdateWithoutMockRegistrationInput
        >;
        create: XOR<
            MockRegistrationStudentCreateWithoutMockRegistrationInput,
            MockRegistrationStudentUncheckedCreateWithoutMockRegistrationInput
        >;
    };

    export type MockRegistrationStudentUpdateWithWhereUniqueWithoutMockRegistrationInput = {
        where: MockRegistrationStudentWhereUniqueInput;
        data: XOR<
            MockRegistrationStudentUpdateWithoutMockRegistrationInput,
            MockRegistrationStudentUncheckedUpdateWithoutMockRegistrationInput
        >;
    };

    export type MockRegistrationStudentUpdateManyWithWhereWithoutMockRegistrationInput = {
        where: MockRegistrationStudentScalarWhereInput;
        data: XOR<
            MockRegistrationStudentUpdateManyMutationInput,
            MockRegistrationStudentUncheckedUpdateManyWithoutMockRegistrationInput
        >;
    };

    export type MockRegistrationStudentScalarWhereInput = {
        AND?: MockRegistrationStudentScalarWhereInput | MockRegistrationStudentScalarWhereInput[];
        OR?: MockRegistrationStudentScalarWhereInput[];
        NOT?: MockRegistrationStudentScalarWhereInput | MockRegistrationStudentScalarWhereInput[];
        id?: StringFilter<'MockRegistrationStudent'> | string;
        studentId?: StringFilter<'MockRegistrationStudent'> | string;
        mockRegistrationId?: StringFilter<'MockRegistrationStudent'> | string;
        registeredAt?: DateTimeFilter<'MockRegistrationStudent'> | Date | string;
    };

    export type MockRegistrationCreateWithoutStudentsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        title?: string | null;
        date: Date | string;
        branchId: string;
        isActive?: boolean;
    };

    export type MockRegistrationUncheckedCreateWithoutStudentsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
        title?: string | null;
        date: Date | string;
        branchId: string;
        isActive?: boolean;
    };

    export type MockRegistrationCreateOrConnectWithoutStudentsInput = {
        where: MockRegistrationWhereUniqueInput;
        create: XOR<MockRegistrationCreateWithoutStudentsInput, MockRegistrationUncheckedCreateWithoutStudentsInput>;
    };

    export type MockRegistrationUpsertWithoutStudentsInput = {
        update: XOR<MockRegistrationUpdateWithoutStudentsInput, MockRegistrationUncheckedUpdateWithoutStudentsInput>;
        create: XOR<MockRegistrationCreateWithoutStudentsInput, MockRegistrationUncheckedCreateWithoutStudentsInput>;
        where?: MockRegistrationWhereInput;
    };

    export type MockRegistrationUpdateToOneWithWhereWithoutStudentsInput = {
        where?: MockRegistrationWhereInput;
        data: XOR<MockRegistrationUpdateWithoutStudentsInput, MockRegistrationUncheckedUpdateWithoutStudentsInput>;
    };

    export type MockRegistrationUpdateWithoutStudentsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
    };

    export type MockRegistrationUncheckedUpdateWithoutStudentsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: NullableStringFieldUpdateOperationsInput | string | null;
        date?: DateTimeFieldUpdateOperationsInput | Date | string;
        branchId?: StringFieldUpdateOperationsInput | string;
        isActive?: BoolFieldUpdateOperationsInput | boolean;
    };

    export type CompanyCreateWithoutJobHuntingsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        companyTitle: string;
        description?: string | null;
        companyLogo?: string | null;
    };

    export type CompanyUncheckedCreateWithoutJobHuntingsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        companyTitle: string;
        description?: string | null;
        companyLogo?: string | null;
    };

    export type CompanyCreateOrConnectWithoutJobHuntingsInput = {
        where: CompanyWhereUniqueInput;
        create: XOR<CompanyCreateWithoutJobHuntingsInput, CompanyUncheckedCreateWithoutJobHuntingsInput>;
    };

    export type CityCreateWithoutJobHuntingsInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamCreateNestedManyWithoutCityInput;
        cvs?: CVCreateNestedManyWithoutCityInput;
        universities?: UniversityCreateNestedManyWithoutCityInput;
    };

    export type CityUncheckedCreateWithoutJobHuntingsInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamUncheckedCreateNestedManyWithoutCityInput;
        cvs?: CVUncheckedCreateNestedManyWithoutCityInput;
        universities?: UniversityUncheckedCreateNestedManyWithoutCityInput;
    };

    export type CityCreateOrConnectWithoutJobHuntingsInput = {
        where: CityWhereUniqueInput;
        create: XOR<CityCreateWithoutJobHuntingsInput, CityUncheckedCreateWithoutJobHuntingsInput>;
    };

    export type CompanyUpsertWithoutJobHuntingsInput = {
        update: XOR<CompanyUpdateWithoutJobHuntingsInput, CompanyUncheckedUpdateWithoutJobHuntingsInput>;
        create: XOR<CompanyCreateWithoutJobHuntingsInput, CompanyUncheckedCreateWithoutJobHuntingsInput>;
        where?: CompanyWhereInput;
    };

    export type CompanyUpdateToOneWithWhereWithoutJobHuntingsInput = {
        where?: CompanyWhereInput;
        data: XOR<CompanyUpdateWithoutJobHuntingsInput, CompanyUncheckedUpdateWithoutJobHuntingsInput>;
    };

    export type CompanyUpdateWithoutJobHuntingsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CompanyUncheckedUpdateWithoutJobHuntingsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        companyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        companyLogo?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CityUpsertWithoutJobHuntingsInput = {
        update: XOR<CityUpdateWithoutJobHuntingsInput, CityUncheckedUpdateWithoutJobHuntingsInput>;
        create: XOR<CityCreateWithoutJobHuntingsInput, CityUncheckedCreateWithoutJobHuntingsInput>;
        where?: CityWhereInput;
    };

    export type CityUpdateToOneWithWhereWithoutJobHuntingsInput = {
        where?: CityWhereInput;
        data: XOR<CityUpdateWithoutJobHuntingsInput, CityUncheckedUpdateWithoutJobHuntingsInput>;
    };

    export type CityUpdateWithoutJobHuntingsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUpdateManyWithoutCityNestedInput;
        cvs?: CVUpdateManyWithoutCityNestedInput;
        universities?: UniversityUpdateManyWithoutCityNestedInput;
    };

    export type CityUncheckedUpdateWithoutJobHuntingsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUncheckedUpdateManyWithoutCityNestedInput;
        cvs?: CVUncheckedUpdateManyWithoutCityNestedInput;
        universities?: UniversityUncheckedUpdateManyWithoutCityNestedInput;
    };

    export type JobHuntingCreateWithoutCompanyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
        city?: CityCreateNestedOneWithoutJobHuntingsInput;
    };

    export type JobHuntingUncheckedCreateWithoutCompanyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        cityId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type JobHuntingCreateOrConnectWithoutCompanyInput = {
        where: JobHuntingWhereUniqueInput;
        create: XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>;
    };

    export type JobHuntingCreateManyCompanyInputEnvelope = {
        data: JobHuntingCreateManyCompanyInput | JobHuntingCreateManyCompanyInput[];
        skipDuplicates?: boolean;
    };

    export type JobHuntingUpsertWithWhereUniqueWithoutCompanyInput = {
        where: JobHuntingWhereUniqueInput;
        update: XOR<JobHuntingUpdateWithoutCompanyInput, JobHuntingUncheckedUpdateWithoutCompanyInput>;
        create: XOR<JobHuntingCreateWithoutCompanyInput, JobHuntingUncheckedCreateWithoutCompanyInput>;
    };

    export type JobHuntingUpdateWithWhereUniqueWithoutCompanyInput = {
        where: JobHuntingWhereUniqueInput;
        data: XOR<JobHuntingUpdateWithoutCompanyInput, JobHuntingUncheckedUpdateWithoutCompanyInput>;
    };

    export type JobHuntingUpdateManyWithWhereWithoutCompanyInput = {
        where: JobHuntingScalarWhereInput;
        data: XOR<JobHuntingUpdateManyMutationInput, JobHuntingUncheckedUpdateManyWithoutCompanyInput>;
    };

    export type CityCreateWithoutCvsInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingCreateNestedManyWithoutCityInput;
        universities?: UniversityCreateNestedManyWithoutCityInput;
    };

    export type CityUncheckedCreateWithoutCvsInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamUncheckedCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingUncheckedCreateNestedManyWithoutCityInput;
        universities?: UniversityUncheckedCreateNestedManyWithoutCityInput;
    };

    export type CityCreateOrConnectWithoutCvsInput = {
        where: CityWhereUniqueInput;
        create: XOR<CityCreateWithoutCvsInput, CityUncheckedCreateWithoutCvsInput>;
    };

    export type CvSkillCreateWithoutCvInput = {
        skill: SkillCreateNestedOneWithoutCvsInput;
    };

    export type CvSkillUncheckedCreateWithoutCvInput = {
        skillId: string;
    };

    export type CvSkillCreateOrConnectWithoutCvInput = {
        where: CvSkillWhereUniqueInput;
        create: XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>;
    };

    export type CvSkillCreateManyCvInputEnvelope = {
        data: CvSkillCreateManyCvInput | CvSkillCreateManyCvInput[];
        skipDuplicates?: boolean;
    };

    export type CvToolCreateWithoutCvInput = {
        tool: ToolCreateNestedOneWithoutCvsInput;
    };

    export type CvToolUncheckedCreateWithoutCvInput = {
        toolId: string;
    };

    export type CvToolCreateOrConnectWithoutCvInput = {
        where: CvToolWhereUniqueInput;
        create: XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>;
    };

    export type CvToolCreateManyCvInputEnvelope = {
        data: CvToolCreateManyCvInput | CvToolCreateManyCvInput[];
        skipDuplicates?: boolean;
    };

    export type CityUpsertWithoutCvsInput = {
        update: XOR<CityUpdateWithoutCvsInput, CityUncheckedUpdateWithoutCvsInput>;
        create: XOR<CityCreateWithoutCvsInput, CityUncheckedCreateWithoutCvsInput>;
        where?: CityWhereInput;
    };

    export type CityUpdateToOneWithWhereWithoutCvsInput = {
        where?: CityWhereInput;
        data: XOR<CityUpdateWithoutCvsInput, CityUncheckedUpdateWithoutCvsInput>;
    };

    export type CityUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUpdateManyWithoutCityNestedInput;
        universities?: UniversityUpdateManyWithoutCityNestedInput;
    };

    export type CityUncheckedUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUncheckedUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUncheckedUpdateManyWithoutCityNestedInput;
        universities?: UniversityUncheckedUpdateManyWithoutCityNestedInput;
    };

    export type CvSkillUpsertWithWhereUniqueWithoutCvInput = {
        where: CvSkillWhereUniqueInput;
        update: XOR<CvSkillUpdateWithoutCvInput, CvSkillUncheckedUpdateWithoutCvInput>;
        create: XOR<CvSkillCreateWithoutCvInput, CvSkillUncheckedCreateWithoutCvInput>;
    };

    export type CvSkillUpdateWithWhereUniqueWithoutCvInput = {
        where: CvSkillWhereUniqueInput;
        data: XOR<CvSkillUpdateWithoutCvInput, CvSkillUncheckedUpdateWithoutCvInput>;
    };

    export type CvSkillUpdateManyWithWhereWithoutCvInput = {
        where: CvSkillScalarWhereInput;
        data: XOR<CvSkillUpdateManyMutationInput, CvSkillUncheckedUpdateManyWithoutCvInput>;
    };

    export type CvSkillScalarWhereInput = {
        AND?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
        OR?: CvSkillScalarWhereInput[];
        NOT?: CvSkillScalarWhereInput | CvSkillScalarWhereInput[];
        cvId?: StringFilter<'CvSkill'> | string;
        skillId?: StringFilter<'CvSkill'> | string;
    };

    export type CvToolUpsertWithWhereUniqueWithoutCvInput = {
        where: CvToolWhereUniqueInput;
        update: XOR<CvToolUpdateWithoutCvInput, CvToolUncheckedUpdateWithoutCvInput>;
        create: XOR<CvToolCreateWithoutCvInput, CvToolUncheckedCreateWithoutCvInput>;
    };

    export type CvToolUpdateWithWhereUniqueWithoutCvInput = {
        where: CvToolWhereUniqueInput;
        data: XOR<CvToolUpdateWithoutCvInput, CvToolUncheckedUpdateWithoutCvInput>;
    };

    export type CvToolUpdateManyWithWhereWithoutCvInput = {
        where: CvToolScalarWhereInput;
        data: XOR<CvToolUpdateManyMutationInput, CvToolUncheckedUpdateManyWithoutCvInput>;
    };

    export type CvToolScalarWhereInput = {
        AND?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
        OR?: CvToolScalarWhereInput[];
        NOT?: CvToolScalarWhereInput | CvToolScalarWhereInput[];
        cvId?: StringFilter<'CvTool'> | string;
        toolId?: StringFilter<'CvTool'> | string;
    };

    export type CvSkillCreateWithoutSkillInput = {
        cv: CVCreateNestedOneWithoutSkillsInput;
    };

    export type CvSkillUncheckedCreateWithoutSkillInput = {
        cvId: string;
    };

    export type CvSkillCreateOrConnectWithoutSkillInput = {
        where: CvSkillWhereUniqueInput;
        create: XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>;
    };

    export type CvSkillCreateManySkillInputEnvelope = {
        data: CvSkillCreateManySkillInput | CvSkillCreateManySkillInput[];
        skipDuplicates?: boolean;
    };

    export type CvSkillUpsertWithWhereUniqueWithoutSkillInput = {
        where: CvSkillWhereUniqueInput;
        update: XOR<CvSkillUpdateWithoutSkillInput, CvSkillUncheckedUpdateWithoutSkillInput>;
        create: XOR<CvSkillCreateWithoutSkillInput, CvSkillUncheckedCreateWithoutSkillInput>;
    };

    export type CvSkillUpdateWithWhereUniqueWithoutSkillInput = {
        where: CvSkillWhereUniqueInput;
        data: XOR<CvSkillUpdateWithoutSkillInput, CvSkillUncheckedUpdateWithoutSkillInput>;
    };

    export type CvSkillUpdateManyWithWhereWithoutSkillInput = {
        where: CvSkillScalarWhereInput;
        data: XOR<CvSkillUpdateManyMutationInput, CvSkillUncheckedUpdateManyWithoutSkillInput>;
    };

    export type CvToolCreateWithoutToolInput = {
        cv: CVCreateNestedOneWithoutToolsInput;
    };

    export type CvToolUncheckedCreateWithoutToolInput = {
        cvId: string;
    };

    export type CvToolCreateOrConnectWithoutToolInput = {
        where: CvToolWhereUniqueInput;
        create: XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>;
    };

    export type CvToolCreateManyToolInputEnvelope = {
        data: CvToolCreateManyToolInput | CvToolCreateManyToolInput[];
        skipDuplicates?: boolean;
    };

    export type CvToolUpsertWithWhereUniqueWithoutToolInput = {
        where: CvToolWhereUniqueInput;
        update: XOR<CvToolUpdateWithoutToolInput, CvToolUncheckedUpdateWithoutToolInput>;
        create: XOR<CvToolCreateWithoutToolInput, CvToolUncheckedCreateWithoutToolInput>;
    };

    export type CvToolUpdateWithWhereUniqueWithoutToolInput = {
        where: CvToolWhereUniqueInput;
        data: XOR<CvToolUpdateWithoutToolInput, CvToolUncheckedUpdateWithoutToolInput>;
    };

    export type CvToolUpdateManyWithWhereWithoutToolInput = {
        where: CvToolScalarWhereInput;
        data: XOR<CvToolUpdateManyMutationInput, CvToolUncheckedUpdateManyWithoutToolInput>;
    };

    export type CVCreateWithoutSkillsInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        city: CityCreateNestedOneWithoutCvsInput;
        tools?: CvToolCreateNestedManyWithoutCvInput;
    };

    export type CVUncheckedCreateWithoutSkillsInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        cityId: string;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        tools?: CvToolUncheckedCreateNestedManyWithoutCvInput;
    };

    export type CVCreateOrConnectWithoutSkillsInput = {
        where: CVWhereUniqueInput;
        create: XOR<CVCreateWithoutSkillsInput, CVUncheckedCreateWithoutSkillsInput>;
    };

    export type SkillCreateWithoutCvsInput = {
        id?: string;
        name: string;
    };

    export type SkillUncheckedCreateWithoutCvsInput = {
        id?: string;
        name: string;
    };

    export type SkillCreateOrConnectWithoutCvsInput = {
        where: SkillWhereUniqueInput;
        create: XOR<SkillCreateWithoutCvsInput, SkillUncheckedCreateWithoutCvsInput>;
    };

    export type CVUpsertWithoutSkillsInput = {
        update: XOR<CVUpdateWithoutSkillsInput, CVUncheckedUpdateWithoutSkillsInput>;
        create: XOR<CVCreateWithoutSkillsInput, CVUncheckedCreateWithoutSkillsInput>;
        where?: CVWhereInput;
    };

    export type CVUpdateToOneWithWhereWithoutSkillsInput = {
        where?: CVWhereInput;
        data: XOR<CVUpdateWithoutSkillsInput, CVUncheckedUpdateWithoutSkillsInput>;
    };

    export type CVUpdateWithoutSkillsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        city?: CityUpdateOneRequiredWithoutCvsNestedInput;
        tools?: CvToolUpdateManyWithoutCvNestedInput;
    };

    export type CVUncheckedUpdateWithoutSkillsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: StringFieldUpdateOperationsInput | string;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        tools?: CvToolUncheckedUpdateManyWithoutCvNestedInput;
    };

    export type SkillUpsertWithoutCvsInput = {
        update: XOR<SkillUpdateWithoutCvsInput, SkillUncheckedUpdateWithoutCvsInput>;
        create: XOR<SkillCreateWithoutCvsInput, SkillUncheckedCreateWithoutCvsInput>;
        where?: SkillWhereInput;
    };

    export type SkillUpdateToOneWithWhereWithoutCvsInput = {
        where?: SkillWhereInput;
        data: XOR<SkillUpdateWithoutCvsInput, SkillUncheckedUpdateWithoutCvsInput>;
    };

    export type SkillUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type SkillUncheckedUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CVCreateWithoutToolsInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        city: CityCreateNestedOneWithoutCvsInput;
        skills?: CvSkillCreateNestedManyWithoutCvInput;
    };

    export type CVUncheckedCreateWithoutToolsInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        cityId: string;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
        skills?: CvSkillUncheckedCreateNestedManyWithoutCvInput;
    };

    export type CVCreateOrConnectWithoutToolsInput = {
        where: CVWhereUniqueInput;
        create: XOR<CVCreateWithoutToolsInput, CVUncheckedCreateWithoutToolsInput>;
    };

    export type ToolCreateWithoutCvsInput = {
        id?: string;
        name: string;
    };

    export type ToolUncheckedCreateWithoutCvsInput = {
        id?: string;
        name: string;
    };

    export type ToolCreateOrConnectWithoutCvsInput = {
        where: ToolWhereUniqueInput;
        create: XOR<ToolCreateWithoutCvsInput, ToolUncheckedCreateWithoutCvsInput>;
    };

    export type CVUpsertWithoutToolsInput = {
        update: XOR<CVUpdateWithoutToolsInput, CVUncheckedUpdateWithoutToolsInput>;
        create: XOR<CVCreateWithoutToolsInput, CVUncheckedCreateWithoutToolsInput>;
        where?: CVWhereInput;
    };

    export type CVUpdateToOneWithWhereWithoutToolsInput = {
        where?: CVWhereInput;
        data: XOR<CVUpdateWithoutToolsInput, CVUncheckedUpdateWithoutToolsInput>;
    };

    export type CVUpdateWithoutToolsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        city?: CityUpdateOneRequiredWithoutCvsNestedInput;
        skills?: CvSkillUpdateManyWithoutCvNestedInput;
    };

    export type CVUncheckedUpdateWithoutToolsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: StringFieldUpdateOperationsInput | string;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        skills?: CvSkillUncheckedUpdateManyWithoutCvNestedInput;
    };

    export type ToolUpsertWithoutCvsInput = {
        update: XOR<ToolUpdateWithoutCvsInput, ToolUncheckedUpdateWithoutCvsInput>;
        create: XOR<ToolCreateWithoutCvsInput, ToolUncheckedCreateWithoutCvsInput>;
        where?: ToolWhereInput;
    };

    export type ToolUpdateToOneWithWhereWithoutCvsInput = {
        where?: ToolWhereInput;
        data: XOR<ToolUpdateWithoutCvsInput, ToolUncheckedUpdateWithoutCvsInput>;
    };

    export type ToolUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type ToolUncheckedUpdateWithoutCvsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
    };

    export type CityCreateWithoutUniversitiesInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingCreateNestedManyWithoutCityInput;
        cvs?: CVCreateNestedManyWithoutCityInput;
    };

    export type CityUncheckedCreateWithoutUniversitiesInput = {
        id?: string;
        name: string;
        ieltsExams?: IeltsExamUncheckedCreateNestedManyWithoutCityInput;
        jobHuntings?: JobHuntingUncheckedCreateNestedManyWithoutCityInput;
        cvs?: CVUncheckedCreateNestedManyWithoutCityInput;
    };

    export type CityCreateOrConnectWithoutUniversitiesInput = {
        where: CityWhereUniqueInput;
        create: XOR<CityCreateWithoutUniversitiesInput, CityUncheckedCreateWithoutUniversitiesInput>;
    };

    export type CertificateRequirementsCreateWithoutUniversitiesInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        programs?: ProgramCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsUncheckedCreateWithoutUniversitiesInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsCreateOrConnectWithoutUniversitiesInput = {
        where: CertificateRequirementsWhereUniqueInput;
        create: XOR<
            CertificateRequirementsCreateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedCreateWithoutUniversitiesInput
        >;
    };

    export type ProgramCreateWithoutUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        faculty?: FacultyCreateNestedOneWithoutProgramsInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutProgramsInput;
    };

    export type ProgramUncheckedCreateWithoutUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        facultyId?: string | null;
    };

    export type ProgramCreateOrConnectWithoutUniversityInput = {
        where: ProgramWhereUniqueInput;
        create: XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>;
    };

    export type ProgramCreateManyUniversityInputEnvelope = {
        data: ProgramCreateManyUniversityInput | ProgramCreateManyUniversityInput[];
        skipDuplicates?: boolean;
    };

    export type FacultyCreateWithoutUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        programs?: ProgramCreateNestedManyWithoutFacultyInput;
    };

    export type FacultyUncheckedCreateWithoutUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutFacultyInput;
    };

    export type FacultyCreateOrConnectWithoutUniversityInput = {
        where: FacultyWhereUniqueInput;
        create: XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>;
    };

    export type FacultyCreateManyUniversityInputEnvelope = {
        data: FacultyCreateManyUniversityInput | FacultyCreateManyUniversityInput[];
        skipDuplicates?: boolean;
    };

    export type CityUpsertWithoutUniversitiesInput = {
        update: XOR<CityUpdateWithoutUniversitiesInput, CityUncheckedUpdateWithoutUniversitiesInput>;
        create: XOR<CityCreateWithoutUniversitiesInput, CityUncheckedCreateWithoutUniversitiesInput>;
        where?: CityWhereInput;
    };

    export type CityUpdateToOneWithWhereWithoutUniversitiesInput = {
        where?: CityWhereInput;
        data: XOR<CityUpdateWithoutUniversitiesInput, CityUncheckedUpdateWithoutUniversitiesInput>;
    };

    export type CityUpdateWithoutUniversitiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUpdateManyWithoutCityNestedInput;
        cvs?: CVUpdateManyWithoutCityNestedInput;
    };

    export type CityUncheckedUpdateWithoutUniversitiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        name?: StringFieldUpdateOperationsInput | string;
        ieltsExams?: IeltsExamUncheckedUpdateManyWithoutCityNestedInput;
        jobHuntings?: JobHuntingUncheckedUpdateManyWithoutCityNestedInput;
        cvs?: CVUncheckedUpdateManyWithoutCityNestedInput;
    };

    export type CertificateRequirementsUpsertWithoutUniversitiesInput = {
        update: XOR<
            CertificateRequirementsUpdateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedUpdateWithoutUniversitiesInput
        >;
        create: XOR<
            CertificateRequirementsCreateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedCreateWithoutUniversitiesInput
        >;
        where?: CertificateRequirementsWhereInput;
    };

    export type CertificateRequirementsUpdateToOneWithWhereWithoutUniversitiesInput = {
        where?: CertificateRequirementsWhereInput;
        data: XOR<
            CertificateRequirementsUpdateWithoutUniversitiesInput,
            CertificateRequirementsUncheckedUpdateWithoutUniversitiesInput
        >;
    };

    export type CertificateRequirementsUpdateWithoutUniversitiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type CertificateRequirementsUncheckedUpdateWithoutUniversitiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type ProgramUpsertWithWhereUniqueWithoutUniversityInput = {
        where: ProgramWhereUniqueInput;
        update: XOR<ProgramUpdateWithoutUniversityInput, ProgramUncheckedUpdateWithoutUniversityInput>;
        create: XOR<ProgramCreateWithoutUniversityInput, ProgramUncheckedCreateWithoutUniversityInput>;
    };

    export type ProgramUpdateWithWhereUniqueWithoutUniversityInput = {
        where: ProgramWhereUniqueInput;
        data: XOR<ProgramUpdateWithoutUniversityInput, ProgramUncheckedUpdateWithoutUniversityInput>;
    };

    export type ProgramUpdateManyWithWhereWithoutUniversityInput = {
        where: ProgramScalarWhereInput;
        data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutUniversityInput>;
    };

    export type ProgramScalarWhereInput = {
        AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
        OR?: ProgramScalarWhereInput[];
        NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[];
        id?: StringFilter<'Program'> | string;
        createdAt?: DateTimeFilter<'Program'> | Date | string;
        createdBy?: StringNullableFilter<'Program'> | string | null;
        updatedAt?: DateTimeFilter<'Program'> | Date | string;
        updatedBy?: StringNullableFilter<'Program'> | string | null;
        title?: StringFilter<'Program'> | string;
        studyLanguage?: EnumStudyLanguageFilter<'Program'> | $Enums.StudyLanguage;
        contract?: IntFilter<'Program'> | number;
        degree?: EnumDegreeFilter<'Program'> | $Enums.Degree;
        certificateRequirementId?: StringNullableFilter<'Program'> | string | null;
        studyType?: EnumStudyTypeNullableFilter<'Program'> | $Enums.StudyType | null;
        universityId?: StringFilter<'Program'> | string;
        facultyId?: StringNullableFilter<'Program'> | string | null;
    };

    export type FacultyUpsertWithWhereUniqueWithoutUniversityInput = {
        where: FacultyWhereUniqueInput;
        update: XOR<FacultyUpdateWithoutUniversityInput, FacultyUncheckedUpdateWithoutUniversityInput>;
        create: XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>;
    };

    export type FacultyUpdateWithWhereUniqueWithoutUniversityInput = {
        where: FacultyWhereUniqueInput;
        data: XOR<FacultyUpdateWithoutUniversityInput, FacultyUncheckedUpdateWithoutUniversityInput>;
    };

    export type FacultyUpdateManyWithWhereWithoutUniversityInput = {
        where: FacultyScalarWhereInput;
        data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutUniversityInput>;
    };

    export type FacultyScalarWhereInput = {
        AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
        OR?: FacultyScalarWhereInput[];
        NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[];
        id?: StringFilter<'Faculty'> | string;
        createdAt?: DateTimeFilter<'Faculty'> | Date | string;
        createdBy?: StringNullableFilter<'Faculty'> | string | null;
        updatedAt?: DateTimeFilter<'Faculty'> | Date | string;
        updatedBy?: StringNullableFilter<'Faculty'> | string | null;
        facultyTitle?: StringFilter<'Faculty'> | string;
        description?: StringNullableFilter<'Faculty'> | string | null;
        universityId?: StringFilter<'Faculty'> | string;
    };

    export type UniversityCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        city?: CityCreateNestedOneWithoutUniversitiesInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutUniversitiesInput;
        faculties?: FacultyCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUncheckedCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
        faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityCreateOrConnectWithoutProgramsInput = {
        where: UniversityWhereUniqueInput;
        create: XOR<UniversityCreateWithoutProgramsInput, UniversityUncheckedCreateWithoutProgramsInput>;
    };

    export type FacultyCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        university: UniversityCreateNestedOneWithoutFacultiesInput;
    };

    export type FacultyUncheckedCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
        universityId: string;
    };

    export type FacultyCreateOrConnectWithoutProgramsInput = {
        where: FacultyWhereUniqueInput;
        create: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>;
    };

    export type CertificateRequirementsCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        universities?: UniversityCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsUncheckedCreateWithoutProgramsInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        certificateRequirementsTitle: string;
        description?: string | null;
        universities?: UniversityUncheckedCreateNestedManyWithoutCertificateRequirementInput;
    };

    export type CertificateRequirementsCreateOrConnectWithoutProgramsInput = {
        where: CertificateRequirementsWhereUniqueInput;
        create: XOR<
            CertificateRequirementsCreateWithoutProgramsInput,
            CertificateRequirementsUncheckedCreateWithoutProgramsInput
        >;
    };

    export type UniversityUpsertWithoutProgramsInput = {
        update: XOR<UniversityUpdateWithoutProgramsInput, UniversityUncheckedUpdateWithoutProgramsInput>;
        create: XOR<UniversityCreateWithoutProgramsInput, UniversityUncheckedCreateWithoutProgramsInput>;
        where?: UniversityWhereInput;
    };

    export type UniversityUpdateToOneWithWhereWithoutProgramsInput = {
        where?: UniversityWhereInput;
        data: XOR<UniversityUpdateWithoutProgramsInput, UniversityUncheckedUpdateWithoutProgramsInput>;
    };

    export type UniversityUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneWithoutUniversitiesNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutUniversitiesNestedInput;
        faculties?: FacultyUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        faculties?: FacultyUncheckedUpdateManyWithoutUniversityNestedInput;
    };

    export type FacultyUpsertWithoutProgramsInput = {
        update: XOR<FacultyUpdateWithoutProgramsInput, FacultyUncheckedUpdateWithoutProgramsInput>;
        create: XOR<FacultyCreateWithoutProgramsInput, FacultyUncheckedCreateWithoutProgramsInput>;
        where?: FacultyWhereInput;
    };

    export type FacultyUpdateToOneWithWhereWithoutProgramsInput = {
        where?: FacultyWhereInput;
        data: XOR<FacultyUpdateWithoutProgramsInput, FacultyUncheckedUpdateWithoutProgramsInput>;
    };

    export type FacultyUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        university?: UniversityUpdateOneRequiredWithoutFacultiesNestedInput;
    };

    export type FacultyUncheckedUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universityId?: StringFieldUpdateOperationsInput | string;
    };

    export type CertificateRequirementsUpsertWithoutProgramsInput = {
        update: XOR<
            CertificateRequirementsUpdateWithoutProgramsInput,
            CertificateRequirementsUncheckedUpdateWithoutProgramsInput
        >;
        create: XOR<
            CertificateRequirementsCreateWithoutProgramsInput,
            CertificateRequirementsUncheckedCreateWithoutProgramsInput
        >;
        where?: CertificateRequirementsWhereInput;
    };

    export type CertificateRequirementsUpdateToOneWithWhereWithoutProgramsInput = {
        where?: CertificateRequirementsWhereInput;
        data: XOR<
            CertificateRequirementsUpdateWithoutProgramsInput,
            CertificateRequirementsUncheckedUpdateWithoutProgramsInput
        >;
    };

    export type CertificateRequirementsUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universities?: UniversityUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type CertificateRequirementsUncheckedUpdateWithoutProgramsInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementsTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        universities?: UniversityUncheckedUpdateManyWithoutCertificateRequirementNestedInput;
    };

    export type UniversityCreateWithoutFacultiesInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        city?: CityCreateNestedOneWithoutUniversitiesInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutUniversitiesInput;
        programs?: ProgramCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUncheckedCreateWithoutFacultiesInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityCreateOrConnectWithoutFacultiesInput = {
        where: UniversityWhereUniqueInput;
        create: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>;
    };

    export type ProgramCreateWithoutFacultyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        university: UniversityCreateNestedOneWithoutProgramsInput;
        certificateRequirement?: CertificateRequirementsCreateNestedOneWithoutProgramsInput;
    };

    export type ProgramUncheckedCreateWithoutFacultyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        universityId: string;
    };

    export type ProgramCreateOrConnectWithoutFacultyInput = {
        where: ProgramWhereUniqueInput;
        create: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>;
    };

    export type ProgramCreateManyFacultyInputEnvelope = {
        data: ProgramCreateManyFacultyInput | ProgramCreateManyFacultyInput[];
        skipDuplicates?: boolean;
    };

    export type UniversityUpsertWithoutFacultiesInput = {
        update: XOR<UniversityUpdateWithoutFacultiesInput, UniversityUncheckedUpdateWithoutFacultiesInput>;
        create: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>;
        where?: UniversityWhereInput;
    };

    export type UniversityUpdateToOneWithWhereWithoutFacultiesInput = {
        where?: UniversityWhereInput;
        data: XOR<UniversityUpdateWithoutFacultiesInput, UniversityUncheckedUpdateWithoutFacultiesInput>;
    };

    export type UniversityUpdateWithoutFacultiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneWithoutUniversitiesNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutUniversitiesNestedInput;
        programs?: ProgramUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateWithoutFacultiesInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutUniversityNestedInput;
    };

    export type ProgramUpsertWithWhereUniqueWithoutFacultyInput = {
        where: ProgramWhereUniqueInput;
        update: XOR<ProgramUpdateWithoutFacultyInput, ProgramUncheckedUpdateWithoutFacultyInput>;
        create: XOR<ProgramCreateWithoutFacultyInput, ProgramUncheckedCreateWithoutFacultyInput>;
    };

    export type ProgramUpdateWithWhereUniqueWithoutFacultyInput = {
        where: ProgramWhereUniqueInput;
        data: XOR<ProgramUpdateWithoutFacultyInput, ProgramUncheckedUpdateWithoutFacultyInput>;
    };

    export type ProgramUpdateManyWithWhereWithoutFacultyInput = {
        where: ProgramScalarWhereInput;
        data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutFacultyInput>;
    };

    export type UniversityCreateWithoutCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        city?: CityCreateNestedOneWithoutUniversitiesInput;
        programs?: ProgramCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityUncheckedCreateWithoutCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
        programs?: ProgramUncheckedCreateNestedManyWithoutUniversityInput;
        faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput;
    };

    export type UniversityCreateOrConnectWithoutCertificateRequirementInput = {
        where: UniversityWhereUniqueInput;
        create: XOR<
            UniversityCreateWithoutCertificateRequirementInput,
            UniversityUncheckedCreateWithoutCertificateRequirementInput
        >;
    };

    export type UniversityCreateManyCertificateRequirementInputEnvelope = {
        data: UniversityCreateManyCertificateRequirementInput | UniversityCreateManyCertificateRequirementInput[];
        skipDuplicates?: boolean;
    };

    export type ProgramCreateWithoutCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        university: UniversityCreateNestedOneWithoutProgramsInput;
        faculty?: FacultyCreateNestedOneWithoutProgramsInput;
    };

    export type ProgramUncheckedCreateWithoutCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        universityId: string;
        facultyId?: string | null;
    };

    export type ProgramCreateOrConnectWithoutCertificateRequirementInput = {
        where: ProgramWhereUniqueInput;
        create: XOR<
            ProgramCreateWithoutCertificateRequirementInput,
            ProgramUncheckedCreateWithoutCertificateRequirementInput
        >;
    };

    export type ProgramCreateManyCertificateRequirementInputEnvelope = {
        data: ProgramCreateManyCertificateRequirementInput | ProgramCreateManyCertificateRequirementInput[];
        skipDuplicates?: boolean;
    };

    export type UniversityUpsertWithWhereUniqueWithoutCertificateRequirementInput = {
        where: UniversityWhereUniqueInput;
        update: XOR<
            UniversityUpdateWithoutCertificateRequirementInput,
            UniversityUncheckedUpdateWithoutCertificateRequirementInput
        >;
        create: XOR<
            UniversityCreateWithoutCertificateRequirementInput,
            UniversityUncheckedCreateWithoutCertificateRequirementInput
        >;
    };

    export type UniversityUpdateWithWhereUniqueWithoutCertificateRequirementInput = {
        where: UniversityWhereUniqueInput;
        data: XOR<
            UniversityUpdateWithoutCertificateRequirementInput,
            UniversityUncheckedUpdateWithoutCertificateRequirementInput
        >;
    };

    export type UniversityUpdateManyWithWhereWithoutCertificateRequirementInput = {
        where: UniversityScalarWhereInput;
        data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyWithoutCertificateRequirementInput>;
    };

    export type ProgramUpsertWithWhereUniqueWithoutCertificateRequirementInput = {
        where: ProgramWhereUniqueInput;
        update: XOR<
            ProgramUpdateWithoutCertificateRequirementInput,
            ProgramUncheckedUpdateWithoutCertificateRequirementInput
        >;
        create: XOR<
            ProgramCreateWithoutCertificateRequirementInput,
            ProgramUncheckedCreateWithoutCertificateRequirementInput
        >;
    };

    export type ProgramUpdateWithWhereUniqueWithoutCertificateRequirementInput = {
        where: ProgramWhereUniqueInput;
        data: XOR<
            ProgramUpdateWithoutCertificateRequirementInput,
            ProgramUncheckedUpdateWithoutCertificateRequirementInput
        >;
    };

    export type ProgramUpdateManyWithWhereWithoutCertificateRequirementInput = {
        where: ProgramScalarWhereInput;
        data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutCertificateRequirementInput>;
    };

    export type IeltsRegistrationStudentCreateManyExamInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type IeltsRegistrationStudentUpdateWithoutExamInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type IeltsRegistrationStudentUncheckedUpdateWithoutExamInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type IeltsRegistrationStudentUncheckedUpdateManyWithoutExamInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type IeltsExamCreateManyCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        dateExam: Date | string;
        isActive?: boolean | null;
        commentUser?: string | null;
        commentAdmin?: string | null;
    };

    export type JobHuntingCreateManyCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        companyId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type CVCreateManyCityInput = {
        id?: string;
        createdAt?: Date | string;
        updatedAt?: Date | string;
        studentId: string;
        description?: string | null;
        degree?: $Enums.Degree | null;
        universityTitle?: string | null;
        universityMajor?: string | null;
        graduationYear?: number | null;
        companyName?: string | null;
        position?: string | null;
        responsibilities?: string | null;
        startDate?: Date | string | null;
        endDate?: Date | string | null;
    };

    export type UniversityCreateManyCityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        logo?: string | null;
        license?: string | null;
        certificateRequirementId?: string | null;
    };

    export type IeltsExamUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        students?: IeltsRegistrationStudentUpdateManyWithoutExamNestedInput;
    };

    export type IeltsExamUncheckedUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
        students?: IeltsRegistrationStudentUncheckedUpdateManyWithoutExamNestedInput;
    };

    export type IeltsExamUncheckedUpdateManyWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        dateExam?: DateTimeFieldUpdateOperationsInput | Date | string;
        isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        commentUser?: NullableStringFieldUpdateOperationsInput | string | null;
        commentAdmin?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type JobHuntingUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
        company?: CompanyUpdateOneWithoutJobHuntingsNestedInput;
    };

    export type JobHuntingUncheckedUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        companyId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type JobHuntingUncheckedUpdateManyWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        companyId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CVUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        skills?: CvSkillUpdateManyWithoutCvNestedInput;
        tools?: CvToolUpdateManyWithoutCvNestedInput;
    };

    export type CVUncheckedUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        skills?: CvSkillUncheckedUpdateManyWithoutCvNestedInput;
        tools?: CvToolUncheckedUpdateManyWithoutCvNestedInput;
    };

    export type CVUncheckedUpdateManyWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        degree?: NullableEnumDegreeFieldUpdateOperationsInput | $Enums.Degree | null;
        universityTitle?: NullableStringFieldUpdateOperationsInput | string | null;
        universityMajor?: NullableStringFieldUpdateOperationsInput | string | null;
        graduationYear?: NullableIntFieldUpdateOperationsInput | number | null;
        companyName?: NullableStringFieldUpdateOperationsInput | string | null;
        position?: NullableStringFieldUpdateOperationsInput | string | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
        endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    };

    export type UniversityUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutUniversitiesNestedInput;
        programs?: ProgramUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUncheckedUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateManyWithoutCityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type MockRegistrationStudentCreateManyMockRegistrationInput = {
        id?: string;
        studentId: string;
        registeredAt?: Date | string;
    };

    export type MockRegistrationStudentUpdateWithoutMockRegistrationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type MockRegistrationStudentUncheckedUpdateWithoutMockRegistrationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type MockRegistrationStudentUncheckedUpdateManyWithoutMockRegistrationInput = {
        id?: StringFieldUpdateOperationsInput | string;
        studentId?: StringFieldUpdateOperationsInput | string;
        registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

    export type JobHuntingCreateManyCompanyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy: string;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        workExperience: $Enums.WorkExperience;
        cityId?: string | null;
        certificateRequirements?: string | null;
        workScheduleHours?: $Enums.WorkScheduleHours | null;
        employmentType?: $Enums.EmploymentType | null;
        workMode?: $Enums.WorkMode | null;
        salary?: number | null;
        responsibilities?: string | null;
        requirements?: string | null;
        conditions?: string | null;
    };

    export type JobHuntingUpdateWithoutCompanyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneWithoutJobHuntingsNestedInput;
    };

    export type JobHuntingUncheckedUpdateWithoutCompanyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type JobHuntingUncheckedUpdateManyWithoutCompanyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: StringFieldUpdateOperationsInput | string;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        workExperience?: EnumWorkExperienceFieldUpdateOperationsInput | $Enums.WorkExperience;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        certificateRequirements?: NullableStringFieldUpdateOperationsInput | string | null;
        workScheduleHours?: NullableEnumWorkScheduleHoursFieldUpdateOperationsInput | $Enums.WorkScheduleHours | null;
        employmentType?: NullableEnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType | null;
        workMode?: NullableEnumWorkModeFieldUpdateOperationsInput | $Enums.WorkMode | null;
        salary?: NullableIntFieldUpdateOperationsInput | number | null;
        responsibilities?: NullableStringFieldUpdateOperationsInput | string | null;
        requirements?: NullableStringFieldUpdateOperationsInput | string | null;
        conditions?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type CvSkillCreateManyCvInput = {
        skillId: string;
    };

    export type CvToolCreateManyCvInput = {
        toolId: string;
    };

    export type CvSkillUpdateWithoutCvInput = {
        skill?: SkillUpdateOneRequiredWithoutCvsNestedInput;
    };

    export type CvSkillUncheckedUpdateWithoutCvInput = {
        skillId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvSkillUncheckedUpdateManyWithoutCvInput = {
        skillId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolUpdateWithoutCvInput = {
        tool?: ToolUpdateOneRequiredWithoutCvsNestedInput;
    };

    export type CvToolUncheckedUpdateWithoutCvInput = {
        toolId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolUncheckedUpdateManyWithoutCvInput = {
        toolId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvSkillCreateManySkillInput = {
        cvId: string;
    };

    export type CvSkillUpdateWithoutSkillInput = {
        cv?: CVUpdateOneRequiredWithoutSkillsNestedInput;
    };

    export type CvSkillUncheckedUpdateWithoutSkillInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvSkillUncheckedUpdateManyWithoutSkillInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolCreateManyToolInput = {
        cvId: string;
    };

    export type CvToolUpdateWithoutToolInput = {
        cv?: CVUpdateOneRequiredWithoutToolsNestedInput;
    };

    export type CvToolUncheckedUpdateWithoutToolInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
    };

    export type CvToolUncheckedUpdateManyWithoutToolInput = {
        cvId?: StringFieldUpdateOperationsInput | string;
    };

    export type ProgramCreateManyUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        facultyId?: string | null;
    };

    export type FacultyCreateManyUniversityInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        facultyTitle: string;
        description?: string | null;
    };

    export type ProgramUpdateWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        faculty?: FacultyUpdateOneWithoutProgramsNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutProgramsNestedInput;
    };

    export type ProgramUncheckedUpdateWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramUncheckedUpdateManyWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type FacultyUpdateWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUpdateManyWithoutFacultyNestedInput;
    };

    export type FacultyUncheckedUpdateWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutFacultyNestedInput;
    };

    export type FacultyUncheckedUpdateManyWithoutUniversityInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        facultyTitle?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramCreateManyFacultyInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        certificateRequirementId?: string | null;
        studyType?: $Enums.StudyType | null;
        universityId: string;
    };

    export type ProgramUpdateWithoutFacultyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        university?: UniversityUpdateOneRequiredWithoutProgramsNestedInput;
        certificateRequirement?: CertificateRequirementsUpdateOneWithoutProgramsNestedInput;
    };

    export type ProgramUncheckedUpdateWithoutFacultyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
    };

    export type ProgramUncheckedUpdateManyWithoutFacultyInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        certificateRequirementId?: NullableStringFieldUpdateOperationsInput | string | null;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
    };

    export type UniversityCreateManyCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        description?: string | null;
        registrationDate: Date | string;
        type?: $Enums.UniType | null;
        status?: boolean | null;
        contract: string;
        contacts?: number | null;
        website?: string | null;
        email?: string | null;
        address?: string | null;
        cityId?: string | null;
        logo?: string | null;
        license?: string | null;
    };

    export type ProgramCreateManyCertificateRequirementInput = {
        id?: string;
        createdAt?: Date | string;
        createdBy?: string | null;
        updatedAt?: Date | string;
        updatedBy?: string | null;
        title: string;
        studyLanguage: $Enums.StudyLanguage;
        contract: number;
        degree: $Enums.Degree;
        studyType?: $Enums.StudyType | null;
        universityId: string;
        facultyId?: string | null;
    };

    export type UniversityUpdateWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        city?: CityUpdateOneWithoutUniversitiesNestedInput;
        programs?: ProgramUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
        programs?: ProgramUncheckedUpdateManyWithoutUniversityNestedInput;
        faculties?: FacultyUncheckedUpdateManyWithoutUniversityNestedInput;
    };

    export type UniversityUncheckedUpdateManyWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        description?: NullableStringFieldUpdateOperationsInput | string | null;
        registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string;
        type?: NullableEnumUniTypeFieldUpdateOperationsInput | $Enums.UniType | null;
        status?: NullableBoolFieldUpdateOperationsInput | boolean | null;
        contract?: StringFieldUpdateOperationsInput | string;
        contacts?: NullableIntFieldUpdateOperationsInput | number | null;
        website?: NullableStringFieldUpdateOperationsInput | string | null;
        email?: NullableStringFieldUpdateOperationsInput | string | null;
        address?: NullableStringFieldUpdateOperationsInput | string | null;
        cityId?: NullableStringFieldUpdateOperationsInput | string | null;
        logo?: NullableStringFieldUpdateOperationsInput | string | null;
        license?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramUpdateWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        university?: UniversityUpdateOneRequiredWithoutProgramsNestedInput;
        faculty?: FacultyUpdateOneWithoutProgramsNestedInput;
    };

    export type ProgramUncheckedUpdateWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    export type ProgramUncheckedUpdateManyWithoutCertificateRequirementInput = {
        id?: StringFieldUpdateOperationsInput | string;
        createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
        updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
        updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
        title?: StringFieldUpdateOperationsInput | string;
        studyLanguage?: EnumStudyLanguageFieldUpdateOperationsInput | $Enums.StudyLanguage;
        contract?: IntFieldUpdateOperationsInput | number;
        degree?: EnumDegreeFieldUpdateOperationsInput | $Enums.Degree;
        studyType?: NullableEnumStudyTypeFieldUpdateOperationsInput | $Enums.StudyType | null;
        universityId?: StringFieldUpdateOperationsInput | string;
        facultyId?: NullableStringFieldUpdateOperationsInput | string | null;
    };

    /**
     * Batch Payload for updateMany & deleteMany & createMany
     */

    export type BatchPayload = {
        count: number;
    };

    /**
     * DMMF
     */
    export const dmmf: runtime.BaseDMMF;
}
